<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DNA confesses Data speak on DNA confesses Data speak</title>
    <link>/</link>
    <description>Recent content in DNA confesses Data speak on DNA confesses Data speak</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018 Ming Tang</copyright>
    <lastBuildDate>Sun, 15 Oct 2017 00:00:00 -0400</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>KMT2D Deficiency Impairs Super-Enhancers to Confer a Glycolytic Vulnerability in Lung Cancer</title>
      <link>/publication/2020-04-03-kmt2d-lung-cancer/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 -0400</pubDate>
      
      <guid>/publication/2020-04-03-kmt2d-lung-cancer/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fast analysis of scATAC-seq data using a predefined set of genomic regions</title>
      <link>/publication/2020-03-20-kallisto-scatac/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 -0400</pubDate>
      
      <guid>/publication/2020-03-20-kallisto-scatac/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>stacked violin plot for visualizing single-cell data in Seurat</title>
      <link>/post/stacked-violin-plot-for-visualizing-single-cell-data-in-seurat/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/stacked-violin-plot-for-visualizing-single-cell-data-in-seurat/</guid>
      <description>&lt;p&gt;In &lt;code&gt;scanpy&lt;/code&gt;, there is a &lt;a href=&#34;https://icb-scanpy-tutorials.readthedocs-hosted.com/en/latest/visualizing-marker-genes.html&#34;&gt;function&lt;/a&gt; to create a stacked violin plot.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/posts_img/scanpy.png&#34; /&gt;
There is no such function in &lt;code&gt;Seurat&lt;/code&gt;, and many people were asking for this feature.
e.g. &lt;a href=&#34;https://github.com/satijalab/seurat/issues/300&#34; class=&#34;uri&#34;&gt;https://github.com/satijalab/seurat/issues/300&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/satijalab/seurat/issues/463&#34; class=&#34;uri&#34;&gt;https://github.com/satijalab/seurat/issues/463&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The developers have not implemented this feature yet. In this post, I am trying to make a stacked violin plot in &lt;code&gt;Seurat&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The idea is to create a violin plot per gene using the &lt;code&gt;VlnPlot&lt;/code&gt; in Seurat, then
customize the axis text/tick and reduce the margin for each plot and finally concatenate by
&lt;code&gt;cowplot::plot_grid&lt;/code&gt; or &lt;code&gt;patchwork::wrap_plots&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)
library(patchwork)
library(ggplot2)

## remove the x-axis text and tick
## plot.margin to adjust the white space between each plot.
## ... pass any arguments to VlnPlot in Seurat
modify_vlnplot&amp;lt;- function(obj, 
                          feature, 
                          pt.size = 0, 
                          plot.margin = unit(c(-0.75, 0, -0.75, 0), &amp;quot;cm&amp;quot;),
                          ...) {
  p&amp;lt;- VlnPlot(obj, features = feature, pt.size = pt.size, ... )  + 
    xlab(&amp;quot;&amp;quot;) + ylab(feature) + ggtitle(&amp;quot;&amp;quot;) + 
    theme(legend.position = &amp;quot;none&amp;quot;, 
          axis.text.x = element_blank(), 
          axis.ticks.x = element_blank(), 
          axis.title.y = element_text(size = rel(1), angle = 0), 
          axis.text.y = element_text(size = rel(1)), 
          plot.margin = plot.margin ) 
  return(p)
}

## extract the max value of the y axis
extract_max&amp;lt;- function(p){
  ymax&amp;lt;- max(ggplot_build(p)$layout$panel_scales_y[[1]]$range$range)
  return(ceiling(ymax))
}


## main function
StackedVlnPlot&amp;lt;- function(obj, features,
                          pt.size = 0, 
                          plot.margin = unit(c(-0.75, 0, -0.75, 0), &amp;quot;cm&amp;quot;),
                          ...) {
  
  plot_list&amp;lt;- purrr::map(features, function(x) modify_vlnplot(obj = obj,feature = x, ...))
  
  # Add back x-axis title to bottom plot. patchwork is going to support this?
  plot_list[[length(plot_list)]]&amp;lt;- plot_list[[length(plot_list)]] +
    theme(axis.text.x=element_text(), axis.ticks.x = element_line())
  
  # change the y-axis tick to only max value 
  ymaxs&amp;lt;- purrr::map_dbl(plot_list, extract_max)
  plot_list&amp;lt;- purrr::map2(plot_list, ymaxs, function(x,y) x + 
                            scale_y_continuous(breaks = c(y)) + 
                            expand_limits(y = y))

  p&amp;lt;- patchwork::wrap_plots(plotlist = plot_list, ncol = 1)
  return(p)
}&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;testing-the-function&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Testing the function&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pbmc&amp;lt;- readRDS(&amp;quot;~/projects/EvaluateSingleCellClustering/data/pbmc_5k_v3.rds&amp;quot;)
features&amp;lt;- c(&amp;quot;CD79A&amp;quot;, &amp;quot;MS4A1&amp;quot;, &amp;quot;CD8A&amp;quot;, &amp;quot;CD8B&amp;quot;, &amp;quot;LYZ&amp;quot;, &amp;quot;LGALS3&amp;quot;, &amp;quot;S100A8&amp;quot;, &amp;quot;GNLY&amp;quot;,
             &amp;quot;NKG7&amp;quot;, &amp;quot;KLRB1&amp;quot;, &amp;quot;FCGR3A&amp;quot;, &amp;quot;FCER1A&amp;quot;, &amp;quot;CST3&amp;quot;)

StackedVlnPlot(obj = pbmc, features = features)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-17-stacked-violin-plot-for-visualizing-single-cell-data-in-seurat_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## any arguments for Vlnplot can be passed to the StackedVlnPlot. e.g. idents.
## only cluster 1-5
StackedVlnPlot(obj = pbmc, features = features, idents = c(1,2,3,4,5) )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-17-stacked-violin-plot-for-visualizing-single-cell-data-in-seurat_files/figure-html/unnamed-chunk-2-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The code can be better designed, and also I should add checks &lt;code&gt;...&lt;/code&gt; using &lt;a href=&#34;https://ellipsis.r-lib.org/&#34;&gt;&lt;code&gt;ellipsis&lt;/code&gt;&lt;/a&gt; package. Nevertheless, it is working and gives me desired layout :)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Tools and tricks for a data scientist</title>
      <link>/talk/2020-tools-tricks-data-science/</link>
      <pubDate>Mon, 09 Mar 2020 14:30:00 -0400</pubDate>
      
      <guid>/talk/2020-tools-tricks-data-science/</guid>
      <description>&lt;p&gt;In the lab meeting today, I introduced some of the linux tricks and apps I have been using
for my daily work. I consider myself as a genomic data scientist. It is a bioinformatician&amp;rsquo;s rebranding according to &lt;a href=&#34;https://twitter.com/JasonWilliamsNY/status/1236671856788242436&#34; target=&#34;_blank&#34;&gt;Jason Williams&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am sharing the PDF here, hope you find some of the tricks are useful too!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Monty Hall problem- a peek through simulation</title>
      <link>/post/monty-hall-problem-a-peek-through-simulation/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/monty-hall-problem-a-peek-through-simulation/</guid>
      <description>&lt;p&gt;I am taking this STATE-80 course from Harvard Extension School. This course teaches
commonly used distributions and probability theory. The instructor Hatch is a
really good teacher and he uses simulation for all the demonstrations along with
the formulas.&lt;/p&gt;
&lt;p&gt;In week 6, we revisited the &lt;a href=&#34;https://en.wikipedia.org/wiki/Monty_Hall_problem&#34;&gt;Monty Hall problem&lt;/a&gt; which we played on the first day of
class.&lt;/p&gt;
&lt;p&gt;If you have not heard about it, I quoted from the wiki:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose you’re on a game show, and you’re given the choice of three doors: Behind one door is a car; behind the others, goats. You pick a door, say No. 1, and the host, who knows what’s behind the doors, opens another door, say No. 3, which has a goat. He then says to you, “Do you want to pick door No. 2?” Is it to your advantage to switch your choice?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/img/Monty_open_door.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The answer is that it &lt;strong&gt;is&lt;/strong&gt; to your advantage to switch the door. The probability of switching the door and get the car is &lt;span class=&#34;math inline&#34;&gt;\(2/3\)&lt;/span&gt; and the probability of not switching is &lt;span class=&#34;math inline&#34;&gt;\(1/3\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Why if I switch I have a better chance to win the car? If the host opened a door with a goat, the car is behind the door of what I have chosen and the one I have not. Is not it 50% of chance to win the car whether I switch or not? It is so counter-intuitive that even &lt;a href=&#34;https://en.wikipedia.org/wiki/Paul_Erd%C5%91s&#34;&gt;Paul Erdős&lt;/a&gt; did not get it at first.&lt;/p&gt;
&lt;p&gt;Let’s tackle it by simulation first and then I will give the formulas to deduce the result.&lt;/p&gt;
&lt;p&gt;The code was copied from Hatch’s lecture notes. The variable names are clearly given and the comments also help you understand the code.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(123)

number.of.goats &amp;lt;- 2

number.of.cars &amp;lt;- 1

cars.goats.vector &amp;lt;-
    c(
        rep( &amp;quot;Goat&amp;quot;, number.of.goats ),
        rep( &amp;quot;Car&amp;quot;, number.of.cars )
    )

total.doors &amp;lt;-
    number.of.goats + number.of.cars

door.vector &amp;lt;- 1:total.doors

number.of.replications &amp;lt;- 10000

outcome.vector &amp;lt;- logical( number.of.replications )

for( replication.index in 1:number.of.replications ) {
    
    # First, we&amp;#39;ll mix up the cars and goats
    # behind the doors
    
    random.cars.goats.vector &amp;lt;-
        sample( cars.goats.vector )
    
    
    # Next, let&amp;#39;s figure out which doors have
    # a goat behind them
    
    goat.doors.vector &amp;lt;-
        which( random.cars.goats.vector == &amp;quot;Goat&amp;quot; )
    
    
    # Now the contestant makes the initial pick
    
    initial.door.pick &amp;lt;-
        sample(
            door.vector,
            size = 1
        )
    
    # The game show host determines which doors
    # can be opened:
    
    possible.to.open.doors.vector &amp;lt;-
        setdiff(
            goat.doors.vector,
            initial.door.pick
        )
    
    if( length( possible.to.open.doors.vector ) == 1 ) {
        
        open.door &amp;lt;- possible.to.open.doors.vector
        
    } else {
        
        open.door &amp;lt;-
            sample(
                possible.to.open.doors.vector,
                size = 1
            )
        
    }
    
    possible.final.door.vector &amp;lt;-
        setdiff(
            door.vector,
            c( initial.door.pick, open.door )
        )
    
    if( length( possible.final.door.vector ) == 1 ) {
        
        final.door.pick &amp;lt;- possible.final.door.vector
        
    } else {
        
        final.door.pick &amp;lt;-
            sample(
                possible.final.door.vector,
                size = 1
            )
        
    }
    
    outcome.vector[ replication.index ] &amp;lt;-
        random.cars.goats.vector[ final.door.pick ] == &amp;quot;Car&amp;quot;

}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let’s check how many times one wins car:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat( &amp;quot;Sample mean of outcome vector:&amp;quot;,
     round( mean( outcome.vector ), 5 ) )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Sample mean of outcome vector: 0.6705&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is it surprising?! Let me explain in plain words:&lt;/p&gt;
&lt;p&gt;Let’s focus on the strategy of always switching the door after the host opens a door.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;If initially you picked a door behind which there is a car, the host opened a door (from either one) with goat, and you switch. The probability of getting the car is &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;. You had the car behind your initial pick! If you switch, you get the goat.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If initially you picked a door behind which there is a goat, the host &lt;strong&gt;had&lt;/strong&gt; to open the other door with goat, and you switch. The probability of getting the car is &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;, because the host has leaked the information that the car is in the other door that you are going to switch to.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The probability of picking a door that a car behind the door for your initial pick is &lt;span class=&#34;math inline&#34;&gt;\(1/3\)&lt;/span&gt; (from 1, your chance is 0 to win the car). The probability of picking a door that a goat is behind the door for your initial pick is &lt;span class=&#34;math inline&#34;&gt;\(2/3\)&lt;/span&gt; (from 2, your chance is 1 to win the car). So in the long run, you have &lt;span class=&#34;math inline&#34;&gt;\(2/3\)&lt;/span&gt; chance to win the car.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&#34;calculate-by-formulas&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Calculate by formulas&lt;/h3&gt;
&lt;p&gt;The trick to using conditional probabilities is to pick the right event to condition on. For the Monty Hall problem, we will condition on the event that Marie selects the door with the car behind it as her initial choice, and we’ll denote this event &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;. Then the event &lt;span class=&#34;math inline&#34;&gt;\(A^c\)&lt;/span&gt; is that Marie does &lt;em&gt;not&lt;/em&gt; select the car door as her initial choice, but instead selects a door with a goat behind it. Also, let &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; denote the event the event that Marie wins the car in the end. Now suppose Marie adopts the strategy of accepting the offer to change her initial selection after seeing another door opened with a goat behind it.&lt;/p&gt;
&lt;p&gt;As I mentioned above:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B\ |\ A)\ =\ 0
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B\ |\ A^c)\ =\ 1
\]&lt;/span&gt;
What’s the probability that Marie will initially select the door with the car behind it? It’s just 1/3. So we have:
&lt;span class=&#34;math display&#34;&gt;\[
\Pr(A)\ =\ 1/3
\]&lt;/span&gt;
Then by the complement trick, we have:
&lt;span class=&#34;math display&#34;&gt;\[
\Pr(A^c)\ =\ 1 - \Pr(A)\ =\ 2/3
\]&lt;/span&gt;
Now we can use the Law of Total Probability:
&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B)\ =\ \Pr(B\ |\ A) \cdot \Pr(A) + \Pr(B\ |\ A^c) \cdot \Pr(A^c)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Substituting, we obtain:
&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B)\ =\ \left ( 0 \cdot \frac{1}{3} \right ) + \left ( 1 \cdot \frac{2}{3} \right )\ =\ \frac{2}{3}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;monty-hall-with-more-doors&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Monty Hall with more doors&lt;/h3&gt;
&lt;p&gt;Let’s try a Monty hall game with 4 doors behind which are 1 car and 3 goats. Just change&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;number.of.goats &amp;lt;- 3

number.of.cars &amp;lt;- 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will get around &lt;span class=&#34;math inline&#34;&gt;\(3/8\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;With 4 doors, if you initially select a door with a goat, the host opens a door with goat, you will be leaving two doors: one with goat and the other one with car. So you will have &lt;span class=&#34;math inline&#34;&gt;\(1/2\)&lt;/span&gt; chance to win the car.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B)\ =\ \left ( 0 \cdot \frac{1}{4} \right ) + \left ( 1/2 \cdot \frac{3}{4} \right )\ =\ \frac{3}{8}
\]&lt;/span&gt;
It is always to your advantage to switch the door because the host has leaked information about the car :)&lt;/p&gt;
&lt;p&gt;Simulation is a very good tool to teach statistic concept and especially for the non-intuitive ones.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>compare kallisto-bustools and cellranger for single nuclei sequencing data</title>
      <link>/post/compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data/</guid>
      <description>&lt;p&gt;In my last &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/cellranger-mk-reference-with-transgenes/&#34;&gt;post&lt;/a&gt;, I tried to include transgenes to the cellranger reference and want to
get the counts for the transgenes. However, even after I extended the &lt;code&gt;Tdtomato&lt;/code&gt; and &lt;code&gt;Cre&lt;/code&gt; with
the potential 3’UTR, I still get very few cells express them. This is confusing to me.&lt;/p&gt;
&lt;p&gt;My next thought is: maybe the STAR aligner is doing something weird that excluded those reads?
At this point, I want to give &lt;a href=&#34;https://github.com/pachterlab/kb_python&#34;&gt;&lt;code&gt;kb-python&lt;/code&gt;&lt;/a&gt;, a python wrapper on &lt;code&gt;kallisto&lt;/code&gt; and &lt;code&gt;bustools&lt;/code&gt; a try.&lt;/p&gt;
&lt;p&gt;Before &lt;code&gt;kb-python&lt;/code&gt;, the workflow for processing single-nuclei data using &lt;code&gt;kallisto&lt;/code&gt; and &lt;code&gt;bustools&lt;/code&gt; is cumbersome. see this &lt;a href=&#34;https://github.com/BUStools/getting_started/blob/master/kallisto_bus_mouse_nuclei_tutorial.ipynb&#34;&gt;tutorial&lt;/a&gt; and &lt;a href=&#34;https://www.kallistobus.tools/velocity_index_tutorial.html&#34;&gt;Building a cDNA and intron index&lt;/a&gt;. I was unwilling to try it out until &lt;code&gt;kb-python&lt;/code&gt; supports single-nuclei data as well. &lt;code&gt;kb-python&lt;/code&gt; automates all the steps and greatly simplify the processing.&lt;/p&gt;
&lt;p&gt;kb-python uses the gtf file and genome fasta file for indexing, and it will create the cDNA and intron fasta and the transcript to gene mapping file on the fly.&lt;/p&gt;
&lt;p&gt;It requires the entries with exons should also have a corresponding entry with transcript in the third column of the gtf file.&lt;/p&gt;
&lt;p&gt;Just duplicated the rows below and concatenate with the &lt;code&gt;genes.gtf&lt;/code&gt; from the cellranger website.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;tdtomato        custom  transcript      1       1880    .       +       .       gene_id &amp;quot;ENSMUSGtdtomato&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;tdtomato1&amp;quot;; gene_name &amp;quot;Tdtomato&amp;quot;
tdtomato        custom  exon    1       1880    .       +       .       gene_id &amp;quot;ENSMUSGtdtomato&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;tdtomato1&amp;quot;; gene_name &amp;quot;Tdtomato&amp;quot;
cre     custom  transcript      1       1067    .       +       .       gene_id &amp;quot;ENSMUSGcre&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;cre1&amp;quot;; gene_name &amp;quot;Cre&amp;quot;
cre     custom  exon    1       1067    .       +       .       gene_id &amp;quot;ENSMUSGcre&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;cre1&amp;quot;; gene_name &amp;quot;Cre&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The developers of &lt;code&gt;kb-python&lt;/code&gt; included a &lt;a href=&#34;https://colab.research.google.com/github/pachterlab/kallistobustools/blob/master/notebooks/kb_single_nucleus.ipynb&#34;&gt;tutorial&lt;/a&gt; for pre-processing single-nuclei data.&lt;/p&gt;
&lt;p&gt;Following it and make a reference:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;## install kbpython
conda create -n kbpython pip
conda activate kbpython
pip install git+https://github.com/pachterlab/kb_python@count-kite

# make a reference
# you can specify -n 8 to split the index to 8 files to reduce the memory usage.
time kb ref -i index.idx -g t2g.txt -f1 cdna.fa -f2 intron.fa -c1 cdna_t2c.txt -c2 intron_t2c.txt --workflow nucleus -n 1 genome.fa genes.gtf &amp;gt; log.txt  2&amp;gt;&amp;amp;1

real    266m53.243s
user    229m5.505s
sys     37m7.056s

## count
ref_dir=&amp;quot;/reference_genome_by_tommy/kallisto_bus_ref/mm10_nuclei_single&amp;quot;

fastq_dir=&amp;quot;novaseq/outs/fastq_path/HJF3WDMXX/Sample1&amp;quot;

time kb count -i ${ref_dir}/index.idx \
-g ${ref_dir}/t2g.txt -c1 ${ref_dir}/cdna_t2c.txt -c2 ${ref_dir}/intron_t2c.txt -x 10xv2 -o sample1_kb_h5ad -t 15 --workflow nucleus --h5ad \
${fastq_dir}/Sample1_S1_L001_R1_001.fastq.gz \
${fastq_dir}/Sample1_S1_L001_R2_001.fastq.gz \
${fastq_dir}/Sample1_S1_L002_R1_001.fastq.gz \
${fastq_dir}/Sample1_S1_L002_R2_001.fastq.gz

real    101m39.986s
user    899m28.925s
sys     114m7.979s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside the &lt;code&gt;sample1_kb_h5ad&lt;/code&gt; output folder, there is a &lt;code&gt;counts_unfiltered&lt;/code&gt; folder which contains the files we are going to work with.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;ls counts_unfiltered/
adata.h5ad  spliced.barcodes.txt  spliced.genes.txt  spliced.mtx  unspliced.barcodes.txt  unspliced.genes.txt  unspliced.mtx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two matrices, spliced and unspliced. We need to sum up them together to get the final counts. The &lt;code&gt;adata.h5ad&lt;/code&gt; is H5AD file contains the summed up matrix.&lt;/p&gt;
&lt;p&gt;Some tips after playing with &lt;code&gt;kb-python&lt;/code&gt; for a bit:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Specify the wrong protocol will give you errors. &lt;strong&gt;If you specify &lt;code&gt;10xv2&lt;/code&gt;, go and check the raw fastq and make sure it is 16 bp cell barcode + 10 bp UMI. If you specify &lt;code&gt;10xv3&lt;/code&gt;, make sure it is 16 bp cell barcode + 12 bp UMI.&lt;/strong&gt; Ideally, &lt;code&gt;kb-python&lt;/code&gt; should check the input.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sometimes, if you specify &lt;code&gt;--h5ad&lt;/code&gt;, when combining the two spliced and unspliced sparse matrix, it gives error: &amp;quot;in _get_arrayXarray csr_sample_values(M, N, self.indptr, self.indices, self.data, ValueError: could not convert integer scalar&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you specify whitelist by &lt;code&gt;-w&lt;/code&gt;, use the unzipped txt file. Otherwise, you may get “died with &amp;lt;Signals.SIGSEGV: 11&amp;gt;” error.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;kb-python&lt;/code&gt; is strict with your gtf file. You may get an error when making references. I had some non-model gff3 file downloaded from NCBI and then converted to gtf using &lt;code&gt;gffread&lt;/code&gt;, but &lt;code&gt;kb-python&lt;/code&gt; complains about it.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;downstream-analysis-in-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Downstream analysis in R&lt;/h3&gt;
&lt;p&gt;Now, let’s import the data into R.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)

Sample1&amp;lt;- ReadH5AD(&amp;quot;~/github_repos/blogdown_data/counts_unfiltered/adata.h5ad&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I got this error:
“Pulling expression matrices and metadata
Data is unscaled
Error in file[[&amp;quot;obs&amp;quot;]][] :
object of type ‘environment’ is not subsettable”&lt;/p&gt;
&lt;p&gt;I have to work with the &lt;code&gt;.mtx&lt;/code&gt; files.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Matrix)
library(tidyverse)

# a function to read in the kallisto count matrix
read_kallisto_sparse&amp;lt;- function(cells, regions, mtx){
  mtx&amp;lt;- Matrix::readMM(mtx)
  # the sparse matrix with rows are cells and columns are peaks/features
  mtx&amp;lt;- t(mtx)
  regions&amp;lt;- read_tsv(regions, col_names = FALSE)
  cells&amp;lt;- read_tsv(cells, col_names = FALSE)
  rownames(mtx)&amp;lt;- regions$X1
  # cellranger add -1 to the cell barcode, I add it for later compare with cellranger output
  colnames(mtx)&amp;lt;- paste0(cells$X1, &amp;quot;-1&amp;quot;)
  return(mtx)
}

spliced&amp;lt;- read_kallisto_sparse(cells = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/spliced.barcodes.txt&amp;quot;,
                               regions = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/spliced.genes.txt&amp;quot;,
                               mtx = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/spliced.mtx&amp;quot;)

unspliced&amp;lt;- read_kallisto_sparse(cells = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/unspliced.barcodes.txt&amp;quot;,
                               regions = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/unspliced.genes.txt&amp;quot;,
                               mtx = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/unspliced.mtx&amp;quot;)

## common index
common_cells&amp;lt;- intersect(colnames(spliced), colnames(unspliced))
spliced&amp;lt;- spliced[, colnames(spliced) %in% common_cells]
unspliced&amp;lt;- unspliced[, colnames(unspliced) %in% common_cells]

# make sure the cells and genes are lined up
all.equal(colnames(spliced), colnames(unspliced))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all.equal(rownames(spliced), rownames(unspliced))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## add up the counts
Sample1_kb&amp;lt;- spliced + unspliced

# the rowname and colnames are lost, put them back
rownames(Sample1_kb)&amp;lt;- rownames(spliced)
colnames(Sample1_kb)&amp;lt;- colnames(spliced)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The matrices are unfiltered, we can filter out some cells using the knee-plot. There are several nice posts on how to
by the &lt;a href=&#34;https://github.com/CGATOxford/UMI-tools&#34;&gt;&lt;code&gt;UMI-tools&lt;/code&gt;&lt;/a&gt; developers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://cgatoxford.wordpress.com/2017/05/18/estimating-the-number-of-true-cell-barcodes-in-single-cell-rna-seq/&#34; class=&#34;uri&#34;&gt;https://cgatoxford.wordpress.com/2017/05/18/estimating-the-number-of-true-cell-barcodes-in-single-cell-rna-seq/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://cgatoxford.wordpress.com/2017/05/23/estimating-the-number-of-true-cell-barcodes-in-single-cell-rna-seq-part-2/&#34; class=&#34;uri&#34;&gt;https://cgatoxford.wordpress.com/2017/05/23/estimating-the-number-of-true-cell-barcodes-in-single-cell-rna-seq-part-2/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(DropletUtils)

tot_counts &amp;lt;- Matrix::colSums(Sample1_kb)

## many of them have very low counts per cell
summary(tot_counts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     0.0     2.0     3.0   287.2    16.0 96681.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Compute barcode rank from Dropletutils
bc_rank &amp;lt;- barcodeRanks(Sample1_kb)

qplot(bc_rank$total, bc_rank$rank, geom = &amp;quot;line&amp;quot;) +
  geom_vline(xintercept = bc_rank$knee, color = &amp;quot;blue&amp;quot;, linetype = 2) +
  geom_vline(xintercept = bc_rank$inflection, color = &amp;quot;green&amp;quot;, linetype = 2) +
  annotate(&amp;quot;text&amp;quot;, y = 1000, x = 1.5 * c(bc_rank$knee, bc_rank$inflection),
           label = c(&amp;quot;knee&amp;quot;, &amp;quot;inflection&amp;quot;), color = c(&amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;)) +
  scale_x_log10() +
  scale_y_log10() +
  labs(y = &amp;quot;Barcode rank&amp;quot;, x = &amp;quot;Total UMI count&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Filter the matrix using this cutoff
Sample1_kb &amp;lt;- Sample1_kb[, tot_counts &amp;gt; bc_rank$inflection]

## 73676 cells are left
dim(Sample1_kb)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 28694 73676&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is way more than the cells we have in this experiment. As I will show later, cellranger gives ~10,000 cells which is about the right number of cells we have.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;kallisto-bustools-and-cellranger-correlation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;kallisto + bustools and cellranger correlation&lt;/h3&gt;
&lt;p&gt;cellranger output&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)
# this is the cellranger output. read in the sparse matrix
Sample1_cr&amp;lt;- Read10X_h5(filename = &amp;quot;~/github_repos/blogdown_data/filtered_feature_bc_matrix.h5&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## cells pass cellranger and Seurat filter
colnames(Sample1_cr) %&amp;gt;% 
  length()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10937&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## how many cells from the kb-python are in the cellranger output
(colnames(Sample1_kb) %in% colnames(Sample1_cr)) %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
## FALSE  TRUE 
## 62739 10937&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All the cells in &lt;code&gt;kb-python&lt;/code&gt; output are in &lt;code&gt;cellranger&lt;/code&gt; output.&lt;/p&gt;
&lt;p&gt;subset the &lt;code&gt;kb-python&lt;/code&gt; matrix and rearrange the rows and columns to match each other.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# kb-python uses the ENSMBEL id
rownames(Sample1_kb) %&amp;gt;% head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;ENSMUSG00000026535.9&amp;quot;  &amp;quot;ENSMUSG00000026315.13&amp;quot; &amp;quot;ENSMUSG00000000817.10&amp;quot;
## [4] &amp;quot;ENSMUSG00000063558.4&amp;quot;  &amp;quot;ENSMUSG00000001138.13&amp;quot; &amp;quot;ENSMUSG00000001143.13&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cellranger uses the gene symbol
rownames(Sample1_cr) %&amp;gt;% head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Xkr4&amp;quot;    &amp;quot;Gm1992&amp;quot;  &amp;quot;Gm37381&amp;quot; &amp;quot;Rp1&amp;quot;     &amp;quot;Rp1.1&amp;quot;   &amp;quot;Sox17&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## read in the transcript to gene map file t2g.txt was created when making kb-python index.
t2g&amp;lt;- read_tsv(&amp;quot;~/github_repos/blogdown_data/t2g.txt&amp;quot;, col_names = FALSE, col_types = cols(.default = col_character()))

head(t2g)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 8
##   X1             X2             X3     X4       X5    X6      X7      X8   
##   &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;
## 1 ENSMUST000000… ENSMUSG000000… Ifi20… Ifi202b… 1     173962… 173982… -    
## 2 ENSMUST000000… ENSMUSG000000… Serpi… Serpinb… 1     107590… 107608… +    
## 3 ENSMUST000000… ENSMUSG000000… Fasl   Fasl-001 1     161780… 161788… -    
## 4 ENSMUST000000… ENSMUSG000000… Aox1   Aox1-001 1     580299… 581064… +    
## 5 ENSMUST000000… ENSMUSG000000… Cnnm3  Cnnm3-0… 1     365118… 365282… +    
## 6 ENSMUST000000… ENSMUSG000000… Lman2l Lman2l-… 1     364231… 364452… -&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ensemble2symbol&amp;lt;- t2g %&amp;gt;% 
  dplyr::select(X2,X3) %&amp;gt;% distinct()

head(ensemble2symbol)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##   X2                    X3      
##   &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;   
## 1 ENSMUSG00000026535.9  Ifi202b 
## 2 ENSMUSG00000026315.13 Serpinb8
## 3 ENSMUSG00000000817.10 Fasl    
## 4 ENSMUSG00000063558.4  Aox1    
## 5 ENSMUSG00000001138.13 Cnnm3   
## 6 ENSMUSG00000001143.13 Lman2l&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# not all genes in cellranger matrix are in this mapping file...
table(rownames(Sample1_cr) %in% ensemble2symbol$X3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
##    67 28627&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## what are the genes?
problematic_genes&amp;lt;- rownames(Sample1_cr)[!(rownames(Sample1_cr) %in% ensemble2symbol$X3)]
problematic_genes&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Rp1.1&amp;quot;           &amp;quot;Gm15853.1&amp;quot;       &amp;quot;Gm16701.1&amp;quot;      
##  [4] &amp;quot;Olfr1284.1&amp;quot;      &amp;quot;Olfr1309.1&amp;quot;      &amp;quot;Olfr1316.1&amp;quot;     
##  [7] &amp;quot;Gm2464.1&amp;quot;        &amp;quot;Schip1.1&amp;quot;        &amp;quot;Flg.1&amp;quot;          
## [10] &amp;quot;Flg.2&amp;quot;           &amp;quot;Flg.3&amp;quot;           &amp;quot;Flg.4&amp;quot;          
## [13] &amp;quot;Flg.5&amp;quot;           &amp;quot;Flg.6&amp;quot;           &amp;quot;Hist2h2bb.1&amp;quot;    
## [16] &amp;quot;Smim20.1&amp;quot;        &amp;quot;Dancr.1&amp;quot;         &amp;quot;Gbp6.1&amp;quot;         
## [19] &amp;quot;D130017N08Rik.1&amp;quot; &amp;quot;Umad1.1&amp;quot;         &amp;quot;Ccdc142.1&amp;quot;      
## [22] &amp;quot;Zfand4.1&amp;quot;        &amp;quot;C1s2.1&amp;quot;          &amp;quot;Atn1.1&amp;quot;         
## [25] &amp;quot;Pik3c2g.1&amp;quot;       &amp;quot;Nova2.1&amp;quot;         &amp;quot;Apoc2.1&amp;quot;        
## [28] &amp;quot;Ltbp4.1&amp;quot;         &amp;quot;U2af1l4.1&amp;quot;       &amp;quot;Tead2.1&amp;quot;        
## [31] &amp;quot;Cd37.1&amp;quot;          &amp;quot;Tulp2.1&amp;quot;         &amp;quot;Tulp2.2&amp;quot;        
## [34] &amp;quot;Ntn5.1&amp;quot;          &amp;quot;Ntn5.2&amp;quot;          &amp;quot;Syngr4.1&amp;quot;       
## [37] &amp;quot;l7Rn6.1&amp;quot;         &amp;quot;Itgam.1&amp;quot;         &amp;quot;Tgfb1i1.1&amp;quot;      
## [40] &amp;quot;Olfr790.1&amp;quot;       &amp;quot;Olfr809.1&amp;quot;       &amp;quot;Map2k7.1&amp;quot;       
## [43] &amp;quot;Olfr730.1&amp;quot;       &amp;quot;Fbxw14.1&amp;quot;        &amp;quot;Olfr1396.1&amp;quot;     
## [46] &amp;quot;Olfr1366.1&amp;quot;      &amp;quot;3110039M20Rik.1&amp;quot; &amp;quot;Ighv5-8.1&amp;quot;      
## [49] &amp;quot;Ighv1-13.1&amp;quot;      &amp;quot;4930556M19Rik.1&amp;quot; &amp;quot;Sgsm3.1&amp;quot;        
## [52] &amp;quot;Olfr170.1&amp;quot;       &amp;quot;Olfr108.1&amp;quot;       &amp;quot;Olfr126.1&amp;quot;      
## [55] &amp;quot;Pcdha11.1&amp;quot;       &amp;quot;Pcdhga8.1&amp;quot;       &amp;quot;Olfr1496.1&amp;quot;     
## [58] &amp;quot;Fam205a2.1&amp;quot;      &amp;quot;Ccl21b.1&amp;quot;        &amp;quot;Il11ra2.1&amp;quot;      
## [61] &amp;quot;Ccl27a.1&amp;quot;        &amp;quot;Ccl21c.1&amp;quot;        &amp;quot;Gm3286.1&amp;quot;       
## [64] &amp;quot;Ccl27a.2&amp;quot;        &amp;quot;Il11ra2.2&amp;quot;       &amp;quot;Ccl19.1&amp;quot;        
## [67] &amp;quot;Ccl21a.1&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## how about we remove the .1 and .2
problematic_genes %&amp;gt;% str_replace(&amp;quot;\\.[1-9]$&amp;quot;, &amp;quot;&amp;quot;) %in% ensemble2symbol$X3 %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
## TRUE 
##   67&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;They all are in the &lt;code&gt;ensemble2symbol&lt;/code&gt; file now if remove the version number.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# there are other gene symbols ends with .1 and .2... but has a corresponding name in ensemble2symbol...
# I can not use str_replace(&amp;quot;\\.1$&amp;quot;, &amp;quot;&amp;quot;)
# rownames(Sample1_cr) [rownames(Sample1_cr) %&amp;gt;% str_detect(&amp;quot;\\.[0-9]$&amp;quot;) ] 

# find the index and replace with the symbols without version number
problematic_indx&amp;lt;- which(rownames(Sample1_cr) %in% problematic_genes)

rownames(Sample1_cr)[problematic_indx]&amp;lt;- problematic_genes %&amp;gt;% 
  str_replace(&amp;quot;\\.[1-9]$&amp;quot;, &amp;quot;&amp;quot;)

rownames(Sample1_kb) %in% ensemble2symbol$X2 %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
##  TRUE 
## 28694&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rownames(Sample1_cr) %in% ensemble2symbol$X3 %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
##  TRUE 
## 28694&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# a dictionary like vector with names are ensemble id and values are gene symbol
gene_map&amp;lt;- ensemble2symbol %&amp;gt;% tibble::deframe() 

## change the ensembel id with gene symbol
rownames(Sample1_kb)&amp;lt;- gene_map[rownames(Sample1_kb)] %&amp;gt;% unname()

#rearrange the columns and rows
Sample1_kb&amp;lt;- Sample1_kb[rownames(Sample1_cr),colnames(Sample1_cr)]

## final check the rows and columns are lined up
all.equal(colnames(Sample1_kb), colnames(Sample1_cr))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all.equal(rownames(Sample1_kb), rownames(Sample1_cr))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let me check the transgene expression in both pipelines.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# from kb-python
table(Sample1_kb[&amp;quot;Cre&amp;quot;, ] !=0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
## 10728   209&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(Sample1_kb[&amp;quot;Tdtomato&amp;quot;, ]!=0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
## 10715   222&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# from cellranger
table(Sample1_cr[&amp;quot;Cre&amp;quot;, ] !=0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
## 10742   195&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(Sample1_cr[&amp;quot;Tdtomato&amp;quot;, ]!=0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
## 10783   154&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kb-python&lt;/code&gt; detected more cells express the transgens, but still the number is very low. I will
need to keep investigating the reason.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;calculate-the-correlation-between-the-two-pipelines&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Calculate the correlation between the two pipelines&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cor(matrixA, matrixB)&lt;/code&gt; calculates the pair-wise correlation, one can use diag() to extract the
column correlations, but for big data matrix, it is not efficient.&lt;/p&gt;
&lt;p&gt;googled and found &lt;a href=&#34;https://stackoverflow.com/questions/6713973/how-do-i-calculate-correlation-between-corresponding-columns-of-two-matrices-and&#34; class=&#34;uri&#34;&gt;https://stackoverflow.com/questions/6713973/how-do-i-calculate-correlation-between-corresponding-columns-of-two-matrices-and&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# from arrayMagic Bioconductor package
colCors = function(x, y) { 
   sqr = function(x) x*x
   if(!is.matrix(x)||!is.matrix(y)||any(dim(x)!=dim(y)))
     stop(&amp;quot;Please supply two matrices of equal size.&amp;quot;)
   x   = sweep(x, 2, colMeans(x))
   y   = sweep(y, 2, colMeans(y))
   cor = colSums(x*y) /  sqrt(colSums(sqr(x))*colSums(sqr(y)))
   return(cor)
}

cors&amp;lt;- colCors(as.matrix(Sample1_cr), as.matrix(Sample1_kb))
head(cors)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## AAACCCAAGCAAGTGC-1 AAACCCAAGCGTGAGT-1 AAACCCAAGCTAGAAT-1 
##          0.9667430          0.8787159          0.9046970 
## AAACCCAAGCTCGTGC-1 AAACCCAAGCTGAAGC-1 AAACCCAAGCTGTCCG-1 
##          0.7184020          0.9463552          0.9077403&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I will make figures similar to the ones in the original &lt;code&gt;kallisto&lt;/code&gt; + &lt;code&gt;bustool&lt;/code&gt; paper &lt;a href=&#34;https://www.biorxiv.org/content/10.1101/673285v1&#34; class=&#34;uri&#34;&gt;https://www.biorxiv.org/content/10.1101/673285v1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Fig2B plots a scatter plot of the total number of UMIs for each cell from the two pipelines.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# set up the theme for all figures
# take suggestions for theme https://twitter.com/ChenxinLi2/status/1228958667686338560
theme_set(theme_minimal() +
  theme(axis.line = element_line(colour = &amp;quot;black&amp;quot;, 
                      size = 1, linetype = &amp;quot;solid&amp;quot;),
        text = element_text(size = 18, color = &amp;quot;black&amp;quot;),  #face = &amp;quot;bold&amp;quot;
        axis.text.x = element_text(size = 18, color = &amp;quot;black&amp;quot;),
        axis.text.y = element_text(size = 18, color = &amp;quot;black&amp;quot;)))


Matrix::colSums(Sample1_cr) %&amp;gt;%
  enframe(name = &amp;quot;cell&amp;quot;, value = &amp;quot;CR_totalUMI&amp;quot;) %&amp;gt;% 
  bind_cols(KB_totalUMI= Matrix::colSums(Sample1_kb)) %&amp;gt;% 
  ggplot(aes(x = KB_totalUMI, y = CR_totalUMI)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  coord_equal() + 
  geom_abline(slope =1, intercept = 0, linetype=2, color = &amp;quot;red&amp;quot;) +
  ggtitle(&amp;quot;total UMI per cell\nkb-python vs cellranger&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kb-python always have more counts than cellranger for single-nuclei data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fig2C plots the correlation of counts from two pipelines for the same cell.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# install.packages(&amp;quot;ggpointdensity&amp;quot;)
library(ggpointdensity)
library(viridis)
df&amp;lt;- Matrix::colSums(Sample1_kb) %&amp;gt;%
  enframe(name = &amp;quot;cell&amp;quot;, value = &amp;quot;KB_totalUMI&amp;quot;) %&amp;gt;%
  bind_cols(cors = cors) 


ggplot(df, aes(x= KB_totalUMI, y = cors)) +
  geom_pointdensity(adjust = .2) +
  scale_x_log10() + 
  scale_color_viridis() +
  ggtitle(&amp;quot;pearson correlation per cell as a \nfunction of total UMI by kb-python&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;most of the correlations are higher than 0.8.&lt;/strong&gt;, but not as good as for the single-cell data showed in the biorxiv paper.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(df$cors &amp;lt; 0.8)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
##  9016  1921&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition, too many zeros can inflate the correlation.
Let’s remove the genes if the counts from two pipelines are both 0s.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapply(cor, as.data.frame(x), as.data.frame(y))

# map2 takes columns of df1 and df2 as argument and apply cor function to each pair of columns
cors2&amp;lt;- map2_dbl( as.data.frame(Sample1_cr), as.data.frame(Sample1_kb), cor)
all.equal(cors, cors2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor_remove_zero&amp;lt;- function(x,y){
  indx&amp;lt;- (x==0 &amp;amp; y==0)
  return(cor(x[!indx],y[!indx]))
}

cors_remove_zeros&amp;lt;- map2_dbl( as.data.frame(Sample1_cr), as.data.frame(Sample1_kb), cor_remove_zero)

df2&amp;lt;- Matrix::colSums(Sample1_kb) %&amp;gt;%
  enframe(name = &amp;quot;cell&amp;quot;, value = &amp;quot;KB_totalUMI&amp;quot;) %&amp;gt;%
  bind_cols(cors_remove_zeros = cors_remove_zeros) 

# boxplot for correlations before and after removing 0s 
inner_join(df, df2) %&amp;gt;%
  gather(3:4, key = &amp;quot;group&amp;quot;, value = &amp;quot;correlation&amp;quot;) %&amp;gt;% 
  ggplot(aes(x=group, y = correlation)) +
  geom_boxplot() +
  xlab(&amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We see removing zeros decreases the correlation a bit.&lt;/p&gt;
&lt;p&gt;Let’s plot side by side.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1&amp;lt;- ggplot(df, aes(x= KB_totalUMI, y = cors)) +
  geom_pointdensity(adjust = .2) +
  scale_x_log10() + 
  scale_color_viridis() +
  ggtitle(&amp;quot;correlation&amp;quot;)


p2&amp;lt;- ggplot(df2, aes(x= KB_totalUMI, y = cors)) +
  geom_pointdensity(adjust = .2) +
  scale_x_log10() + 
  scale_color_viridis() +
  ggtitle(&amp;quot;correlation removing 0s&amp;quot;)

#install.packages(&amp;quot;patchwork&amp;quot;)
# use patchwork to combine the legends from multiple plots
library(patchwork)
p1 / p2 + plot_layout(guides = &amp;quot;collect&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I have not seen many posts comparing cellranger with &lt;code&gt;kallisto + bustools&lt;/code&gt; for single nuclei data. I hope this post opens the discussion for the single-cell RNAseq community.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kallisto + bustools&lt;/code&gt; always gives more counts for single-nuclei data, why is that?&lt;/li&gt;
&lt;li&gt;Why the correlation between cellranger and &lt;code&gt;kallisto + bustools&lt;/code&gt; is not as good for single-nuclei data?&lt;/li&gt;
&lt;li&gt;For those cells with bad correlation, what’s going on?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Comment below!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>cellranger mk reference with transgenes</title>
      <link>/post/cellranger-mk-reference-with-transgenes/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/cellranger-mk-reference-with-transgenes/</guid>
      <description>

&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;

&lt;p&gt;I am working on some 10x scRNAseq data from transgenic mouse. The cells express &lt;a href=&#34;https://www.fpbase.org/protein/tdtomato/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Tdtomato&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Cre-Lox_recombination&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Cre&lt;/code&gt;&lt;/a&gt; genes. I need to add those to the &lt;code&gt;cellranger&lt;/code&gt; reference to get the counts for those two genes.&lt;/p&gt;

&lt;h3 id=&#34;the-journey-to-the-solution&#34;&gt;The journey to the solution&lt;/h3&gt;

&lt;p&gt;Following &lt;a href=&#34;https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/advanced/references#addgene&#34; target=&#34;_blank&#34;&gt;https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/advanced/references#addgene&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I created a &lt;code&gt;fasta&lt;/code&gt; file for the two transgenes: &lt;code&gt;tdTomato&lt;/code&gt; and &lt;code&gt;Cre&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tdtomato_cre.fa&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;tdtomato dna:chromosome chromosome:GRCm38:tdtomato:1:1431:1 REF
ATGGTGAGCAAGGGCGAGGAGGTCATCAAAGAGTTCATGCGCTTCAAGGTGCGCATGGAGGGCTCCATGAACGGCCACGAGTTCGAGATCGAGGGCGAGGGCGAGGGCCGCCCCTACGAGGGCACCCAGACCGCCAAGCTGAAGGTGACCAAGGGCGGCCCCCTGCCCTTCGCCTGGGACATCCTGTCCCCCCAGTTCATGTACGGCTCCAAGGCGTACGTGAAGCACCCCGCCGACATCCCCGATTACAAGAAGCTGTCCTTCCCCGAGGGCTTCAAGTGGGAGCGCGTGATGAACTTCGAGGACGGCGGTCTGGTGACCGTGACCCAGGACTCCTCCCTGCAGGACGGCACGCTGATCTACAAGGTGAAGATGCGCGGCACCAACTTCCCCCCCGACGGCCCCGTAATGCAGAAGAAGACCATGGGCTGGGAGGCCTCCACCGAGCGCCTGTACCCCCGCGACGGCGTGCTGAAGGGCGAGATCCACCAGGCCCTGAAGCTGAAGGACGGCGGCCACTACCTGGTGGAGTTCAAGACCATCTACATGGCCAAGAAGCCCGTGCAACTGCCCGGCTACTACTACGTGGACACCAAGCTGGACATCACCTCCCACAACGAGGACTACACCATCGTGGAACAGTACGAGCGCTCCGAGGGCCGCCACCACCTGTTCCTGGGGCATGGCACCGGCAGCACCGGCAGCGGCAGCTCCGGCACCGCCTCCTCCGAGGACAACAACATGGCCGTCATCAAAGAGTTCATGCGCTTCAAGGTGCGCATGGAGGGCTCCATGAACGGCCACGAGTTCGAGATCGAGGGCGAGGGCGAGGGCCGCCCCTACGAGGGCACCCAGACCGCCAAGCTGAAGGTGACCAAGGGCGGCCCCCTGCCCTTCGCCTGGGACATCCTGTCCCCCCAGTTCATGTACGGCTCCAAGGCGTACGTGAAGCACCCCGCCGACATCCCCGATTACAAGAAGCTGTCCTTCCCCGAGGGCTTCAAGTGGGAGCGCGTGATGAACTTCGAGGACGGCGGTCTGGTGACCGTGACCCAGGACTCCTCCCTGCAGGACGGCACGCTGATCTACAAGGTGAAGATGCGCGGCACCAACTTCCCCCCCGACGGCCCCGTAATGCAGAAGAAGACCATGGGCTGGGAGGCCTCCACCGAGCGCCTGTACCCCCGCGACGGCGTGCTGAAGGGCGAGATCCACCAGGCCCTGAAGCTGAAGGACGGCGGCCACTACCTGGTGGAGTTCAAGACCATCTACATGGCCAAGAAGCCCGTGCAACTGCCCGGCTACTACTACGTGGACACCAAGCTGGACATCACCTCCCACAACGAGGACTACACCATCGTGGAACAGTACGAGCGCTCCGAGGGCCGCCACCACCTGTTCCTGTACGGCATGGACGAGCTGTACAAGTAA
&amp;gt;cre dna:chromosome chromosome:GRCm38:cre:1:1032:1 REF
ATGGCCAATTTACTGACCGTACACCAAAATTTGCCTGCATTACCGGTCGATGCAACGAGTGATGAGGTTCGCAAGAACCTGATGGACATGTTCAGGGATCGCCAGGCGTTTTCTGAGCATACCTGGAAAATGCTTCTGTCCGTTTGCCGGTCGTGGGCGGCATGGTGCAAGTTGAATAACCGGAAATGGTTTCCCGCAGAACCTGAAGATGTTCGCGATTATCTTCTATATCTTCAGGCGCGCGGTCTGGCAGTAAAAACTATCCAGCAACATTTGGGCCAGCTAAACATGCTTCATCGTCGGTCCGGGCTGCCACGACCAAGTGACAGCAATGCTGTTTCACTGGTTATGCGGCGGATCCGAAAAGAAAACGTTGATGCCGGTGAACGTGCAAAACAGGCTCTAGCGTTCGAACGCACTGATTTCGACCAGGTTCGTTCACTCATGGAAAATAGCGATCGCTGCCAGGATATACGTAATCTGGCATTTCTGGGGATTGCTTATAACACCCTGTTACGTATAGCCGAAATTGCCAGGATCAGGGTTAAAGATATCTCACGTACTGACGGTGGGAGAATGTTAATCCATATTGGCAGAACGAAAACGCTGGTTAGCACCGCAGGTGTAGAGAAGGCACTTAGCCTGGGGGTAACTAAACTGGTCGAGCGATGGATTTCCGTCTCTGGTGTAGCTGATGATCCGAATAACTACCTGTTTTGCCGGGTCAGAAAAAATGGTGTTGCCGCGCCATCTGCCACCAGCCAGCTATCAACTCGCGCCCTGGAAGGGATTTTTGAAGCAACTCATCGATTGATTTACGGCGCTAAGGATGACTCTGGTCAGAGATACCTGGCCTGGTCTGGACACAGTGCCCGTGTCGGAGCCGCGCGAGATATGGCCCGCGCTGGAGTTTCAATACCGGAGATCATGCAAGCTGGTGGCTGGACCAATGTAAATATTGTCATGAACTATATCCGTAACCTGGATAGTGAAACAGGGGCAATGGTGCGCCTGCTGGAAGATGGCGATTAG
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;edit-the-genome-fa-file&#34;&gt;edit the genome.fa file&lt;/h4&gt;

&lt;p&gt;The original mouse &lt;code&gt;genome.fa&lt;/code&gt; file is wrapped with 60 based per line, need to convert the transgene fasta to the same format.&lt;/p&gt;

&lt;p&gt;use &lt;a href=&#34;https://github.com/lh3/seqtk&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;seqtk&lt;/code&gt;&lt;/a&gt; from Heng Li.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;seqtk seq -l 60 tdtomato_cre.fa  &amp;gt; tdtomato_cre_multi.fa

mkdir ../../mm10-2.1.0_premrna_tdtomato_cre

cat genome.fa tdtomato_cre_multi.fa &amp;gt; ../../mm10-2.1.0_premrna_tdtomato_cre/genome.fa
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;edit-the-gtf-file&#34;&gt;edit the gtf file&lt;/h4&gt;

&lt;p&gt;create a tdtomato_cre.gtf:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tdtomato        custom  exon    1       1431    .       +       .       gene_id &amp;quot;ENSMUSGtdtomato&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;tdtomato1&amp;quot;; gene_name &amp;quot;Tdtomato&amp;quot;
cre     custom  exon    1       1032    .       +       .       gene_id &amp;quot;ENSMUSGcre&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;cre1&amp;quot;; gene_name &amp;quot;Cre&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be careful with the tabs and spaces. The &lt;code&gt;attributes&lt;/code&gt; column is at column 9 and separate the entries with space.
concatenate the original &lt;code&gt;genes.gtf&lt;/code&gt; with the transgene gtf:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat genes.gtf tdtomato_cre.gtf &amp;gt; ../../mm10-2.1.0_premrna_tdtomato_cre/genes.gtf
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cellranger-mk-reference&#34;&gt;cellranger  mk reference&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cellranger mkref --genome=mm10-2.1.0_premrna_tdtomato_cre --fasta genome.fa --genes genes.gtf --nthreads 12 --memgb 30
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-problem-1&#34;&gt;The problem&lt;/h3&gt;

&lt;p&gt;After &lt;code&gt;cellranger-count&lt;/code&gt; and I used &lt;code&gt;Seurat&lt;/code&gt; to visualize the expression levels of &lt;code&gt;Cre&lt;/code&gt; and &lt;code&gt;Tdtomato&lt;/code&gt;. I see no cells express Tdtomato and very few cells express &lt;code&gt;Cre&lt;/code&gt;, which is very strange given that all cells are &lt;code&gt;red&lt;/code&gt; under microscope and we sorted out the cells using &lt;code&gt;Tdtomato&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I googled and found some other people have the same problem.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://bioinformatics.stackexchange.com/questions/6694/scrna-seq-10x-cellranger-pipelines-low-custom-tdtomato-gene-content-looking-for&#34; target=&#34;_blank&#34;&gt;https://bioinformatics.stackexchange.com/questions/6694/scrna-seq-10x-cellranger-pipelines-low-custom-tdtomato-gene-content-looking-for&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://bioinformatics.stackexchange.com/questions/4596/no-counts-for-added-gene-in-cellranger-scrna-seq&#34; target=&#34;_blank&#34;&gt;https://bioinformatics.stackexchange.com/questions/4596/no-counts-for-added-gene-in-cellranger-scrna-seq&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I then went to the &lt;code&gt;bam&lt;/code&gt; file:&lt;/p&gt;

&lt;p&gt;only 34 reads mapped to &lt;code&gt;Tdtomato&lt;/code&gt; gene&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;samtools view possorted_genome_bam.bam tdtomato | wc -l
34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are more for &lt;code&gt;Cre&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;samtools view possorted_genome_bam.bam cre  | wc -l
6166

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is in agreement of the &lt;code&gt;FeaturePlot&lt;/code&gt; results.&lt;/p&gt;

&lt;p&gt;From the two links above, I realized 10x scRNAseq we are using is a 3&amp;rsquo; technology, only the 3 prime sequences are captured and sequenced. For the &lt;code&gt;Cre&lt;/code&gt; and &lt;code&gt;Tdtomato&lt;/code&gt; genes, I will need to add the 3&amp;rsquo;UTR sequences as well. Otherwise a lot of the reads will not be mapped.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This is particular true for poorly annotated genome if you are working with non-model organisms. If the &lt;code&gt;gtf&lt;/code&gt; annotation of the 3&amp;rsquo;UTR is not complete or too short, you will get very low mapping rate for the genes.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;let-s-fix-the-problem&#34;&gt;Let&amp;rsquo;s fix the problem&lt;/h3&gt;

&lt;p&gt;The problem is that no one knows what is the 3&amp;rsquo; UTR of the transgenes. I have to somehow derive it from the reads.
I asked on twitter and &lt;a href=&#34;https://twitter.com/RiyueSunnyBao&#34; target=&#34;_blank&#34;&gt;Sunney Bao&lt;/a&gt; suggested &lt;a href=&#34;https://colibread.inria.fr/software/mapsembler2/&#34; target=&#34;_blank&#34;&gt;mapsember2&lt;/a&gt; for this purpose. What &lt;code&gt;mapsember2&lt;/code&gt; does is extending the &lt;code&gt;Tdtomato&lt;/code&gt; fasta based on the fastq reads. I see it something like a local reassembly based on some baits.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
conda create -n mapsembler -c bioconda mapsembler2
conda activate mapsembler

run_mapsembler2_pipeline.sh -s tdtomato_cre.fa -r &amp;quot;Sample1_S1_L001_R2_001.fastq.gz Sample1_S1_L002_R2_001.fastq.gz&amp;quot; -t 1 -p cre_tdtomato
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on how many reads you have, it can take long. This is a novaseq run, it took me 2 days to finish running.
After that, in the &lt;code&gt;cre_tdtomato&lt;/code&gt; folder, there is a file named &lt;code&gt;cre_tdtomato_original_k_31_c_5_t_1.fasta&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat cre_tdtomato_original_k_31_c_5_t_1.fasta
&amp;gt;cre
ATGGCCAATTTACTGACCGTACACCAAAATTTGCCTGCATTACCGGTCGATGCAACGAGTGATGAGGTTCGCAAGAACCTGATGGACATGTTCAGGGATCGCCAGGCGTTTTCTGAGCATACCTGGAAAATGCTTCTGTCCGTTTGCCGGTCGTGGGCGGCATGGTGCAAGTTGAATAACCGGAAATGGTTTCCCGCAGAACCTGAAGATGTTCGCGATTATCTTCTATATCTTCAGGCGCGCGGTCTGGCAGTAAAAACTATCCAGCAACATTTGGGCCAGCTAAACATGCTTCATCGTCGGTCCGGGCTGCCACGACCAAGTGACAGCAATGCTGTTTCACTGGTTATGCGGCGGATCCGAAAAGAAAACGTTGATGCCGGTGAACGTGCAAAACAGGCTCTAGCGTTCGAACGCACTGATTTCGACCAGGTTCGTTCACTCATGGAAAATAGCGATCGCTGCCAGGATATACGTAATCTGGCATTTCTGGGGATTGCTTATAACACCCTGTTACGTATAGCCGAAATTGCCAGGATCAGGGTTAAAGATATCTCACGTACTGACGGTGGGAGAATGTTAATCCATATTGGCAGAACGAAAACGCTGGTTAGCACCGCAGGTGTAGAGAAGGCACTTAGCCTGGGGGTAACTAAACTGGTCGAGCGATGGATTTCCGTCTCTGGTGTAGCTGATGATCCGAATAACTACCTGTTTTGCCGGGTCAGAAAAAATGGTGTTGCCGCGCCATCTGCCACCAGCCAGCTATCAACTCGCGCCCTGGAAGGGATTTTTGAAGCAACTCATCGATTGATTTACGGCGCTAAGGATGACTCTGGTCAGAGATACCTGGCCTGGTCTGGACACAGTGCCCGTGTCGGAGCCGCGCGAGATATGGCCCGCGCTGGAGTTTCAATACCGGAGATCATGCAAGCTGGTGGCTGGACCAATGTAAATATTGTCATGAACTATATCCGTAACCTGGATAGTGAAACAGGGGCAATGGTGCGCCTGCTGGAAGATGGCGATTAG
&amp;gt;right_extension_0
ATGGTGCGCCTGCTGGAAGATGGCGATTAGCCATT
&amp;gt;tdtomato
ATGGTGAGCAAGGGCGAGGAGGTCATCAAAGAGTTCATGCGCTTCAAGGTGCGCATGGAGGGCTCCATGAACGGCCACGAGTTCGAGATCGAGGGCGAGGGCGAGGGCCGCCCCTACGAGGGCACCCAGACCGCCAAGCTGAAGGTGACCAAGGGCGGCCCCCTGCCCTTCGCCTGGGACATCCTGTCCCCCCAGTTCATGTACGGCTCCAAGGCGTACGTGAAGCACCCCGCCGACATCCCCGATTACAAGAAGCTGTCCTTCCCCGAGGGCTTCAAGTGGGAGCGCGTGATGAACTTCGAGGACGGCGGTCTGGTGACCGTGACCCAGGACTCCTCCCTGCAGGACGGCACGCTGATCTACAAGGTGAAGATGCGCGGCACCAACTTCCCCCCCGACGGCCCCGTAATGCAGAAGAAGACCATGGGCTGGGAGGCCTCCACCGAGCGCCTGTACCCCCGCGACGGCGTGCTGAAGGGCGAGATCCACCAGGCCCTGAAGCTGAAGGACGGCGGCCACTACCTGGTGGAGTTCAAGACCATCTACATGGCCAAGAAGCCCGTGCAACTGCCCGGCTACTACTACGTGGACACCAAGCTGGACATCACCTCCCACAACGAGGACTACACCATCGTGGAACAGTACGAGCGCTCCGAGGGCCGCCACCACCTGTTCCTGGGGCATGGCACCGGCAGCACCGGCAGCGGCAGCTCCGGCACCGCCTCCTCCGAGGACAACAACATGGCCGTCATCAAAGAGTTCATGCGCTTCAAGGTGCGCATGGAGGGCTCCATGAACGGCCACGAGTTCGAGATCGAGGGCGAGGGCGAGGGCCGCCCCTACGAGGGCACCCAGACCGCCAAGCTGAAGGTGACCAAGGGCGGCCCCCTGCCCTTCGCCTGGGACATCCTGTCCCCCCAGTTCATGTACGGCTCCAAGGCGTACGTGAAGCACCCCGCCGACATCCCCGATTACAAGAAGCTGTCCTTCCCCGAGGGCTTCAAGTGGGAGCGCGTGATGAACTTCGAGGACGGCGGTCTGGTGACCGTGACCCAGGACTCCTCCCTGCAGGACGGCACGCTGATCTACAAGGTGAAGATGCGCGGCACCAACTTCCCCCCCGACGGCCCCGTAATGCAGAAGAAGACCATGGGCTGGGAGGCCTCCACCGAGCGCCTGTACCCCCGCGACGGCGTGCTGAAGGGCGAGATCCACCAGGCCCTGAAGCTGAAGGACGGCGGCCACTACCTGGTGGAGTTCAAGACCATCTACATGGCCAAGAAGCCCGTGCAACTGCCCGGCTACTACTACGTGGACACCAAGCTGGACATCACCTCCCACAACGAGGACTACACCATCGTGGAACAGTACGAGCGCTCCGAGGGCCGCCACCACCTGTTCCTGTACGGCATGGACGAGCTGTACAAGTAA
&amp;gt;left_extension_0
CTTCGTATAGCATACATTATACGAAGTTATCACGCGCCGGCCGGCCTCTAGATTACCGGTCTCGCGAAGCCACCATGCCACCCAAAAAGAAAAGAAAGGTGGGCATGGTGAGCAAGGGCGAGGAGGTCATCAAA
&amp;gt;right_extension_0
CTGTACGGCATGGACGAGCTGTACAAGTAATTCGCGAGTGGCGCGTTAAGTGCAACACGTGAAGGCCGGCCCTGCAGGAATTCGATATCAAGCTTATCGATAATCAACCTCTGGATTACAAAATTTGTGAAAGATTGACTGGTATTCTTAACTATGTTGCTCCTTTTACGCTATGTGGATACGCTGCTTTAATGCCTTTGTATCATGCTATTGCTTCCCGTATGGCTTTCATTTTCTCCTCCTTGTATAAATCCTGGTTGCTGTCTCTTTATGAGGAGTTGTGGCCCGTTGTCAGGCAACGTGGCGTGGTGTGCACTGTGTTTGCTGACGCAACCCCCACTGGTTGGGGCATTGCCACCACCTGTCAGCTCCTTTCCGGGACTTTCGCTTTCCCCCTCCCTATTGCCACGGCGGAACTCATCGCCGCCTGCCTTGCCCGCTGCTGGACA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tdtomato&lt;/code&gt; get extended a lot and &lt;code&gt;Cre&lt;/code&gt; gets only a bit (right_extension_0).
I did a &lt;code&gt;blastn&lt;/code&gt; and want to see what is the sequence that was extended.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/posts_img/blastn.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It aligned to a &lt;code&gt;AAV vector&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I was excited at this step. With Tdtomato extending that much, I should get a lot more counts.&lt;/p&gt;

&lt;h3 id=&#34;remake-the-fasta-and-gtf&#34;&gt;remake the fasta and gtf&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;tdtomato dna:chromosome chromosome:GRCm38:tdtomato:1:1880:1 REF
ATGGTGAGCAAGGGCGAGGAGGTCATCAAAGAGTTCATGCGCTTCAAGGTGCGCATGGAGGGCTCCATGAACGGCCACGAGTTCGAGATCGAGGGCGAGGGCGAGGGCCGCCCCTACGAGGGCACCCAGACCGCCAAGCTGAAGGTGACCAAGGGCGGCCCCCTGCCCTTCGCCTGGGACATCCTGTCCCCCCAGTTCATGTACGGCTCCAAGGCGTACGTGAAGCACCCCGCCGACATCCCCGATTACAAGAAGCTGTCCTTCCCCGAGGGCTTCAAGTGGGAGCGCGTGATGAACTTCGAGGACGGCGGTCTGGTGACCGTGACCCAGGACTCCTCCCTGCAGGACGGCACGCTGATCTACAAGGTGAAGATGCGCGGCACCAACTTCCCCCCCGACGGCCCCGTAATGCAGAAGAAGACCATGGGCTGGGAGGCCTCCACCGAGCGCCTGTACCCCCGCGACGGCGTGCTGAAGGGCGAGATCCACCAGGCCCTGAAGCTGAAGGACGGCGGCCACTACCTGGTGGAGTTCAAGACCATCTACATGGCCAAGAAGCCCGTGCAACTGCCCGGCTACTACTACGTGGACACCAAGCTGGACATCACCTCCCACAACGAGGACTACACCATCGTGGAACAGTACGAGCGCTCCGAGGGCCGCCACCACCTGTTCCTGGGGCATGGCACCGGCAGCACCGGCAGCGGCAGCTCCGGCACCGCCTCCTCCGAGGACAACAACATGGCCGTCATCAAAGAGTTCATGCGCTTCAAGGTGCGCATGGAGGGCTCCATGAACGGCCACGAGTTCGAGATCGAGGGCGAGGGCGAGGGCCGCCCCTACGAGGGCACCCAGACCGCCAAGCTGAAGGTGACCAAGGGCGGCCCCCTGCCCTTCGCCTGGGACATCCTGTCCCCCCAGTTCATGTACGGCTCCAAGGCGTACGTGAAGCACCCCGCCGACATCCCCGATTACAAGAAGCTGTCCTTCCCCGAGGGCTTCAAGTGGGAGCGCGTGATGAACTTCGAGGACGGCGGTCTGGTGACCGTGACCCAGGACTCCTCCCTGCAGGACGGCACGCTGATCTACAAGGTGAAGATGCGCGGCACCAACTTCCCCCCCGACGGCCCCGTAATGCAGAAGAAGACCATGGGCTGGGAGGCCTCCACCGAGCGCCTGTACCCCCGCGACGGCGTGCTGAAGGGCGAGATCCACCAGGCCCTGAAGCTGAAGGACGGCGGCCACTACCTGGTGGAGTTCAAGACCATCTACATGGCCAAGAAGCCCGTGCAACTGCCCGGCTACTACTACGTGGACACCAAGCTGGACATCACCTCCCACAACGAGGACTACACCATCGTGGAACAGTACGAGCGCTCCGAGGGCCGCCACCACCTGTTCCTGTACGGCATGGACGAGCTGTACAAGTAACTGTACGGCATGGACGAGCTGTACAAGTAATTCGCGAGTGGCGCGTTAAGTGCAACACGTGAAGGCCGGCCCTGCAGGAATTCGATATCAAGCTTATCGATAATCAACCTCTGGATTACAAAATTTGTGAAAGATTGACTGGTATTCTTAACTATGTTGCTCCTTTTACGCTATGTGGATACGCTGCTTTAATGCCTTTGTATCATGCTATTGCTTCCCGTATGGCTTTCATTTTCTCCTCCTTGTATAAATCCTGGTTGCTGTCTCTTTATGAGGAGTTGTGGCCCGTTGTCAGGCAACGTGGCGTGGTGTGCACTGTGTTTGCTGACGCAACCCCCACTGGTTGGGGCATTGCCACCACCTGTCAGCTCCTTTCCGGGACTTTCGCTTTCCCCCTCCCTATTGCCACGGCGGAACTCATCGCCGCCTGCCTTGCCCGCTGCTGGACA
&amp;gt;cre dna:chromosome chromosome:GRCm38:cre:1:1067:1 REF
ATGGCCAATTTACTGACCGTACACCAAAATTTGCCTGCATTACCGGTCGATGCAACGAGTGATGAGGTTCGCAAGAACCTGATGGACATGTTCAGGGATCGCCAGGCGTTTTCTGAGCATACCTGGAAAATGCTTCTGTCCGTTTGCCGGTCGTGGGCGGCATGGTGCAAGTTGAATAACCGGAAATGGTTTCCCGCAGAACCTGAAGATGTTCGCGATTATCTTCTATATCTTCAGGCGCGCGGTCTGGCAGTAAAAACTATCCAGCAACATTTGGGCCAGCTAAACATGCTTCATCGTCGGTCCGGGCTGCCACGACCAAGTGACAGCAATGCTGTTTCACTGGTTATGCGGCGGATCCGAAAAGAAAACGTTGATGCCGGTGAACGTGCAAAACAGGCTCTAGCGTTCGAACGCACTGATTTCGACCAGGTTCGTTCACTCATGGAAAATAGCGATCGCTGCCAGGATATACGTAATCTGGCATTTCTGGGGATTGCTTATAACACCCTGTTACGTATAGCCGAAATTGCCAGGATCAGGGTTAAAGATATCTCACGTACTGACGGTGGGAGAATGTTAATCCATATTGGCAGAACGAAAACGCTGGTTAGCACCGCAGGTGTAGAGAAGGCACTTAGCCTGGGGGTAACTAAACTGGTCGAGCGATGGATTTCCGTCTCTGGTGTAGCTGATGATCCGAATAACTACCTGTTTTGCCGGGTCAGAAAAAATGGTGTTGCCGCGCCATCTGCCACCAGCCAGCTATCAACTCGCGCCCTGGAAGGGATTTTTGAAGCAACTCATCGATTGATTTACGGCGCTAAGGATGACTCTGGTCAGAGATACCTGGCCTGGTCTGGACACAGTGCCCGTGTCGGAGCCGCGCGAGATATGGCCCGCGCTGGAGTTTCAATACCGGAGATCATGCAAGCTGGTGGCTGGACCAATGTAAATATTGTCATGAACTATATCCGTAACCTGGATAGTGAAACAGGGGCAATGGTGCGCCTGCTGGAAGATGGCGATTAGATGGTGCGCCTGCTGGAAGATGGCGATTAGCCATT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;gtf&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tdtomato        custom  exon    1       1880    .       +       .       gene_id &amp;quot;ENSMUSGtdtomato&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;tdtomato1&amp;quot;; gene_name &amp;quot;Tdtomato&amp;quot;
cre     custom  exon    1       1067    .       +       .       gene_id &amp;quot;ENSMUSGcre&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;cre1&amp;quot;; gene_name &amp;quot;Cre&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, after I remake the reference with the extended fasta and do a cellranger count. I still get very few number of cells express &lt;code&gt;tdtomato&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## after reading in the sparse matrix
library(Seurat)
Sample1&amp;lt;- Read10X_h5(filename = &amp;quot;data/cre_tdtomato/Sample1/filtered_feature_bc_matrix.h5&amp;quot;)

&amp;gt; table(Sample1[&amp;quot;Tdtomato&amp;quot;, ] ==0)

FALSE  TRUE 
  154 10783 
&amp;gt; table(Sample1[&amp;quot;Cre&amp;quot;, ] ==0)

FALSE  TRUE 
  195 10742 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is bioinformatics: trails and errors. What else can possibly go wrong? Can you please share your experience?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Align multiple ggplot2 plots by axis</title>
      <link>/post/align-multiple-ggplot2-plots-by-axis/</link>
      <pubDate>Fri, 07 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/align-multiple-ggplot2-plots-by-axis/</guid>
      <description>&lt;p&gt;I used to use &lt;code&gt;cowplot&lt;/code&gt; to align multiple ggplot2 plots but when the x-axis are of different ranges, some extra work is needed to align the axis as well.&lt;/p&gt;
&lt;p&gt;The other day I was reading a &lt;a href=&#34;https://mp.weixin.qq.com/s/V1UiR98K6vy00PwkgkTmvA&#34;&gt;blog post&lt;/a&gt; by &lt;code&gt;GuangChuang Yu&lt;/code&gt; and he exactly tackled this problem. His packages such as &lt;code&gt;ChIPseeker&lt;/code&gt;, &lt;code&gt;ClusterProfiler&lt;/code&gt;, &lt;code&gt;ggtree&lt;/code&gt; are quite popular among the users.&lt;/p&gt;
&lt;p&gt;Some dummy example from his post:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(ggplot2)
library(ggstance)
library(cowplot)
# devtools::install_github(&amp;quot;YuLab-SMU/treeio&amp;quot;)
# devtools::install_github(&amp;quot;YuLab-SMU/ggtree&amp;quot;)
library(tidytree)
library(ggtree)

no_legend=theme(legend.position=&amp;#39;none&amp;#39;)

d &amp;lt;- group_by(mtcars, cyl) %&amp;gt;% summarize(mean=mean(disp), sd=sd(disp))
d2 &amp;lt;- dplyr::filter(mtcars, cyl != 8) %&amp;gt;% rename(var = cyl)

p1 &amp;lt;- ggplot(d, aes(x=cyl, y=mean)) +
    geom_col(aes(fill=factor(cyl)), width=1) +
    no_legend
p2 &amp;lt;- ggplot(d2, aes(var, disp)) +
    geom_jitter(aes(color=factor(var)), width=.5) +
    no_legend

p3 &amp;lt;- ggplot(filter(d, cyl != 4), aes(mean, cyl)) +
    geom_colh(aes(fill=factor(cyl)), width=.6) +
    coord_flip() + no_legend

pp &amp;lt;- list(p1, p2, p3)
plot_grid(plotlist=pp, ncol=1, align=&amp;#39;v&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-07-align-multiple-ggplot2-plots-by-axis_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;specifying &lt;code&gt;aling=&#39;v&#39;&lt;/code&gt; aligns the plots vertically, but because the axis limits are different the x-axis is not aligned.&lt;/p&gt;
&lt;p&gt;Let’s use &lt;code&gt;coord_cartesian&lt;/code&gt; to expand the xlim without filtering out the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p11&amp;lt;- p1 + coord_cartesian(xlim = c(3,11))
p22&amp;lt;- p2 + coord_cartesian(xlim = c(3,11))
p33&amp;lt;- p3 &amp;lt;- ggplot(filter(d, cyl != 4), aes(cyl, mean)) +
    geom_col(aes(fill=factor(cyl)), width=.6) +
  coord_cartesian(xlim = c(3,11)) +no_legend

pp1 &amp;lt;- list(p11, p22, p33)
plot_grid(plotlist=pp1, ncol=1, align=&amp;#39;v&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-07-align-multiple-ggplot2-plots-by-axis_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This works.&lt;/p&gt;
&lt;p&gt;However, as mentioned in the blog post by &lt;code&gt;GuangChuang Yu&lt;/code&gt;. There are several other cases that this may not be easy to work out:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;what if the x-axis is character string rather than continuous digits?&lt;/li&gt;
&lt;li&gt;what if the first plot is not from a dataframe (e.g. a tree object from ggtree)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s use the other example from the blog post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(2019-10-31)
tr &amp;lt;- rtree(10)

d1 &amp;lt;- data.frame(
    # only some labels match
    label = c(tr$tip.label[sample(5, 5)], &amp;quot;A&amp;quot;),
    value = sample(1:6, 6))

d2 &amp;lt;- data.frame(
    label = rep(tr$tip.label, 5),
    category = rep(LETTERS[1:5], each=10),
    value = rnorm(50, 0, 3))

g &amp;lt;- ggtree(tr) + geom_tiplab(align=TRUE)
g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-07-align-multiple-ggplot2-plots-by-axis_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This is a tree.&lt;/p&gt;
&lt;p&gt;Make some other dummy dataframe for making a bar plot and a heatmap:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;- filter(g, isTip) %&amp;gt;% select(c(label, y))

dd1 &amp;lt;- left_join(d1, d, by=&amp;#39;label&amp;#39;)
dd1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   label value  y
## 1    t4     5 10
## 2    t6     6  9
## 3    t9     2  2
## 4    t2     3  8
## 5    t1     4  1
## 6     A     1 NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dd2 &amp;lt;- left_join(d2, d, by=&amp;#39;label&amp;#39;)
head(dd2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   label category      value  y
## 1    t1        A -3.3159014  1
## 2    t9        A  1.1526652  2
## 3    t2        A  0.9969863  8
## 4    t6        A  3.7986173  9
## 5    t4        A  4.9893312 10
## 6   t10        A -2.1545959  6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# a bar graph
p1 &amp;lt;- ggplot(dd1, aes(y, value)) + geom_col(aes(fill=label)) +
    coord_flip() + theme_tree2() + theme(legend.position=&amp;#39;none&amp;#39;)
 
# a heatmap
p2 &amp;lt;- ggplot(dd2, aes(x=category, y=y)) +
    geom_tile(aes(fill=value)) + scale_fill_viridis_c() +
    theme_tree2() + theme(legend.position=&amp;#39;none&amp;#39;)

cowplot::plot_grid(g, p1, p2, ncol=3, align=&amp;#39;h&amp;#39;,
    labels=LETTERS[1:3], rel_widths = c(1, .5, .8))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-07-align-multiple-ggplot2-plots-by-axis_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The y-axis is not aligned with the tip of the &lt;code&gt;ggtree&lt;/code&gt; output if you read carefully.&lt;/p&gt;
&lt;p&gt;Let’s use the &lt;code&gt;ylim2&lt;/code&gt; function from &lt;code&gt;ggtree&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1 &amp;lt;- p1 + ylim2(g)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## the plot was flipped and the y limits will be applied to x-axis&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p2 &amp;lt;- p2 + ylim2(g)

cowplot::plot_grid(g, p1, p2, ncol=3, align=&amp;#39;h&amp;#39;,
    labels=LETTERS[1:3], rel_widths = c(1, .5, .8))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-07-align-multiple-ggplot2-plots-by-axis_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now they are aligned perfectly!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ggtree::ylim2()&lt;/code&gt; and &lt;code&gt;ggtree::xlim2()&lt;/code&gt; can be very useful for other cases. Thanks &lt;code&gt;GuangChuang Yu&lt;/code&gt; for making it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>add pct_in for each cluster for scRNAseq result table using list column</title>
      <link>/post/add-pct-in-for-each-cluster-for-scrnaseq-result-table-using-list-column/</link>
      <pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/add-pct-in-for-each-cluster-for-scrnaseq-result-table-using-list-column/</guid>
      <description>&lt;p&gt;Using nested dataframe and list column has transformed my way of data wrangling in R. For more on this topic, I highly recommend &lt;a href=&#34;https://jennybc.github.io/purrr-tutorial/index.html&#34;&gt;purrr tutorial&lt;/a&gt; from Jenney Bryan.&lt;/p&gt;
&lt;p&gt;In this post, I am going to show you how I use this to solve a problem for adding &lt;code&gt;pct_in&lt;/code&gt; column from the differential scRNAseq result table.&lt;/p&gt;
&lt;p&gt;I am going to use &lt;a href=&#34;https://github.com/immunogenomics/presto&#34;&gt;&lt;code&gt;presto&lt;/code&gt;&lt;/a&gt; for differential gene expression test. &lt;code&gt;presto&lt;/code&gt; performs a fast Wilcoxon rank sum test and auROC analysis. It can be used for differential accessible region test for scATACseq data as well. Because scATACseq data can have over 800k regions in my hand, I found it is much faster than &lt;code&gt;Seurat&lt;/code&gt; and also gives sensible results. Using presto also gives you all the genes/regions without filtering. This is particularly useful if you want to run GSEA which requires all genes as input. see &lt;a href=&#34;https://crazyhottommy.github.io/scRNA-seq-workshop-Fall-2019/scRNAseq_workshop_3.html&#34;&gt;this part&lt;/a&gt; for our scRNAseq workshop.&lt;/p&gt;
&lt;p&gt;Let’s download some scRNAseq example data from &lt;a href=&#34;https://satijalab.org/seurat/v3.1/atacseq_integration_vignette.html&#34; class=&#34;uri&#34;&gt;https://satijalab.org/seurat/v3.1/atacseq_integration_vignette.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl -L https://www.dropbox.com/s/3f3p5nxrn5b3y4y/pbmc_10k_v3.rds\?dl\=1 -o pbmc_10k_v3.rds&lt;/code&gt;&lt;/p&gt;
&lt;div id=&#34;read-into-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;read into R&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# install_github(&amp;#39;immunogenomics/presto&amp;#39;)
library(presto)
library(Seurat)
library(dplyr)
library(tibble)
library(furrr)
library(tictoc)
pbmc&amp;lt;- readRDS(&amp;quot;~/pbmc_10k_v3.rds&amp;quot;)

head(wilcoxauc(pbmc, &amp;quot;RNA_snn_res.0.4&amp;quot; ))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      feature group     avgExpr         logFC statistic       auc
## 1 AL627309.1     0 0.004455649 -0.0001475212   9648856 0.5007586
## 2 AL669831.5     0 0.058653109  0.0155762453   9974323 0.5176497
## 3     FAM87B     0 0.001185081  0.0007726323   9649065 0.5007694
## 4  LINC00115     0 0.023454801 -0.0001696563   9701960 0.5035145
## 5     FAM41C     0 0.025523520  0.0035611306   9745564 0.5057775
## 6 AL645608.3     0 0.000766896  0.0003039512   9642626 0.5004352
##           pval         padj    pct_in    pct_out
## 1 3.450509e-01 4.033191e-01 0.6350267 0.48136646
## 2 7.957294e-12 2.279022e-11 8.3221925 4.58074534
## 3 2.429577e-02 3.743801e-02 0.2005348 0.04658385
## 4 5.546520e-02 8.014953e-02 3.3422460 2.59316770
## 5 1.339544e-03 2.430893e-03 3.5427807 2.34472050
## 6 1.485920e-01 1.932465e-01 0.1336898 0.04658385&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;by default, &lt;code&gt;presto&lt;/code&gt; and &lt;code&gt;Seurat&lt;/code&gt; compare a gene in cells of one group versus all other groups of cells and calculate the
statistics. In the output, you see &lt;code&gt;pct_in&lt;/code&gt; and &lt;code&gt;pct_out&lt;/code&gt; columns which show the percentage of cells express this gene in the &lt;code&gt;in&lt;/code&gt; group and perecentage of cells express this gene in the &lt;code&gt;out&lt;/code&gt; groups. What if you want to know &lt;code&gt;pct_out&lt;/code&gt; in each of the group? How do you add that information to the dataframe? In addtion, you may also want to add the number of cells in each cluster into the dataframe.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;res&amp;lt;- wilcoxauc(pbmc, &amp;quot;RNA_snn_res.0.4&amp;quot; )

## how many genes in the result?
length(unique(res$feature))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 19089&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## for each group we have the same number of genes
count(res, group) %&amp;gt;% arrange(as.numeric(group))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 13 x 2
##    group     n
##    &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;
##  1 0     19089
##  2 1     19089
##  3 2     19089
##  4 3     19089
##  5 4     19089
##  6 5     19089
##  7 6     19089
##  8 7     19089
##  9 8     19089
## 10 9     19089
## 11 10    19089
## 12 11    19089
## 13 12    19089&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;get a dataframe for number of cells in each group&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(cell_number&amp;lt;- pbmc@meta.data %&amp;gt;%
  count(RNA_snn_res.0.4) %&amp;gt;%
  dplyr::rename(group = RNA_snn_res.0.4, cell_number = n))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 13 x 2
##    group cell_number
##    &amp;lt;fct&amp;gt;       &amp;lt;int&amp;gt;
##  1 0            2992
##  2 1            1596
##  3 2            1047
##  4 3             959
##  5 4             592
##  6 5             544
##  7 6             460
##  8 7             383
##  9 8             337
## 10 9             328
## 11 10             74
## 12 11             68
## 13 12             52&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s nest the dataframe by gene&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;res_nest&amp;lt;- res %&amp;gt;%
  group_by(feature) %&amp;gt;% 
  tidyr::nest()

res_nest&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 19,089 x 2
## # Groups:   feature [19,089]
##    feature    data                                                         
##    &amp;lt;chr&amp;gt;      &amp;lt;S3: vctrs_list_of&amp;gt;                                          
##  1 AL627309.1 0                    , 1                    , 10            …
##  2 AL669831.5 0                   , 1                   , 10              …
##  3 FAM87B     0                    , 1                    , 10            …
##  4 LINC00115  0                    , 1                    , 10            …
##  5 FAM41C     0                   , 1                   , 10              …
##  6 AL645608.3 0                    , 1                    , 10            …
##  7 SAMD11     0                    , 1                    , 10            …
##  8 NOC2L      0                   , 1                   , 10              …
##  9 KLHL17     0                   , 1                   , 10              …
## 10 PLEKHN1    0                    , 1                    , 10            …
## # … with 19,079 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;res_nest&lt;/code&gt; is a nested dataframe with a list column named &lt;code&gt;data&lt;/code&gt;. Let’s check the first entry of this list.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df&amp;lt;- res_nest$data[[1]] %&amp;gt;% arrange(as.numeric(group))
head(df)  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 9
##   group avgExpr     logFC statistic   auc   pval  padj pct_in pct_out
##   &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
## 1 0     0.00446 -0.000148  9648856. 0.501 0.345  0.403  0.635   0.481
## 2 1     0.00206 -0.00300   6232089  0.498 0.0916 0.162  0.251   0.587
## 3 2     0.00285 -0.00192   4377551  0.499 0.251  0.364  0.287   0.561
## 4 3     0.00685  0.00255   4067216. 0.501 0.661  0.723  0.626   0.519
## 5 4     0.00650  0.00208   2620733  0.501 0.612  0.719  0.676   0.520
## 6 5     0.00834  0.00401   2422859  0.501 0.492  0.648  0.735   0.518&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can collect the &lt;code&gt;pct_in&lt;/code&gt; for this gene from &lt;code&gt;df&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(df&amp;lt;- df %&amp;gt;% 
  left_join(cell_number, by = c(&amp;quot;group&amp;quot; = &amp;quot;group&amp;quot;)) %&amp;gt;%
  mutate(pct_in_group = paste(group, pct_in, sep= &amp;quot;_&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Column `group` joining character vector and factor, coercing into
## character vector&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 13 x 11
##    group avgExpr    logFC statistic   auc   pval  padj pct_in pct_out
##    &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
##  1 0     0.00446 -1.48e-4  9648856. 0.501 0.345  0.403  0.635   0.481
##  2 1     0.00206 -3.00e-3  6232089  0.498 0.0916 0.162  0.251   0.587
##  3 2     0.00285 -1.92e-3  4377551  0.499 0.251  0.364  0.287   0.561
##  4 3     0.00685  2.55e-3  4067216. 0.501 0.661  0.723  0.626   0.519
##  5 4     0.00650  2.08e-3  2620733  0.501 0.612  0.719  0.676   0.520
##  6 5     0.00834  4.01e-3  2422859  0.501 0.492  0.648  0.735   0.518
##  7 6     0.00816  3.78e-3  2070947  0.502 0.303  0.507  0.870   0.513
##  8 7     0.00245 -2.20e-3  1728031  0.499 0.460  0.685  0.261   0.541
##  9 8     0       -4.73e-3  1524082. 0.497 0.172  0.348  0       0.550
## 10 9     0.00533  7.97e-4  1498956. 0.502 0.333  0.524  0.915   0.516
## 11 10    0.00609  1.55e-3   349088. 0.504 0.333  0.586  1.35    0.524
## 12 11    0       -4.59e-3   316676  0.497 0.546  0.848  0       0.534
## 13 12    0.0295   2.50e-2   247320. 0.507 0.163  0.437  1.92    0.522
## # … with 2 more variables: cell_number &amp;lt;int&amp;gt;, pct_in_group &amp;lt;chr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# interleave the pct_in and number_in 
pct_in_groups&amp;lt;- df$pct_in
num_in_groups&amp;lt;- df$cell_number
names_pct_in_groups&amp;lt;-  paste(df$group,&amp;quot;pct_in&amp;quot;, sep = &amp;quot;_&amp;quot;)
names_num_in_groups&amp;lt;- paste(df$group, &amp;quot;cell_num&amp;quot;, sep= &amp;quot;_&amp;quot;)
# https://stackoverflow.com/questions/16443260/interleave-lists-in-r
out&amp;lt;- c(rbind(num_in_groups, pct_in_groups))
names(out)&amp;lt;- c(rbind(names_num_in_groups, names_pct_in_groups))
out&amp;lt;- bind_rows(out)
out&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 26
##   `0_cell_num` `0_pct_in` `1_cell_num` `1_pct_in` `2_cell_num` `2_pct_in`
##          &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1         2992      0.635         1596      0.251         1047      0.287
## # … with 20 more variables: `3_cell_num` &amp;lt;dbl&amp;gt;, `3_pct_in` &amp;lt;dbl&amp;gt;,
## #   `4_cell_num` &amp;lt;dbl&amp;gt;, `4_pct_in` &amp;lt;dbl&amp;gt;, `5_cell_num` &amp;lt;dbl&amp;gt;,
## #   `5_pct_in` &amp;lt;dbl&amp;gt;, `6_cell_num` &amp;lt;dbl&amp;gt;, `6_pct_in` &amp;lt;dbl&amp;gt;,
## #   `7_cell_num` &amp;lt;dbl&amp;gt;, `7_pct_in` &amp;lt;dbl&amp;gt;, `8_cell_num` &amp;lt;dbl&amp;gt;,
## #   `8_pct_in` &amp;lt;dbl&amp;gt;, `9_cell_num` &amp;lt;dbl&amp;gt;, `9_pct_in` &amp;lt;dbl&amp;gt;,
## #   `10_cell_num` &amp;lt;dbl&amp;gt;, `10_pct_in` &amp;lt;dbl&amp;gt;, `11_cell_num` &amp;lt;dbl&amp;gt;,
## #   `11_pct_in` &amp;lt;dbl&amp;gt;, `12_cell_num` &amp;lt;dbl&amp;gt;, `12_pct_in` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have 13 groups of cells, so we get a tibble of 1 x 26 with number of cells and percentage of cells for each group in each column. We now only need to &lt;code&gt;cbind&lt;/code&gt; this info back to each gene.&lt;/p&gt;
&lt;p&gt;Let’s write a function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;add_pct_in&amp;lt;- function(df, cell_number){
  df&amp;lt;- df %&amp;gt;% 
  left_join(cell_number, by = c(&amp;quot;group&amp;quot; = &amp;quot;group&amp;quot;)) %&amp;gt;%
  mutate(pct_in_group = paste(group, pct_in, sep= &amp;quot;_&amp;quot;))
  
  pct_in_groups&amp;lt;- df$pct_in
  num_in_groups&amp;lt;- df$cell_number
  names_pct_in_groups&amp;lt;-  paste(df$group,&amp;quot;pct_in&amp;quot;, sep = &amp;quot;_&amp;quot;)
  names_num_in_groups&amp;lt;- paste(df$group, &amp;quot;cell_num&amp;quot;, sep= &amp;quot;_&amp;quot;)
  # https://stackoverflow.com/questions/16443260/interleave-lists-in-r
  out&amp;lt;- c(rbind(num_in_groups, pct_in_groups))
  names(out)&amp;lt;- c(rbind(names_num_in_groups, names_pct_in_groups))
  out&amp;lt;- bind_rows(out)
  return(out)
}

## test this function for one gene
add_pct_in(df = res_nest$data[[1]], cell_number = cell_number )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Column `group` joining character vector and factor, coercing into
## character vector&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 26
##   `0_cell_num` `0_pct_in` `1_cell_num` `1_pct_in` `10_cell_num` `10_pct_in`
##          &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1         2992      0.635         1596      0.251            74        1.35
## # … with 20 more variables: `11_cell_num` &amp;lt;dbl&amp;gt;, `11_pct_in` &amp;lt;dbl&amp;gt;,
## #   `12_cell_num` &amp;lt;dbl&amp;gt;, `12_pct_in` &amp;lt;dbl&amp;gt;, `2_cell_num` &amp;lt;dbl&amp;gt;,
## #   `2_pct_in` &amp;lt;dbl&amp;gt;, `3_cell_num` &amp;lt;dbl&amp;gt;, `3_pct_in` &amp;lt;dbl&amp;gt;,
## #   `4_cell_num` &amp;lt;dbl&amp;gt;, `4_pct_in` &amp;lt;dbl&amp;gt;, `5_cell_num` &amp;lt;dbl&amp;gt;,
## #   `5_pct_in` &amp;lt;dbl&amp;gt;, `6_cell_num` &amp;lt;dbl&amp;gt;, `6_pct_in` &amp;lt;dbl&amp;gt;,
## #   `7_cell_num` &amp;lt;dbl&amp;gt;, `7_pct_in` &amp;lt;dbl&amp;gt;, `8_cell_num` &amp;lt;dbl&amp;gt;,
## #   `8_pct_in` &amp;lt;dbl&amp;gt;, `9_cell_num` &amp;lt;dbl&amp;gt;, `9_pct_in` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because we are going to apply this function to over 10,000 genes, I am going to use the parallized &lt;code&gt;purrr&lt;/code&gt;: &lt;code&gt;furrr&lt;/code&gt;.
&lt;a href=&#34;https://github.com/DavisVaughan/furrr&#34; class=&#34;uri&#34;&gt;https://github.com/DavisVaughan/furrr&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plan(multiprocess, workers = 8)

# this will start 8 workers, but each worker will consume 20Mb memory 
print(object.size(res), units= &amp;quot;Mb&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 20 Mb&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tic()
info&amp;lt;- furrr::future_map_dfr(res_nest$data, ~ add_pct_in(df= .x, cell_number = cell_number)) 
toc()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 9.007 sec elapsed&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(info)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 26
##   `0_cell_num` `0_pct_in` `1_cell_num` `1_pct_in` `10_cell_num` `10_pct_in`
##          &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1         2992      0.635         1596     0.251             74        1.35
## 2         2992      8.32          1596     3.57              74       20.3 
## 3         2992      0.201         1596     0.0627            74        0   
## 4         2992      3.34          1596     2.26              74        9.46
## 5         2992      3.54          1596     1.63              74        9.46
## 6         2992      0.134         1596     0                 74        0   
## # … with 20 more variables: `11_cell_num` &amp;lt;dbl&amp;gt;, `11_pct_in` &amp;lt;dbl&amp;gt;,
## #   `12_cell_num` &amp;lt;dbl&amp;gt;, `12_pct_in` &amp;lt;dbl&amp;gt;, `2_cell_num` &amp;lt;dbl&amp;gt;,
## #   `2_pct_in` &amp;lt;dbl&amp;gt;, `3_cell_num` &amp;lt;dbl&amp;gt;, `3_pct_in` &amp;lt;dbl&amp;gt;,
## #   `4_cell_num` &amp;lt;dbl&amp;gt;, `4_pct_in` &amp;lt;dbl&amp;gt;, `5_cell_num` &amp;lt;dbl&amp;gt;,
## #   `5_pct_in` &amp;lt;dbl&amp;gt;, `6_cell_num` &amp;lt;dbl&amp;gt;, `6_pct_in` &amp;lt;dbl&amp;gt;,
## #   `7_cell_num` &amp;lt;dbl&amp;gt;, `7_pct_in` &amp;lt;dbl&amp;gt;, `8_cell_num` &amp;lt;dbl&amp;gt;,
## #   `8_pct_in` &amp;lt;dbl&amp;gt;, `9_cell_num` &amp;lt;dbl&amp;gt;, `9_pct_in` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## cbind back to the nested dataframe
bind_cols(res_nest, info) %&amp;gt;%
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 28
## # Groups:   feature [6]
##   feature data  `0_cell_num` `0_pct_in` `1_cell_num` `1_pct_in`
##   &amp;lt;chr&amp;gt;   &amp;lt;S3:&amp;gt;        &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1 AL6273… 0   …         2992      0.635         1596     0.251 
## 2 AL6698… 0   …         2992      8.32          1596     3.57  
## 3 FAM87B  0   …         2992      0.201         1596     0.0627
## 4 LINC00… 0   …         2992      3.34          1596     2.26  
## 5 FAM41C  0   …         2992      3.54          1596     1.63  
## 6 AL6456… 0   …         2992      0.134         1596     0     
## # … with 22 more variables: `10_cell_num` &amp;lt;dbl&amp;gt;, `10_pct_in` &amp;lt;dbl&amp;gt;,
## #   `11_cell_num` &amp;lt;dbl&amp;gt;, `11_pct_in` &amp;lt;dbl&amp;gt;, `12_cell_num` &amp;lt;dbl&amp;gt;,
## #   `12_pct_in` &amp;lt;dbl&amp;gt;, `2_cell_num` &amp;lt;dbl&amp;gt;, `2_pct_in` &amp;lt;dbl&amp;gt;,
## #   `3_cell_num` &amp;lt;dbl&amp;gt;, `3_pct_in` &amp;lt;dbl&amp;gt;, `4_cell_num` &amp;lt;dbl&amp;gt;,
## #   `4_pct_in` &amp;lt;dbl&amp;gt;, `5_cell_num` &amp;lt;dbl&amp;gt;, `5_pct_in` &amp;lt;dbl&amp;gt;,
## #   `6_cell_num` &amp;lt;dbl&amp;gt;, `6_pct_in` &amp;lt;dbl&amp;gt;, `7_cell_num` &amp;lt;dbl&amp;gt;,
## #   `7_pct_in` &amp;lt;dbl&amp;gt;, `8_cell_num` &amp;lt;dbl&amp;gt;, `8_pct_in` &amp;lt;dbl&amp;gt;,
## #   `9_cell_num` &amp;lt;dbl&amp;gt;, `9_pct_in` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can unnest the dataframe&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bind_cols(res_nest, info) %&amp;gt;% 
  tidyr::unnest() %&amp;gt;%
  head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: `cols` is now required.
## Please use `cols = c(data)`&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 36
## # Groups:   feature [1]
##   feature group avgExpr    logFC statistic   auc   pval  padj pct_in
##   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1 AL6273… 0     0.00446 -1.48e-4  9648856. 0.501 0.345  0.403  0.635
## 2 AL6273… 1     0.00206 -3.00e-3  6232089  0.498 0.0916 0.162  0.251
## 3 AL6273… 10    0.00609  1.55e-3   349088. 0.504 0.333  0.586  1.35 
## 4 AL6273… 11    0       -4.59e-3   316676  0.497 0.546  0.848  0    
## 5 AL6273… 12    0.0295   2.50e-2   247320. 0.507 0.163  0.437  1.92 
## 6 AL6273… 2     0.00285 -1.92e-3  4377551  0.499 0.251  0.364  0.287
## # … with 27 more variables: pct_out &amp;lt;dbl&amp;gt;, `0_cell_num` &amp;lt;dbl&amp;gt;,
## #   `0_pct_in` &amp;lt;dbl&amp;gt;, `1_cell_num` &amp;lt;dbl&amp;gt;, `1_pct_in` &amp;lt;dbl&amp;gt;,
## #   `10_cell_num` &amp;lt;dbl&amp;gt;, `10_pct_in` &amp;lt;dbl&amp;gt;, `11_cell_num` &amp;lt;dbl&amp;gt;,
## #   `11_pct_in` &amp;lt;dbl&amp;gt;, `12_cell_num` &amp;lt;dbl&amp;gt;, `12_pct_in` &amp;lt;dbl&amp;gt;,
## #   `2_cell_num` &amp;lt;dbl&amp;gt;, `2_pct_in` &amp;lt;dbl&amp;gt;, `3_cell_num` &amp;lt;dbl&amp;gt;,
## #   `3_pct_in` &amp;lt;dbl&amp;gt;, `4_cell_num` &amp;lt;dbl&amp;gt;, `4_pct_in` &amp;lt;dbl&amp;gt;,
## #   `5_cell_num` &amp;lt;dbl&amp;gt;, `5_pct_in` &amp;lt;dbl&amp;gt;, `6_cell_num` &amp;lt;dbl&amp;gt;,
## #   `6_pct_in` &amp;lt;dbl&amp;gt;, `7_cell_num` &amp;lt;dbl&amp;gt;, `7_pct_in` &amp;lt;dbl&amp;gt;,
## #   `8_cell_num` &amp;lt;dbl&amp;gt;, `8_pct_in` &amp;lt;dbl&amp;gt;, `9_cell_num` &amp;lt;dbl&amp;gt;,
## #   `9_pct_in` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are possiblely other easier ways to achieve the same result. Please share your thoughts in the comments!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>The end of 2019</title>
      <link>/post/the-end-of-2019/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/the-end-of-2019/</guid>
      <description>&lt;p&gt;It is the end of 2019. How time flies! It is a good time to reflect what I have
achieved during the past year and what to look forward in 2020. I wrote a post for
2018 &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/the-end-of-2018/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.
I am not the only one who has impostor syndrome :) It is important to celebrate your
small successes/achievements by writing them down.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;I taught a snakemake and scRNAseq workshop during the FAS informatics 2-week &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/talk/2019-harvard-fas-workshop/&#34; target=&#34;_blank&#34;&gt;nanocourse&lt;/a&gt;. I love teaching biologists computing skills that I have learned from scratch. Nowadays, almost &lt;a href=&#34;https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.2002050&#34; target=&#34;_blank&#34;&gt;every biology is computational biology&lt;/a&gt;. I also helped/taught lab members in Dulac lab with programming.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I had my first R package &lt;a href=&#34;https://github.com/crazyhottommy/scclusteval&#34; target=&#34;_blank&#34;&gt;scclusteval&lt;/a&gt; for estimating cluster stability in single-cell RNAseq data in github and am writing it up for a small paper. I had some changes that have not been committed to github yet. I presented it in the &lt;a href=&#34;http://bioc2019.bioconductor.org/&#34; target=&#34;_blank&#34;&gt;2019 bioconductor annual meeting&lt;/a&gt; which was held in NYC. I met many wonderful tweeps during the conference including &lt;a href=&#34;https://twitter.com/nomad421&#34; target=&#34;_blank&#34;&gt;Rob Patro&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/mikelove&#34; target=&#34;_blank&#34;&gt;Mike Love&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/anshulkundaje&#34; target=&#34;_blank&#34;&gt;Ansul kundaje&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/QianLiu28878838&#34; target=&#34;_blank&#34;&gt;Qian liu&lt;/a&gt; (congrats for the new professorship!), &lt;a href=&#34;https://profiles.umassmed.edu/display/129880&#34; target=&#34;_blank&#34;&gt;Lihua Zhu&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/davetang31&#34; target=&#34;_blank&#34;&gt;Dave Tang&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/k3yavi&#34; target=&#34;_blank&#34;&gt;Avi Srivastava&lt;/a&gt; and many others. Thanks bioconductor for the travel award! bioconductor 2020 will be in local Boston, so I will see everyone here!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;My first co-first author computational paper is still under review after revision. I have my fingers crossed for the reviewers&amp;rsquo; comments back. It has tons of experimental data and computational analysis of both in-house and public data. You can have a look in biorxiv &lt;a href=&#34;https://www.biorxiv.org/content/10.1101/507202v1&#34; target=&#34;_blank&#34;&gt;https://www.biorxiv.org/content/10.1101/507202v1&lt;/a&gt;. I promise to update the README and pipeline once it is accepted :) &lt;a href=&#34;https://github.com/crazyhottommy/pyflow-ChIPseq&#34; target=&#34;_blank&#34;&gt;https://github.com/crazyhottommy/pyflow-ChIPseq&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I started working on scATACseq in March 2019. It is a brand new field and I have learned quite a bit during the journey. I learned the sparsity of the matrix (more sparse than scRNAseq given the nature of the experiment: we only 2 copies of diploid DNA). I wrote some &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/#posts&#34; target=&#34;_blank&#34;&gt;blog posts&lt;/a&gt; on it. I am developing an R/bioconductor package to deal with scATACseq data &lt;a href=&#34;https://github.com/crazyhottommy/scATACutils&#34; target=&#34;_blank&#34;&gt;https://github.com/crazyhottommy/scATACutils&lt;/a&gt;. I plan to add more functions and improve the documentations. I presented it in the cold spring harbor &lt;a href=&#34;https://meetings.cshl.edu/meetings.aspx?meet=SINGLE&amp;amp;year=19&#34; target=&#34;_blank&#34;&gt;Single Cell Analyses&lt;/a&gt; meeting.It is amazing to see the development of the single-cell field in the past 10 years! I met some awesome people there including &lt;a href=&#34;https://twitter.com/LGMartelotto&#34; target=&#34;_blank&#34;&gt;Luciano Martelotto&lt;/a&gt; and got to see some of my old MD Anderson Colleagues.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I said I would start learning some deep learning in 2019. That did not happen much. Instead, I started watching some linear algebra courses by MIT Gilbert Strang &lt;a href=&#34;https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/index.htm&#34; target=&#34;_blank&#34;&gt;18.06&lt;/a&gt; and &lt;a href=&#34;https://ocw.mit.edu/courses/mathematics/18-065-matrix-methods-in-data-analysis-signal-processing-and-machine-learning-spring-2018/index.htm&#34; target=&#34;_blank&#34;&gt;18.065&lt;/a&gt;. I have finished watching 70% of the videos and really enjoyed them. I got a much better idea of matrix dimentionality (along with space and subspace) and matrix factorization(e.g. SVD). I highly recommend youtube videos from 3blue1brown: &lt;a href=&#34;https://www.3blue1brown.com/essence-of-linear-algebra-page&#34; target=&#34;_blank&#34;&gt;Essense of linear algebra&lt;/a&gt; as well. Thanks &lt;a href=&#34;https://twitter.com/zhiiiyang&#34; target=&#34;_blank&#34;&gt;Yi Zhang&lt;/a&gt; for recommending. At the same time, I slowly picked up &lt;a href=&#34;https://www.manning.com/books/deep-learning-with-r&#34; target=&#34;_blank&#34;&gt;Deep learning with R&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I started &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/run-rstudio-server-with-singularity-on-hpc/&#34; target=&#34;_blank&#34;&gt;using docker and singularity&lt;/a&gt; for reproducible computing. It is a life-saver for me. Thanks Nathan for helping me along the way.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I finally met &lt;a href=&#34;https://twitter.com/JasonWilliamsNY&#34; target=&#34;_blank&#34;&gt;Jason Willimas&lt;/a&gt; in person together with &lt;a href=&#34;https://twitter.com/dccc_phd&#34; target=&#34;_blank&#34;&gt;Damien&lt;/a&gt;. Jason is a very nice person. Next time we will treat you when you are in Boston again. I am sure this is in the right category of my success list :)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I am grateful that I am in a such supporting position and I have been learning new things. Thanks everyone who has helped me along the way.&lt;/p&gt;

&lt;p&gt;In the coming 2020, I should&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;learn more stats. I registered one class from Harvard Extension school and will see how it goes. Lacking statistics background hurts me.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;do better in data and project management. I will start using &lt;a href=&#34;https://pypi.org/project/dtool/&#34; target=&#34;_blank&#34;&gt;dtool&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;write some papers up. A good paper is a finished paper. I hear you.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;try to be a better human, a better husband and father and then a better researcher.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Mixing mouse and human 10x single cell RNAseq data</title>
      <link>/post/mixing-mouse-and-human-10x-single-cell-rnaseq-data/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/mixing-mouse-and-human-10x-single-cell-rnaseq-data/</guid>
      <description>&lt;p&gt;In a typical “barnyard” experiment in which cells from different species are mixed before loading to the 10x controller, the identification of the species of origin after mapping/counting with the hybrid reference is a problem. People tend to use the ratio of reads mapped to each reference genome to determine which species a cell is from.&lt;/p&gt;
&lt;p&gt;In this paper &lt;a href=&#34;https://www.biorxiv.org/content/10.1101/630087v1.full&#34; class=&#34;uri&#34;&gt;https://www.biorxiv.org/content/10.1101/630087v1.full&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To deconvolute species, detect doublets and low quality cells, the mixed-species mapped data was used. Cells for which &amp;gt;70% of the reads mapped to only one species were assigned to the corresponding species. The remaining cells (those for which &amp;lt;70% of the reads mapped to only one species) were removed from the downstream analysis.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;kallisto bustool &lt;a href=&#34;https://bustools.github.io/BUS_notebooks_R/10xv2.html&#34;&gt;https://bustools.github.io/BUS_notebooks_R/10xv2.html&lt;/a&gt; uses 90% as a cutoff.&lt;/p&gt;
&lt;p&gt;However, how to choose this cutoff is subjective. In this blog post, I will mix a mouse and a human 10x single cell RNAseq dataset in silicon and then map to the hybrid transriptome. We have the ground truth of which cell comes from which species so we can investigate the mapping rate.&lt;/p&gt;
&lt;div id=&#34;download-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Download data&lt;/h3&gt;
&lt;p&gt;Download 1k pbmc data and 1k mouse brain data from 10x website.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;cd /n/holylfs/LABS/informatics/mtang/projects/dj/10x_mouse_human_mixing
wget http://cf.10xgenomics.com/samples/cell-exp/3.0.0/neuron_1k_v3/neuron_1k_v3_fastqs.tar

wget http://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/pbmc_1k_v3_fastqs.tar

## after tar xvf
ls neuron_1k_v3_fastqs/
neuron_1k_v3_S1_L001_I1_001.fastq.gz  neuron_1k_v3_S1_L001_R2_001.fastq.gz  neuron_1k_v3_S1_L002_R1_001.fastq.gz
neuron_1k_v3_S1_L001_R1_001.fastq.gz  neuron_1k_v3_S1_L002_I1_001.fastq.gz  neuron_1k_v3_S1_L002_R2_001.fastq.gz

ls pbmc_1k_v3_fastqs/
pbmc_1k_v3_S1_L001_I1_001.fastq.gz  pbmc_1k_v3_S1_L001_R2_001.fastq.gz  pbmc_1k_v3_S1_L002_R1_001.fastq.gz
pbmc_1k_v3_S1_L001_R1_001.fastq.gz  pbmc_1k_v3_S1_L002_I1_001.fastq.gz  pbmc_1k_v3_S1_L002_R2_001.fastq.gz&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;add-species-barcode-to-the-r1-fastq&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;add species barcode to the R1 fastq&lt;/h3&gt;
&lt;p&gt;Different experiment could have barcode collisions, let’s add additional barcode in front of the original cell barcode.&lt;/p&gt;
&lt;p&gt;save the below as a &lt;code&gt;add_species_barcode.sh&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;This script adds a 8 base pair barcode in front of the R1 reads (16bp cell barcode + 12 bp umi for 10x version3) and some dummy high quality score (I) to the quality line.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;#! /bin/bash
set -euo pipefail

zcat $1 |  awk -v barcode=&amp;quot;$2&amp;quot; &amp;#39;NR%4 == 2 {$0=barcode$0} NR%4==0 {$0=&amp;quot;IIIIIIII&amp;quot;$0} {print}&amp;#39; | gzip  &amp;gt; $3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I am adding &lt;code&gt;AAAAAAAA&lt;/code&gt; and &lt;code&gt;TTTTTTTT&lt;/code&gt; to mouse and human data, respectively.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;chmod u+x add_species_barcode.sh

./add_species_barcode.sh neuron_1k_v3_fastqs/neuron_1k_v3_S1_L001_R1_001.fastq.gz AAAAAAAA neuron_1k_v3_fastqs/neuron_1k_v3_S1_L001_R1_001_modified.fastq.gz


./add_species_barcode.sh neuron_1k_v3_fastqs/neuron_1k_v3_S1_L002_R1_001.fastq.gz AAAAAAAA neuron_1k_v3_fastqs/neuron_1k_v3_S1_L002_R1_001_modified.fastq.gz


./add_species_barcode.sh pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L001_R1_001.fastq.gz TTTTTTTT pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L001_R1_001_modified.fastq.gz


./add_species_barcode.sh pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L002_R1_001.fastq.gz TTTTTTTT pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L002_R1_001_modified.fastq.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;build-a-hybrid-index-for-kallisto.&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;build a hybrid index for kallisto.&lt;/h3&gt;
&lt;p&gt;kallisto uses cDNA for indexing.&lt;/p&gt;
&lt;p&gt;Note &lt;a href=&#34;https://www.kallistobus.tools/kb_transcriptome_index.html&#34;&gt;&lt;code&gt;kb-python&lt;/code&gt;&lt;/a&gt; uses genomics DNA and gtf file for making reference (it will extract the cDNA from genomic DNA based on gtf file). I tested &lt;code&gt;kb-python&lt;/code&gt; for a single species experiment and it worked well and saves you doing all the steps. However, &lt;code&gt;kb ref&lt;/code&gt; requires the fasta and gtf files to be merged for creating the hybrid reference. I may try it next time.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;## download the cDNA for mouse and human
wget ftp://ftp.ensembl.org/pub/release-96/fasta/mus_musculus/cdna/Mus_musculus.GRCm38.cdna.all.fa.gz
wget ftp://ftp.ensembl.org/pub/release-96/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh38.cdna.all.fa.gz

## download the gtf files
wget ftp://ftp.ensembl.org/pub/release-96/gtf/mus_musculus/Mus_musculus.GRCm38.96.gtf.gz
wget ftp://ftp.ensembl.org/pub/release-96/gtf/homo_sapiens/Homo_sapiens.GRCh38.96.gtf.gz

kallisto index -i GRCh38_GRCm38/GRCh38_GRCm38_96.idx Homo_sapiens.GRCh38.cdna.all.fa.gz Mus_musculus.GRCm38.cdna.all.fa.gz&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;kallisto-count-at-transcript-level&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;kallisto count at transcript level&lt;/h4&gt;
&lt;p&gt;Note 10x V2 R1 is 16bp cell barcode + 10 bp umi, V3 R1 is 16 bp cell barcode + 12 bp umi.&lt;/p&gt;
&lt;p&gt;See my previous post &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/understand-10x-scrnaseq-and-scatac-fastqs/&#34; class=&#34;uri&#34;&gt;https://divingintogeneticsandgenomics.rbind.io/post/understand-10x-scrnaseq-and-scatac-fastqs/&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;
kallisto bus -i /n/holylfs/INTERNAL_REPOS/INFORMATICS/reference_genome_by_tommy/kallisto_bus_ref/GRCh38_GRCm38_96.idx -o mouse_human_kallisto_out -x 0,0,24:0,24,36:1,0,0 -t8 \
neuron_1k_v3_fastqs/neuron_1k_v3_S1_L001_R1_001_modified.fastq.gz \
neuron_1k_v3_fastqs/neuron_1k_v3_S1_L001_R2_001.fastq.gz \
neuron_1k_v3_fastqs/neuron_1k_v3_S1_L002_R1_001_modified.fastq.gz \
neuron_1k_v3_fastqs/neuron_1k_v3_S1_L002_R2_001.fastq.gz \
pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L001_R1_001_modified.fastq.gz \
pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L001_R2_001.fastq.gz \
pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L002_R1_001_modified.fastq.gz \
pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L002_R2_001.fastq.gz

[index] k-mer length: 31
[index] number of targets: 307,242
[index] number of k-mers: 208,670,671
[index] number of equivalence classes: 1,276,238
[quant] will process sample 1: neuron_1k_v3_fastqs/neuron_1k_v3_S1_L001_R1_001_modified.fastq.gz
                               neuron_1k_v3_fastqs/neuron_1k_v3_S1_L001_R2_001.fastq.gz
[quant] will process sample 2: neuron_1k_v3_fastqs/neuron_1k_v3_S1_L002_R1_001_modified.fastq.gz
                               neuron_1k_v3_fastqs/neuron_1k_v3_S1_L002_R2_001.fastq.gz
[quant] will process sample 3: pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L001_R1_001_modified.fastq.gz
                               pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L001_R2_001.fastq.gz
[quant] will process sample 4: pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L002_R1_001_modified.fastq.gz
                               pbmc_1k_v3_fastqs/pbmc_1k_v3_S1_L002_R2_001.fastq.gz
[quant] finding pseudoalignments for the reads ... done
[quant] processed 159,504,118 reads, 97,750,679 reads pseudoaligned&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;bustools-count-at-gene-level&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;bustools count at gene level&lt;/h3&gt;
&lt;p&gt;we need a transcript to gene mapping tsv file making from gtf file. I could not find the &lt;code&gt;t2g.py&lt;/code&gt; script mentioned in the &lt;a href=&#34;https://www.kallistobus.tools/documentation&#34;&gt;tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;make a transcript to gene mapping file using unix command line. also read my previous blog post: &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/how-to-make-a-transcript-to-gene-mapping-file/&#34; class=&#34;uri&#34;&gt;https://divingintogeneticsandgenomics.rbind.io/post/how-to-make-a-transcript-to-gene-mapping-file/&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;zcat Homo_sapiens.GRCh38.96.gtf.gz | grep -v &amp;quot;#&amp;quot; | awk &amp;#39;$3==&amp;quot;transcript&amp;quot;&amp;#39; | cut -f9 | tr -s &amp;quot;;&amp;quot; &amp;quot; &amp;quot; | awk -v OFS=&amp;quot;\t&amp;quot; &amp;#39;{print$6&amp;quot;\t&amp;quot;$2&amp;quot;\t&amp;quot;$10}&amp;#39; | sort | uniq |  sed &amp;#39;s/\&amp;quot;//g&amp;#39; &amp;gt; Homo_sapiens.GRCh38.96.tsv


zcat Mus_musculus.GRCm38.96.gtf.gz | grep -v &amp;quot;#&amp;quot; | awk &amp;#39;$3==&amp;quot;transcript&amp;quot;&amp;#39; | cut -f9 | tr -s &amp;quot;;&amp;quot; &amp;quot; &amp;quot; | awk -v OFS=&amp;quot;\t&amp;quot; &amp;#39;{print$6&amp;quot;\t&amp;quot;$2&amp;quot;\t&amp;quot;$10}&amp;#39; | sort | uniq |  sed &amp;#39;s/\&amp;quot;//g&amp;#39; &amp;gt; Mus_musculus.GRCm38.96.tsv

## merge the tsv 
cat Homo_sapiens.GRCh38.96.tsv Mus_musculus.GRCm38.96.tsv &amp;gt; GRCh38_GRCm38.96.tsv&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;correct-to-the-whitelist-and-bustools-count-at-gene-level&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;correct to the whitelist and bustools count at gene level&lt;/h3&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;wget https://github.com/BUStools/getting_started/releases/download/species_mixing/10xv3_whitelist.txt

wc -l 10xv3_whitelist.txt
6794880 10xv3_whitelist.txt&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are valid 68k cell barcodes from 10x. we added the species barcode in front of them and use bustool to correct for sequencing errors.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# add the same species barcode to it.
cat 10xv3_whitelist.txt | awk &amp;#39;{print &amp;quot;AAAAAAAA&amp;quot;$0}&amp;#39; &amp;gt; whitelist1.txt
cat 10xv3_whitelist.txt | awk &amp;#39;{print &amp;quot;TTTTTTTT&amp;quot;$0}&amp;#39; &amp;gt; whitelist2.txt
cat whitelist1.txt whitelist2.txt &amp;gt; whitelist.txt

mkdir tmp genecount

bustools correct -w whitelist.txt -p mouse_human_kallisto_out/output.bus | \
bustools sort -T tmp/ -t 4 -p - | \
bustools count -o genecount/genes \
-g /n/holylfs/INTERNAL_REPOS/INFORMATICS/reference_genome_by_tommy/kallisto_bus_ref/GRCh38_GRCm38.96.tsv \
-e mouse_human_kallisto_out/matrix.ec -t mouse_human_kallisto_out/transcripts.txt --genecounts -

Found 13589760 barcodes in the whitelist

Number of hamming dist 1 barcodes = 461228268
Processed 97750679 bus records
In whitelist = 94311259
Corrected = 329059
Uncorrected = 3110361
Read in 94640318 BUS records&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt; it is not working!! 0 genes were mapped when I checked the &lt;code&gt;genes.genes.txt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The devil is that &lt;code&gt;kallisto&lt;/code&gt; infers the transcript id from the &lt;code&gt;cDNA&lt;/code&gt; fasta file which contains the &lt;code&gt;.2&lt;/code&gt; version number, but in the gtf file the version number is in the &lt;code&gt;transcript_version 2&lt;/code&gt; entry.&lt;/p&gt;
&lt;p&gt;The easiest way is to remove the version number in the &lt;code&gt;transcript.txt&lt;/code&gt; file from output.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# make a backup
cp transcripts.txt transcripts.bc.txt

# check how the version number look like for all genes
cat transcripts.txt | cut -d. -f2 | sort | uniq
1
10
11
12
13
14
15
16
17
2
3
4
5
6
7
8
9

cat transcripts.txt | sed -r &amp;#39;s/\.[0-9]?//&amp;#39; &amp;gt; transcript2.txt

## rerun bustool but feeding the transcript2.txt
rm -rf genecount/*

bustools correct -w whitelist.txt -p mouse_human_kallisto_out/output.bus | \
bustools sort -T tmp/ -t 4 -p - | \
bustools count -o genecount/genes \
-g /n/holylfs/INTERNAL_REPOS/INFORMATICS/reference_genome_by_tommy/kallisto_bus_ref/GRCh38_GRCm38.96.tsv \
-e mouse_human_kallisto_out/matrix.ec -t mouse_human_kallisto_out/transcript2.txt --genecounts -&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;alternative-ways&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Alternative ways&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;The R package &lt;a href=&#34;https://github.com/BUStools/BUSpaRse/blob/master/R/tr2g.R&#34;&gt;BUSpaRse&lt;/a&gt; has a function to take care of that to make a transcript to gene mapping file from cDNA fasta. &lt;a href=&#34;https://bustools.github.io/BUS_notebooks_R/10xv2.html&#34; class=&#34;uri&#34;&gt;https://bustools.github.io/BUS_notebooks_R/10xv2.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(BUSpaRse)
tr2g &amp;lt;- transcript2gene(fasta_file = c(&amp;quot;./data/hs_cdna.fa.gz&amp;quot;, &amp;quot;./data/mm_cdna.fa.gz&amp;quot;),
                        kallisto_out_path = &amp;quot;./output/out_hgmm1k&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;code&gt;kb-python&lt;/code&gt; command &lt;code&gt;kb ref&lt;/code&gt; takes &lt;strong&gt;genomic DNA fasta&lt;/strong&gt; and gtf files and makes the index and a transcript to gene mapping file on the fly.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;load-in-to-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;load in to R&lt;/h3&gt;
&lt;p&gt;following &lt;a href=&#34;https://bustools.github.io/BUS_notebooks_R/10xv2.html&#34; class=&#34;uri&#34;&gt;https://bustools.github.io/BUS_notebooks_R/10xv2.html&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(BUSpaRse)
library(tidyverse)
library(DropletUtils)
library(Matrix)
library(Seurat)

res_mat &amp;lt;- read_count_output(&amp;quot;~/Downloads/genecount&amp;quot;,name = &amp;quot;genes&amp;quot;, tcc = FALSE)

dim(res_mat)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  71600 731356&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;remove some of the empty droplets&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tot_counts &amp;lt;- Matrix::colSums(res_mat)
summary(tot_counts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
##      0.00      1.00      1.00     34.89      5.00 142612.00&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Compute barcode rank from Dropletutils
bc_rank &amp;lt;- barcodeRanks(res_mat)

qplot(bc_rank$total, bc_rank$rank, geom = &amp;quot;line&amp;quot;) +
  geom_vline(xintercept = bc_rank$knee, color = &amp;quot;blue&amp;quot;, linetype = 2) +
  geom_vline(xintercept = bc_rank$inflection, color = &amp;quot;green&amp;quot;, linetype = 2) +
  annotate(&amp;quot;text&amp;quot;, y = 1000, x = 1.5 * c(bc_rank$knee, bc_rank$inflection),
           label = c(&amp;quot;knee&amp;quot;, &amp;quot;inflection&amp;quot;), color = c(&amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;)) +
  scale_x_log10() +
  scale_y_log10() +
  labs(y = &amp;quot;Barcode rank&amp;quot;, x = &amp;quot;Total UMI count&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-11-mixing-mouse-and-human-10x-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;filter-the-cells&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;filter the cells&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Filter the matrix
res_mat &amp;lt;- res_mat[, tot_counts &amp;gt; bc_rank$inflection]
dim(res_mat)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 71600  2375&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we get around 2000 cells.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gene_species &amp;lt;- ifelse(str_detect(rownames(res_mat), &amp;quot;^ENSMUSG&amp;quot;), &amp;quot;mouse&amp;quot;, &amp;quot;human&amp;quot;)
mouse_inds &amp;lt;- gene_species == &amp;quot;mouse&amp;quot;
human_inds &amp;lt;- gene_species == &amp;quot;human&amp;quot;
# mark cells as mouse or human
cell_species &amp;lt;- tibble(n_mouse_umi = Matrix::colSums(res_mat[mouse_inds,]),
                       n_human_umi = Matrix::colSums(res_mat[human_inds,]),
                       tot_umi = Matrix::colSums(res_mat),
                       prop_mouse = n_mouse_umi / tot_umi,
                       prop_human = n_human_umi / tot_umi)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ground-truth&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;ground truth&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_detect(colnames(res_mat), &amp;quot;^AAAAAAAA&amp;quot;) %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
## FALSE  TRUE 
##  1169  1206&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_detect(colnames(res_mat), &amp;quot;^TTTTTTTT&amp;quot;) %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
## FALSE  TRUE 
##  1206  1169&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have 1206 mouse cells and 1169 human cells&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cell_species&amp;lt;- cell_species %&amp;gt;% 
  mutate(ground_truth = case_when(
    str_detect(colnames(res_mat), &amp;quot;^AAAAAAAA&amp;quot;) ~ &amp;quot;mouse&amp;quot;,
    str_detect(colnames(res_mat), &amp;quot;^TTTTTTTT&amp;quot;) ~ &amp;quot;human&amp;quot;
  )) 

p1&amp;lt;- ggplot(cell_species, aes(x = ground_truth, y = prop_mouse)) +
  geom_boxplot(aes(color = ground_truth))

p2&amp;lt;- ggplot(cell_species, aes(x = ground_truth, y = prop_human)) +
  geom_boxplot(aes(color = ground_truth))

p&amp;lt;- cowplot::plot_grid(
  p1 + theme(legend.position=&amp;quot;none&amp;quot;),
  p2 + theme(legend.position=&amp;quot;none&amp;quot;),
  align = &amp;#39;vh&amp;#39;)

## add back the legend
legend &amp;lt;- cowplot::get_legend(
  # create some space to the left of the legend
  p1 + theme(legend.box.margin = margin(0, 0, 0, 12))
)

# add the legend to the row we made earlier. Give it one-third of 
# the width of one plot (via rel_widths).
cowplot::plot_grid(p, legend, rel_widths = c(2, .4))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-11-mixing-mouse-and-human-10x-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;minimal and maximal proportion for mapping rate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# min 95%
cell_species$prop_human[cell_species$ground_truth == &amp;quot;human&amp;quot;] %&amp;gt;%
  range()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9505135 0.9994325&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# max 5%
cell_species$prop_mouse[cell_species$ground_truth == &amp;quot;human&amp;quot;] %&amp;gt;%
  range()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.0005675369 0.0494864613&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# min 97%
cell_species$prop_mouse[cell_species$ground_truth == &amp;quot;mouse&amp;quot;] %&amp;gt;%
  range()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9743096 1.0000000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# max 2%
cell_species$prop_human[cell_species$ground_truth == &amp;quot;mouse&amp;quot;] %&amp;gt;%
  range()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.00000000 0.02569043&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;assign species of origin by the proportion&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cell_species&amp;lt;- cell_species %&amp;gt;% 
  mutate(ground_truth = case_when(
    str_detect(colnames(res_mat), &amp;quot;^AAAAAAAA&amp;quot;) ~ &amp;quot;mouse&amp;quot;,
    str_detect(colnames(res_mat), &amp;quot;^TTTTTTTT&amp;quot;) ~ &amp;quot;human&amp;quot;
  )) %&amp;gt;%
  mutate(species = case_when(
    prop_mouse &amp;gt; 0.9 ~ &amp;quot;mouse&amp;quot;,
    prop_human &amp;gt; 0.9 ~ &amp;quot;human&amp;quot;,
    TRUE ~ &amp;quot;mixed&amp;quot;
  ))

table(cell_species$ground_truth, cell_species$species)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        
##         human mouse
##   human  1169     0
##   mouse     0  1206&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This makes a 100% match as expected.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;seurat-for-dimension-reduction-and-visualization&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Seurat for dimension reduction and visualization&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seu &amp;lt;- CreateSeuratObject(res_mat, min.cells = 3) %&amp;gt;% 
  NormalizeData(verbose = FALSE) %&amp;gt;% 
  ScaleData(verbose = FALSE) %&amp;gt;% 
  FindVariableFeatures(verbose = FALSE)

seu &amp;lt;- AddMetaData(seu, metadata = cell_species$ground_truth, col.name = &amp;quot;species&amp;quot;)
seu &amp;lt;- RunPCA(seu, verbose = FALSE, npcs = 30)
seu &amp;lt;- RunTSNE(seu, dims = 1:20, check_duplicates = FALSE)
DimPlot(seu, reduction = &amp;quot;pca&amp;quot;, pt.size = 0.5, group.by = &amp;quot;species&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-11-mixing-mouse-and-human-10x-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DimPlot(seu, reduction = &amp;quot;tsne&amp;quot;, pt.size = 0.5, group.by = &amp;quot;species&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-11-mixing-mouse-and-human-10x-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-19-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;conclusion&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Using ratio of mapped reads for each cell to identify the cell of origin works pretty well for mouse and human mixtures. what if we use a more close species to human say chimpanzee or monkeys? Also, in a real experiment, one may have doublets from different species.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The mapping ratio is so drasticially different so a much smaller cutoff can still seperate the sepecies very well. This could be due to the cell type difference. It will be interesting to do the same experiment but with human pbmc and mouse pbmc cells.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I used the hybrid reference for mapping. How it will look like if I map the human cells with the mouse reference or map the mouse cells with the human reference?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Modeling single cell RNAseq data with multinomial distribution </title>
      <link>/post/modeling-single-cell-rnaseq-data-with-multinomial-distribution/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/modeling-single-cell-rnaseq-data-with-multinomial-distribution/</guid>
      <description>&lt;p&gt;I was reading &lt;a href=&#34;https://www.biorxiv.org/content/10.1101/574574v1&#34;&gt;Feature Selection and Dimension Reduction for Single Cell RNA-Seq based on a Multinomial Model&lt;/a&gt;. In the paper, the authors model the scRNAseq counts using a multinomial distribution.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/multinomial.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I was using negative binomial distribution for modeling in my last &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/negative-bionomial-distribution-in-single-cell-rnaseq/&#34;&gt;post&lt;/a&gt;, so I asked the question on twitter:&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
for modeling RNAseq counts, what&#39;s the difference/advantages using negative binomial and multinomial distribution?
&lt;/p&gt;
— Ming Tang (&lt;span class=&#34;citation&#34;&gt;@tangming2005&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/tangming2005/status/1199340525188349952?ref_src=twsrc%5Etfw&#34;&gt;November 26, 2019&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;some quotes from the answers I get from Matthew&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the true distribution is multinomial. The conditional distr has of each gene is Poisson. Since there are so many genes each gene is approximately independent so independent Poissons can be used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;the marginal distribution of the true multinomial is binomial, which can be approximated by Poisson.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Real data is over dispersed since the Poisson only models technical variance not biological. To model the biological variance we use a mixture of poisons with a gamma prior — the gamma prior accounting for biological variability. The marginal distr of counts is negative binomial&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I am going to use multinomial distribution for the same data I used in my last post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)
library(tidyverse)
# There is an error when using this function, need to use the dev branch.
# https://github.com/satijalab/seurat/issues/2060
svensson_data&amp;lt;- ReadH5AD(&amp;quot;~/Downloads/svensson_chromium_control.h5ad&amp;quot;)

raw_counts&amp;lt;- svensson_data@assays$RNA@counts

# there are two datasets, each with 2000 cells
colnames(raw_counts) %&amp;gt;% stringr::str_extract(&amp;quot;[0-9]+_&amp;quot;) %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
## 20311_ 20312_ 
##   2000   2000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# I am going to use only the second dataset sevensson et al 2
raw_counts2&amp;lt;- raw_counts[, grepl(pattern = &amp;quot;20312_&amp;quot;, x = colnames(raw_counts))]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;counts from a gene fit a binomial distribution in a cell.&lt;/p&gt;
&lt;p&gt;Given
&lt;span class=&#34;math inline&#34;&gt;\(\displaystyle \Pr(X=k)={\binom {n}{k}}p^{k}(1-p)^{n-k}\)&lt;/span&gt; for binomial distribution,&lt;/p&gt;
&lt;p&gt;the marginal mean for each gene is &lt;span class=&#34;math inline&#34;&gt;\(E[y_{ij}]=n_ip_{ij} = \mu_{ij}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;the marginal variance is &lt;span class=&#34;math inline&#34;&gt;\(Var[y_{ij}] = n_ip_{ij}(1-p_{ij}) = \mu_{ij}- \frac1{n_i}\mu_{ij}^2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;the probability of seeing a 0 count for a gene is: &lt;span class=&#34;math inline&#34;&gt;\((1-p_{ij})^{n_i} = (1-\frac{\mu_{ij}}{n_i})^{n_i}\)&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# https://github.com/const-ae/sparseMatrixStats
library(sparseMatrixStats)
library(tidyverse)
gene_means&amp;lt;- sparseMatrixStats::rowMeans2(raw_counts2)


## total counts for each cell
lib_size&amp;lt;- sparseMatrixStats::colSums2(raw_counts2)

## https://github.com/willtownes/scrna2019/blob/master/real/zheng_2017_monocytes/02_exploratory.Rmd#L290
## why median though?
n_i&amp;lt;- median(lib_size)

# probability of 0 for each gene given binomial distribution 
zeros_bn&amp;lt;- (1- gene_means/n_i)^n_i 


## this is copied from last post, probability of 0 given negative binomiral distribution
phi &amp;lt;- 1/0.3725
zeros_nb&amp;lt;- (phi/(gene_means + phi))^phi

zeros_observed&amp;lt;- apply(raw_counts2, 1, function(x) mean(x ==0))

data.frame(zeros_bn = zeros_bn, zeros_nb = zeros_nb, zeros_observed = zeros_observed, 
           gene_means = gene_means) %&amp;gt;%
  ggplot(aes(x =log10(gene_means), y = zeros_observed)) +
  geom_point() +
  geom_line(aes(x = log10(gene_means), y = zeros_nb), color = &amp;quot;red&amp;quot;) +
  geom_line(aes(x = log10(gene_means), y = zeros_bn), color = &amp;quot;blue&amp;quot;) +
  theme_classic(base_size = 14) +
  ggtitle(&amp;quot;Svensson et al 2&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-26-modeling-single-cell-rnaseq-data-with-multinomial-distribution_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;At least for this dataset, negative bionomial (red line) seems to fit the observed 0 count better. multinomial with marginal binomial (blue line) seems to support 0 inflated in single-cell RNAseq.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt; 12/10/2019, as Will pointed out in the comment, we need to downsample the single cell data making each cell has roughly the same number of reads. He replicated my analysis at &lt;a href=&#34;https://github.com/willtownes/scrna2019/blob/master/real/svensson_2019/01_exploratory.Rmd&#34; class=&#34;uri&#34;&gt;https://github.com/willtownes/scrna2019/blob/master/real/svensson_2019/01_exploratory.Rmd&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
Hi thanks for your interest, in order to make those plots, you have to be able to treat all the cells/droplets as being drawn from same multinomial distribution meaning all the “n_i” terms have to be the same (or at least close). We used downsampling to achieve that…
&lt;/p&gt;
— Will (&lt;span class=&#34;citation&#34;&gt;@sandakano&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/sandakano/status/1199709577144623106?ref_src=twsrc%5Etfw&#34;&gt;November 27, 2019&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;I will put them in the same blog post for completeness.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## from https://github.com/willtownes/scrna2019/blob/master/util/functions.R#L67

Down_Sample_Matrix&amp;lt;-function(expr_mat,min_lib_size=NULL){
  #adapted from https://hemberg-lab.github.io/scRNA.seq.course/cleaning-the-expression-matrix.html#normalisations
  min_sz&amp;lt;-min(colSums(expr_mat))
  if(is.null(min_lib_size)){
    min_lib_size&amp;lt;-min_sz
  } else {
    stopifnot(min_lib_size&amp;lt;=min_sz)
  }
  down_sample&amp;lt;-function(x){
    prob &amp;lt;- min_lib_size/sum(x)
    unlist(lapply(x,function(y){rbinom(1, y, prob)}))
  }
  apply(expr_mat, 2, down_sample)
}


gg&amp;lt;-sparseMatrixStats::rowSums2(raw_counts2)&amp;gt;0 #exclude genes that are zero across all cells
Y&amp;lt;-raw_counts2[gg,]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To make the droplets comparable, we will exclude droplets with total count below 2,000 and downsample all other droplets to have approximately the same total counts.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_counts&amp;lt;- sparseMatrixStats::colSums2(Y)

hist(total_counts,breaks=100)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-26-modeling-single-cell-rnaseq-data-with-multinomial-distribution_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Yss&amp;lt;-Y[,total_counts&amp;gt;2000]
#downsample to normalize droplet size (total UMI)
Yds&amp;lt;-Down_Sample_Matrix(as.matrix(Yss))&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;using-the-downsampled-matrix-yss-for-plotting&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;using the downsampled matrix Yss for plotting&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Yds&amp;lt;-Yds[rowSums(Yds)&amp;gt;0,]

gene_means&amp;lt;- rowMeans(Yds)
gene_vars&amp;lt;- apply(Yds, 1, var)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;after downsampling, the mean and variance now are the same suggesting possion distribution&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df&amp;lt;- bind_cols(gene_means = gene_means, gene_vars = gene_vars)
 
df %&amp;gt;% ggplot(aes(x = log10(gene_means), y = log10(gene_vars))) +
        geom_point() +
        geom_abline(intercept = 0, slope = 1, color = &amp;quot;red&amp;quot;) + 
        theme_classic(base_size = 14) +
        ggtitle(&amp;quot;svensson et al 2 downsample&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-26-modeling-single-cell-rnaseq-data-with-multinomial-distribution_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This is consistent with &lt;a href=&#34;https://www.nxn.se/valent/2018/1/30/count-depth-variation-makes-poisson-scrna-seq-data-negative-binomial&#34;&gt;Count depth variation makes Poisson scRNA-seq data Negative Binomial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let’s see how the observed 0 counts fit each model:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## total counts for each cell
lib_size&amp;lt;- colSums(Yds)

## https://github.com/willtownes/scrna2019/blob/master/real/zheng_2017_monocytes/02_exploratory.Rmd#L290

N&amp;lt;-median(colSums(Yds))
predict_zeros_binom&amp;lt;-function(x){(1-exp(x)/N)^N} #binomial
predict_zeros_poi&amp;lt;-function(x){exp(-exp(x))}
predict_zeros_nb&amp;lt;-function(x,phi=100){
  exp(-phi*log1p(exp(x-log(phi))))
}

## note it is natural log here.
data.frame(zeros_observed = rowMeans(Yds==0), 
           x = log(gene_means)) %&amp;gt;%
  ggplot(aes(x , y = zeros_observed), alpha = 0.5) +
  geom_point() +
  stat_function(aes(x,color=&amp;quot;bin&amp;quot;),fun=predict_zeros_binom) +
  stat_function(aes(x,color=&amp;quot;poi&amp;quot;),fun=predict_zeros_poi) +
  stat_function(aes(x,color=&amp;quot;nb&amp;quot;),fun=predict_zeros_nb) +
  scale_color_manual(&amp;quot;model&amp;quot;,breaks=c(&amp;quot;bin&amp;quot;,&amp;quot;poi&amp;quot;,&amp;quot;nb&amp;quot;),values=c(&amp;quot;blue&amp;quot;,&amp;quot;green&amp;quot;,&amp;quot;red&amp;quot;)) +
  theme_classic(base_size = 14) +
  ggtitle(&amp;quot;Svensson et al 2&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-26-modeling-single-cell-rnaseq-data-with-multinomial-distribution_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After downsampling&lt;/strong&gt;, “Poisson, binomial and negative binomial models all fit the data about the same.”&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>negative bionomial distribution in (single-cell) RNAseq </title>
      <link>/post/negative-bionomial-distribution-in-single-cell-rnaseq/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/negative-bionomial-distribution-in-single-cell-rnaseq/</guid>
      <description>&lt;p&gt;This post is inspired by two posts written by Valentine Svensson:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.nxn.se/valent/2017/11/16/droplet-scrna-seq-is-not-zero-inflated&#34; class=&#34;uri&#34;&gt;http://www.nxn.se/valent/2017/11/16/droplet-scrna-seq-is-not-zero-inflated&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.nxn.se/valent/2018/1/30/count-depth-variation-makes-Poisson-scrna-seq-data-negative-binomial&#34; class=&#34;uri&#34;&gt;http://www.nxn.se/valent/2018/1/30/count-depth-variation-makes-Poisson-scrna-seq-data-negative-binomial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The original ipython notebook can be found at &lt;a href=&#34;https://github.com/vals/Blog/blob/master/171116-zero-inflation/Negative%20control%20analysis.ipynb&#34; class=&#34;uri&#34;&gt;https://github.com/vals/Blog/blob/master/171116-zero-inflation/Negative%20control%20analysis.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thanks for writing those and put both the data and code in public. After I read &lt;a href=&#34;https://www.biorxiv.org/content/10.1101/582064v1&#34;&gt;Droplet scRNA-seq is not zero-inflated&lt;/a&gt; by Valentine Svensson, I want to gain some understanding of it. This post is an effort to replicate some of the analysis in the preprint using &lt;code&gt;R&lt;/code&gt;. The original analysis was carried out in &lt;code&gt;python&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I am going to use the same negative control scRNAseq data used in the paper. Negative control data are generated by adding a solution of RNA to the fluid in microfluidic systems so that each droplet contains the same RNA content.&lt;/p&gt;
&lt;p&gt;The negative control data can be downloaded from &lt;a href=&#34;https://figshare.com/projects/Zero_inflation_in_negative_control_data/61292&#34; class=&#34;uri&#34;&gt;https://figshare.com/projects/Zero_inflation_in_negative_control_data/61292&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)
library(tidyverse)
# There is an error when using this function, need to use the dev branch.
# https://github.com/satijalab/seurat/issues/2060
svensson_data&amp;lt;- ReadH5AD(&amp;quot;~/Downloads/svensson_chromium_control.h5ad&amp;quot;)

raw_counts&amp;lt;- svensson_data@assays$RNA@counts

# there are two datasets, each with 2000 cells
colnames(raw_counts) %&amp;gt;% stringr::str_extract(&amp;quot;[0-9]+_&amp;quot;) %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
## 20311_ 20312_ 
##   2000   2000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# I am going to use only the second dataset sevensson et al 2
raw_counts2&amp;lt;- raw_counts[, grepl(pattern = &amp;quot;20312_&amp;quot;, x = colnames(raw_counts))]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, let’s check the mean and variance relationship for all the genes&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# https://github.com/const-ae/sparseMatrixStats
library(sparseMatrixStats)
library(tidyverse)
gene_means&amp;lt;- sparseMatrixStats::rowMeans2(raw_counts2)
gene_vars&amp;lt;- sparseMatrixStats::rowVars(raw_counts2)

df&amp;lt;- bind_cols(gene_means = gene_means, gene_vars = gene_vars)
 
df %&amp;gt;% ggplot(aes(x = log10(gene_means), y = log10(gene_vars))) +
        geom_point() +
        theme_classic(base_size = 14) +
        ggtitle(&amp;quot;svensson et al 2&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-21-negative-bionomial-distribution-in-single-cell-rnaseq_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We see when the gene expression level is bigger, the variance is also bigger- a quadratic relationship as opposed to possion distribution in which the mean is equal to variance.&lt;/p&gt;
&lt;p&gt;Poisson distribution is a common model for count data as well.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Poisson distribution, named after French mathematician Siméon Denis Poisson, is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time or space if these events occur with a known constant rate and independently of the time since the last event.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The probability density function is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[{\displaystyle P(k{\text{ events in interval}})={\frac {\lambda ^{k}e^{-\lambda }}{k!}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;with only one positive real &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; as the parameter.&lt;/p&gt;
&lt;p&gt;One can prove mathematically the mean is equal to the variance and equal to &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[E(X)= Var(X) = \lambda\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Remember from my last &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/negative-binomial-distribution-in-scrnaseq/&#34;&gt;post&lt;/a&gt;, for negative binomial distribution, the Variance is in a quadratic relationship with the mean. It seems that &lt;strong&gt;for each gene&lt;/strong&gt;, the counts across all cells in scRNAseq data can be modeled with negative binomial distribution better than possion since we observed mean not equal to variance according to the scatter plot.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[Var = \mu + \frac {\mu^2}{\phi}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In fact, &lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt; is always postive, so we will always have &lt;span class=&#34;math inline&#34;&gt;\(Var &amp;gt; \mu\)&lt;/span&gt;. When &lt;span class=&#34;math inline&#34;&gt;\(\frac {1}{\phi} = 0\)&lt;/span&gt;, it is the possion distribution.&lt;/p&gt;
&lt;p&gt;Let’s assume each gene follows negative binomial distribution and we can fit a linear regression line.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model&amp;lt;- lm(gene_vars ~  1* gene_means + I(gene_means^2) + 0, data =df )
summary(model)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = gene_vars ~ 1 * gene_means + I(gene_means^2) + 0, 
##     data = df)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1457.42     0.00     0.00     0.02   802.42 
## 
## Coefficients:
##                  Estimate Std. Error t value Pr(&amp;gt;|t|)    
## I(gene_means^2) 3.725e-01  6.352e-05    5863   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 11.24 on 24115 degrees of freedom
## Multiple R-squared:  0.9993, Adjusted R-squared:  0.9993 
## F-statistic: 3.438e+07 on 1 and 24115 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We see the coefficient estimate is &lt;code&gt;0.3725&lt;/code&gt; for the &lt;span class=&#34;math inline&#34;&gt;\(\mu^2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\frac 1\phi = 0.3725\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This is the same value as calculated in the preprint by Valentine Svensson:
&lt;a href=&#34;https://www.biorxiv.org/content/10.1101/582064v1&#34;&gt;Droplet scRNA-seq is not zero-inflated&lt;/a&gt; table 1.&lt;/p&gt;
&lt;p&gt;Let’s plot the fitted line to the mean variance plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;predicted_df&amp;lt;- data.frame(mean = df$gene_means, var_predict = 
                            df$gene_means + 0.3725 * (df$gene_means)^2 )

df %&amp;gt;%  ggplot(aes(x = log10(gene_means), y = log10(gene_vars))) +
        geom_point() +
        geom_line(color = &amp;quot;red&amp;quot;, data = predicted_df, aes(x = log10(gene_means), y =log10(var_predict))) + 
        theme_classic(base_size = 14) +
        ggtitle(&amp;quot;svensson et al&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-21-negative-bionomial-distribution-in-single-cell-rnaseq_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Given the &lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt; and mean of a gene, we can calculate the probability of observing 0 count for that gene:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\Pr(X=0) = \left(\frac{\phi} {\mu + \phi}\right)^{\phi}\]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&#34;is-single-cell-rnaseq-data-0-inflated&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Is single cell RNAseq data 0 inflated?&lt;/h3&gt;
&lt;p&gt;Now, let’s plot the observed 0s vs the theoretical 0s given the data fit negative binomial distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;phi &amp;lt;- 1/0.3725

zeros_nb&amp;lt;- (phi/(gene_means + phi))^phi
zeros_observed&amp;lt;- apply(raw_counts2, 1, function(x) mean(x ==0))

data.frame(zeros_nb = zeros_nb, zeros_observed = zeros_observed, 
           gene_means = gene_means) %&amp;gt;%
  ggplot(aes(x =log10(gene_means), y = zeros_observed)) +
  geom_point() +
  geom_line(aes(x = log10(gene_means), y = zeros_nb), color = &amp;quot;red&amp;quot;) +
  theme_classic(base_size = 14) +
  ggtitle(&amp;quot;Svensson et al 2&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-21-negative-bionomial-distribution-in-single-cell-rnaseq_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We see it fits very well. That’s why Valentine says this scRNAseq data is &lt;strong&gt;NOT&lt;/strong&gt; 0 inflated.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>negative binomial distribution</title>
      <link>/post/negative-binomial-distribution-in-scrnaseq/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/negative-binomial-distribution-in-scrnaseq/</guid>
      <description>&lt;p&gt;“Every model is wrong, but some are useful”— George Box&lt;/p&gt;
&lt;p&gt;In an effort to better understand the distribution of single-cell RNAseq counts,
I dived a bit deeper into the negative binomial distribution in the context of &lt;code&gt;R&lt;/code&gt;. I am by no means an
expert in statistics and writing this post is for myself to better understand it.&lt;/p&gt;
&lt;div id=&#34;what-is-a-negative-binomial-distribution&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;what is a negative binomial distribution&lt;/h3&gt;
&lt;p&gt;I will quote from &lt;a href=&#34;https://en.wikipedia.org/wiki/Negative_binomial_distribution&#34;&gt;wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose there is a sequence of independent Bernoulli trials. Thus, each trial has two potential outcomes called “success” and “failure”. In each trial the probability of success is p and of failure is (1 − p). We are observing this sequence until a predefined number r of failures have occurred. Then the random number of successes we have seen, X, will have the negative binomial (or Pascal) distribution:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[X\sim \mathrm {NB} (r,\,p)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The probability mass function of the negative binomial distribution is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[{\displaystyle f(k;r,p)\equiv \Pr(X=k)={\binom {k+r-1}{k}}(1-p)^{r}p^{k}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Sometimes the distribution is parameterized in terms of its mean &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; and variance &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; :&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[{\displaystyle {\begin{aligned}&amp;amp;p={\frac {\sigma ^{2}-\mu }{\sigma ^{2}}},\\[6pt]&amp;amp;r={\frac {\mu ^{2}}{\sigma ^{2}-\mu }},\\[3pt]&amp;amp;\Pr(X=k)={k+{\frac {\mu ^{2}}{\sigma ^{2}-\mu }}-1 \choose k}\left({\frac {\sigma ^{2}-\mu }{\sigma ^{2}}}\right)^{k}\left({\frac {\mu }{\sigma ^{2}}}\right)^{\mu ^{2}/(\sigma ^{2}-\mu )}.\end{aligned}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Let’s see how it is implemented in &lt;code&gt;R&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;Open the help page &lt;code&gt;?rnbinom&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rnbinom(n, size, prob, mu)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[{\displaystyle f(x;n,p)\equiv \Pr(X=x)={\binom {n+x-1}{n-1}}(1-p)^{x}p^{n}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This represents the number of failures which occur in a sequence of Bernoulli trials before a target number of successes (n) is reached.&lt;/strong&gt; The mean is μ = n(1-p)/p and variance n(1-p)/p^2.&lt;/p&gt;
&lt;p&gt;Notice the difference from the definition from wiki above.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;size&lt;br /&gt;
target for number of successful trials, or dispersion parameter (the shape parameter of the gamma mixing distribution). Must be strictly positive, need not be integer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is the n in the formula.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;prob&lt;br /&gt;
probability of success in each trial. 0 &amp;lt; prob &amp;lt;= 1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is the p in the formula.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mu
alternative parametrization via mean: see ‘Details’.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Details:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An alternative parametrization (often used in ecology) is by the mean mu (see above), and size, the dispersion parameter, where prob = size/(size+mu). The variance is mu + mu^2/size in this parametrization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It is a bit confusing since we can define it in different ways. We can verify it by ourselves.&lt;/p&gt;
&lt;p&gt;Suppose we do independent Bernoulli trails 10 times, with a success probability of 0.4, what’s the probability we see 4 failures before the 6th success?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## this is the total number of failures, the random variable X 
x&amp;lt;- 4

p&amp;lt;- 0.4

## size, the number of successful trials we are targeting
size &amp;lt;- 10 - x

dnbinom(x= x, size = size, prob = p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.06688604&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;one possible outcome is:&lt;/p&gt;
&lt;p&gt;SSSSSFFFFS&lt;/p&gt;
&lt;p&gt;The last trail has to be a success.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## this is the same as 
choose(size + x -1, size-1) * p^(size) * (1-p)^x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.06688604&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## and 
choose(size + x -1, x) * p^(size) * (1-p)^x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.06688604&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we can simulate the negative binomial distribution counts by&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

rnbinom(10000, size = size, prob =p) %&amp;gt;%
        enframe(name = &amp;quot;seq&amp;quot;, value = &amp;quot;num&amp;quot;) %&amp;gt;%
        ggplot(aes(x = num)) +
        geom_histogram(col=&amp;quot;white&amp;quot;, bins = 30) +
        geom_vline(xintercept = x, linetype = 2, col= &amp;quot;red&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-13-negative-binomial-distribution-in-scrnaseq_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean(rnbinom(10000, size = size, prob =p) == x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.0664&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We see it is close to the exact probability.&lt;/p&gt;
&lt;p&gt;An alternative parametrization (often used in ecology) is by the mean mu (see above), and size, the dispersion parameter, where prob = size/(size+mu). The variance is mu + mu^2/size in this parametrization.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[X\sim \mathrm {NB} (\mu,\,\sigma)\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mu&amp;lt;- size/p - size 
mu&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;variance&amp;lt;- mu + mu^2/size 
variance&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 22.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dnbinom(x= x, size = size, mu = mu)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.06688604&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We see it is the same result.&lt;/p&gt;
&lt;p&gt;with&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[{\displaystyle f(x;n,p)\equiv \Pr(X=x)={\binom {n+x-1}{n-1}}(1-p)^{x}p^{n}}\]&lt;/span&gt;
we can calculate the probablity when x = 0
i.e. the probability that we see a 0 count in RNAseq data.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[{\displaystyle\Pr(X=0)=p^{n}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and we know prob = size/(size+mu)&lt;/p&gt;
&lt;p&gt;The size or &lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt; is dispersion parameter in gamma distribution (the shape parameter of the gamma mixing distribution). let’s replace the p using &lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\Pr(X=0) = \left(\frac{\phi} {\mu + \phi}\right)^{\phi}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The variance is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[Var = \mu + \frac {\mu^2}{\phi}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>My opinionated selection of books/urls for bioinformatics/data science curriculum</title>
      <link>/post/my-opinionated-selection-of-books-for-bioinformatics-data-science-curriculum/</link>
      <pubDate>Thu, 12 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/my-opinionated-selection-of-books-for-bioinformatics-data-science-curriculum/</guid>
      <description>

&lt;p&gt;There was a paper on this topic: &lt;a href=&#34;https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003662&#34; target=&#34;_blank&#34;&gt;A New Online Computational Biology Curriculum&lt;/a&gt;.&lt;br /&gt;
I am going to provide a biased list below (I have read most of the books if not all). I say it is biased because you will see many books of R are from Hadely Wickham. I now use &lt;a href=&#34;https://www.tidyverse.org/&#34; target=&#34;_blank&#34;&gt;tidyverse&lt;/a&gt; most of the time.&lt;/p&gt;

&lt;h2 id=&#34;unix&#34;&gt;Unix&lt;/h2&gt;

&lt;p&gt;I suggest people who want to learn bioinformatics starting to learn unix commands first. It is so powerful and also omnipresent in high-performance computing settings (clouding computing etc). You can not survive without knowing it.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linuxcommand.org/tlcl.php&#34; target=&#34;_blank&#34;&gt;The linux command line&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nostarch.com/howlinuxworks2&#34; target=&#34;_blank&#34;&gt;How Linux works&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.datascienceatthecommandline.com/&#34; target=&#34;_blank&#34;&gt;Data science at the command line&lt;/a&gt;
It was a fun reading for me and learned many tricks from this book.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rik.smith-unna.com/command_line_bootcamp&#34; target=&#34;_blank&#34;&gt;command line bootcamp&lt;/a&gt; interactive online session to learn unix. it is not working anymore unfortunately.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;computational-biology&#34;&gt;Computational biology&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://library.open.oregonstate.edu/computationalbiology/&#34; target=&#34;_blank&#34;&gt;A Primer for Computational Biology&lt;/a&gt; by Shawn T. O&amp;rsquo;Neil&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://practicalcomputing.org/&#34; target=&#34;_blank&#34;&gt;Practical computing for biologist&lt;/a&gt; by  Steven H.D Haddock and Casey W. Dunn This was the first book that I used to learn unix, regex and python.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://shop.oreilly.com/product/0636920030157.do&#34; target=&#34;_blank&#34;&gt;Bioinformatics data skills&lt;/a&gt; by Vince Buffalo. This is a must have! once you have some experience on bioinformatics.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;r-programming&#34;&gt;R programming&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://r4ds.had.co.nz/&#34; target=&#34;_blank&#34;&gt;R for data science&lt;/a&gt; by Garrett Grolemund and Hadley Wickham.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://adv-r.had.co.nz/&#34; target=&#34;_blank&#34;&gt;Advanced R&lt;/a&gt; by Hadley Wickham.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://r-pkgs.had.co.nz/&#34; target=&#34;_blank&#34;&gt;R packages&lt;/a&gt; by Hadley Wickham. If you want to transit from an R user to developer, writing an R package will get you started.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;stats-r-focused&#34;&gt;Stats  (R focused)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://rafalab.github.io/pages/harvardx.html&#34; target=&#34;_blank&#34;&gt;Data analysis for the life science with R&lt;/a&gt; by Micheal Love and Rafael A. Irizarry. I took the course on edx for 3 times! learned a ton! You can buy a paper book at &lt;a href=&#34;https://www.crcpress.com/Data-Analysis-for-the-Life-Sciences-with-R/Irizarry-Love/p/book/9781498775670&#34; target=&#34;_blank&#34;&gt;https://www.crcpress.com/Data-Analysis-for-the-Life-Sciences-with-R/Irizarry-Love/p/book/9781498775670&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://compgenomr.github.io/book/&#34; target=&#34;_blank&#34;&gt;Computational Genomics with R&lt;/a&gt; by Altuna Akalin.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://web.stanford.edu/class/bios221/book/&#34; target=&#34;_blank&#34;&gt;Mordern statistics for mordern biology&lt;/a&gt; by Susan Holmes and Wolfgang Huber.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python-programming&#34;&gt;Python programming&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pythonforbiologists.com/advanced-python-for-biologists&#34; target=&#34;_blank&#34;&gt;(Advanced) python for biologist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wesmckinney.com/pages/book.html&#34; target=&#34;_blank&#34;&gt;Python for data analysis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oreilly.com/library/view/data-science-from/9781492041122/&#34; target=&#34;_blank&#34;&gt;Data science from scratch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;machine-learning&#34;&gt;Machine learning&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://faculty.marshall.usc.edu/gareth-james/ISL/&#34; target=&#34;_blank&#34;&gt;An intro to statistical learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.manning.com/books/practical-data-science-with-r&#34; target=&#34;_blank&#34;&gt;Practical Data science with R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.manning.com/books/deep-learning-with-r&#34; target=&#34;_blank&#34;&gt;Deeping learning with R&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;visualization&#34;&gt;Visualization&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://serialmentor.com/dataviz/&#34; target=&#34;_blank&#34;&gt;Fundamentals of Data Visualization&lt;/a&gt; by Claus O.Wilke&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Visual-Display-Quantitative-Information/dp/1930824130&#34; target=&#34;_blank&#34;&gt;The Visual Display of Quantitative Information&lt;/a&gt; by Edward R. Tufte as well.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Those two books are not teaching you how to make figures programmatically (although the book by Claus was generated by Rmarkdown and the codes for all the figures can be found at &lt;a href=&#34;https://github.com/clauswilke/dataviz&#34; target=&#34;_blank&#34;&gt;https://github.com/clauswilke/dataviz&lt;/a&gt;). They teach you what kind of figures are informative and pleasant to eyes. &lt;a href=&#34;https://www.data-to-viz.com/&#34; target=&#34;_blank&#34;&gt;From data to viz&lt;/a&gt; is a website guiding you to choose the right graph for your data.&lt;/p&gt;

&lt;p&gt;I am still using R/ggplot2 for visualization.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://socviz.co/&#34; target=&#34;_blank&#34;&gt;Data Visualization&lt;/a&gt; by Kieran Healy.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cookbook-r.com/Graphs/&#34; target=&#34;_blank&#34;&gt;R Graphics Cookbook&lt;/a&gt; by Winston Chang.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/ggplot2-Elegant-Graphics-Data-Analysis/dp/0387981403&#34; target=&#34;_blank&#34;&gt;ggplot2: Elegant Graphics for Data Analysis&lt;/a&gt; by Hadely Wickham.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, I have compiled many useful links at &lt;a href=&#34;https://github.com/crazyhottommy/getting-started-with-genomics-tools-and-resources&#34; target=&#34;_blank&#34;&gt;https://github.com/crazyhottommy/getting-started-with-genomics-tools-and-resources&lt;/a&gt; .&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s your favorite book that I have missed? Comment below!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/books.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
