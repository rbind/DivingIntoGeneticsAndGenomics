<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DNA confesses Data speak on DNA confesses Data speak</title>
    <link>/</link>
    <description>Recent content in DNA confesses Data speak on DNA confesses Data speak</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018 Ming &#39;Tommy&#39; Tang</copyright>
    <lastBuildDate>Sun, 15 Oct 2017 00:00:00 -0400</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>S3 and S4 objects in R explained </title>
      <link>/post/s3-and-s4-objects-in-r-explained/</link>
      <pubDate>Tue, 07 May 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/s3-and-s4-objects-in-r-explained/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;In R, S3 and S4 objects are related to object-oriented programming (OOP), which
allows you to create custom data structures with associated behaviors and methods.
Let me explain them using simple language and metaphors, along with practical examples.&lt;/p&gt;
&lt;p&gt;S3 Objects:
Imagine you have a collection of toys, like cars, dolls, and action figures. Each toy has its own set of properties (color, size, material) and behaviors (move, make sounds, etc.). In R, an S3 object is like a toy with its own properties and behaviors.&lt;/p&gt;
&lt;p&gt;For example, let‚Äôs create an S3 object called ‚Äúcar‚Äù with properties like ‚Äúcolor‚Äù and ‚Äúspeed‚Äù, and a method to ‚Äúmove‚Äù:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Define the car object
car &amp;lt;- list(color = &amp;quot;red&amp;quot;, speed = 0)

# Define a method to move the car
move_car &amp;lt;- function(car, distance) {
  car$speed &amp;lt;- distance
  cat(&amp;quot;The&amp;quot;, car$color, &amp;quot;car is moving at&amp;quot;, car$speed, &amp;quot;mph\n&amp;quot;)
  invisible(car)
}

# Use the S3 object and method
car &amp;lt;- move_car(car, 30)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The red car is moving at 30 mph&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, the car is an S3 object (a list), and &lt;code&gt;move_car&lt;/code&gt; is a function
that operates on the car object, updating its speed and displaying a message.&lt;/p&gt;
&lt;div id=&#34;s4-objects&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;S4 Objects&lt;/h3&gt;
&lt;p&gt;Now, imagine you have a factory that produces toys. Each toy has a specific design,
and you want to ensure that all toys follow the same rules and standards.
In R, an S4 object is like a toy from a factory, with well-defined properties
and behaviors that follow strict rules.&lt;/p&gt;
&lt;p&gt;Here‚Äôs an example of creating an S4 object called ‚ÄúCar‚Äù:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Define the Car class
setClass(&amp;quot;Car&amp;quot;, slots = list(color = &amp;quot;character&amp;quot;, speed = &amp;quot;numeric&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This line creates a new class called ‚ÄúCar‚Äù with two slots: color (of type character)
and speed (of type numeric). These slots represent the properties of the Car object,
such as its color and speed.&lt;/p&gt;
&lt;p&gt;In S4 objects, &lt;code&gt;slots&lt;/code&gt; are used to define the properties or attributes of the object.
Slots are defined when creating a class using the setClass function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Define the generic function &amp;quot;move&amp;quot;
setGeneric(&amp;quot;move&amp;quot;, function(object, distance) standardGeneric(&amp;quot;move&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;move&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Now you can define the method for the &amp;quot;Car&amp;quot; class
setMethod(&amp;quot;move&amp;quot;, signature(&amp;quot;Car&amp;quot;, &amp;quot;numeric&amp;quot;),
          function(object, distance) {
            object@speed &amp;lt;- distance
            cat(&amp;quot;The&amp;quot;, object@color, &amp;quot;car is moving at&amp;quot;, object@speed, &amp;quot;mph\n&amp;quot;)
            invisible(object)
          })&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;invisible()&lt;/code&gt; function in R is used to control the output of a function or expression.
When you call a function or evaluate an expression in R, the result is automatically
printed to the console. However, sometimes you may want to suppress this output or
return an object without printing it.&lt;/p&gt;
&lt;p&gt;In the context of S4 objects, the invisible() call is often used in methods to return the modified object without printing it. This is considered a good practice because it keeps the console output clean and allows you to capture the returned object for further processing.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;invisible(car)&lt;/code&gt; line returns the modified car object without printing it to the console. Instead, it prints the message ‚ÄúThe [color] car is moving at [speed] mph‚Äù using the cat function.&lt;/p&gt;
&lt;p&gt;If you didn‚Äôt use invisible(car), the method would print the object representation to the console, which may not be desirable, especially for more complex objects.&lt;/p&gt;
&lt;p&gt;By using invisible(), you can update the object‚Äôs state (in this case, the speed slot) and return the modified object without cluttering the console output. This makes it easier to work with the object in subsequent operations or assignments.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Create an instance of the Car class
my_car &amp;lt;- new(&amp;quot;Car&amp;quot;, color = &amp;quot;blue&amp;quot;, speed = 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you create an instance of the Car class using new(‚ÄúCar‚Äù, color = ‚Äúblue‚Äù, speed = 0),
you are initializing the color slot with the value ‚Äúblue‚Äù and the speed slot with the value 0.
Slots provide a way to encapsulate and organize data within an object, making it easier to manage and maintain the object‚Äôs state.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Use the S4 object and method
my_car &amp;lt;- move(my_car, 40)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The blue car is moving at 40 mph&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_car&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## An object of class &amp;quot;Car&amp;quot;
## Slot &amp;quot;color&amp;quot;:
## [1] &amp;quot;blue&amp;quot;
## 
## Slot &amp;quot;speed&amp;quot;:
## [1] 40&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here‚Äôs what we did:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;First, we defined the Car class using setClass.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We then created a generic function called move using setGeneric. The standardGeneric function is a utility function that creates a standard generic function with the specified name.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After defining the generic function, we can now define the method for the Car class using &lt;code&gt;setMethod&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;setMethod&lt;/code&gt; call specifies the generic function name (‚Äúmove‚Äù), the signature (the class or classes the method should be dispatched for), and the function definition for the method.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In the method definition, we update the speed slot of the object (the Car instance) and print a message using cat.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, we create an instance of the Car class and use the move method on it.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;By defining the generic function first, R knows that ‚Äúmove‚Äù is a valid generic function, and you can then define methods for different classes that should be dispatched when calling the move function.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Academia to Industry: Computational Biology Careeer Advice and Tips</title>
      <link>/talk/2024-indian-isg/</link>
      <pubDate>Fri, 26 Apr 2024 06:30:00 -0400</pubDate>
      
      <guid>/talk/2024-indian-isg/</guid>
      <description>&lt;p&gt;Your journey in the field of computational biology is inspiring and we hope through the webinar ISCB RSG India would be able to bring your story firsthand to the  budding computational biologists. We trust that they will not only gain academic insights from your talk but would also be able to find the right motivation to carve their own path in this constantly evolving field.
As we can see from your profile, you have a diverse skill set and experience of both academia and industry.&lt;/p&gt;

&lt;p&gt;We request you to talk a bit about your research work, challenges faced in taking up and pursuing Bioinformatics, trials and successes over the journey besides the specific domain you wish to touch upon. Please also talk about your entrepreneurial journey as it will be inspiring for freshly graduating research scholars and students.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/indian-ISG.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>computational biology career path tips</title>
      <link>/talk/2024-decipher-rafa-course/</link>
      <pubDate>Thu, 18 Apr 2024 17:00:00 -0400</pubDate>
      
      <guid>/talk/2024-decipher-rafa-course/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/img/rafa-course.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bridging the Gap: how to learn computational biology the right way</title>
      <link>/talk/2024-iowa-state/</link>
      <pubDate>Thu, 04 Apr 2024 15:00:00 -0400</pubDate>
      
      <guid>/talk/2024-iowa-state/</guid>
      <description>&lt;p&gt;With a theme of &amp;lsquo;From Code to Cure Bridging the Gap in Biological Sciences,&amp;rsquo; the cooperative efforts of the Interdisciplinary Biological Sciences Graduate Programs have culminated in organizing The 2nd Annual Interdisciplinary Biological Sciences Symposium - 2024(IBSS). The goal of IBSS 2024 is to unite scholars from diverse biological domains to deliver advances in the relevant fields and to promote an atmosphere to facilitate the exchange of idIBSS Flyereas and information. The symposium will feature keynote speakers who are experts in their fields. It will also provide exceptional opportunities for all participants to share their research through oral presentations and poster sessions. The participants will form new collaborations in this two-day symposium to advance innovative scientific research.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/iowa_state.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to Single-cell RNAseq analysis</title>
      <link>/talk/2024-tunis-r/</link>
      <pubDate>Sat, 30 Mar 2024 11:00:00 -0400</pubDate>
      
      <guid>/talk/2024-tunis-r/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/img/tunis_R.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bioinformatics is not (just) statistics </title>
      <link>/post/bioinformatics-is-not-just-statistics/</link>
      <pubDate>Wed, 27 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/bioinformatics-is-not-just-statistics/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;I was asked this question very often: ‚ÄúTommy, what‚Äôs the p-value cutoff should
I use to determine the differentially expressed genes; what log2 Fold change
cutoff should I use too?‚Äù&lt;/p&gt;
&lt;p&gt;For single-cell RNAseq quality control, what‚Äôs the cutoff for mitochondrial
content?&lt;/p&gt;
&lt;p&gt;My answer is always: it depends. I was joking: determining a cutoff is 90% of the
work a bioinformatician does.&lt;/p&gt;
&lt;p&gt;Why is that?&lt;/p&gt;
&lt;p&gt;Biology is more than just statistics. Several examples:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;when you have gazillions of data points, the p-value will be inherently small.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is especially true for single-cell RNAseq marker gene identification. We
may have thousands of cells in each cluster and the p-value will be inherently small.
Moreover, we are double-dipping as we cluster first and then test differences in
the clusters identified which causes the p-values to be even smaller. You probably
see many marker genes with p values of &lt;code&gt;10^-10&lt;/code&gt;.
We may want to focus on the effect size (the magnitude of changes). e.g.¬†log2 Fold change.&lt;/p&gt;
&lt;p&gt;This applies to any dataset with large sample size.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
Reminder: You will get small p-values when your the number of data points is large &lt;a href=&#34;https://t.co/wqx6JxRtGH&#34;&gt;https://t.co/wqx6JxRtGH&lt;/a&gt;
&lt;/p&gt;
‚Äî Ming &#34;Tommy&#34; Tang (&lt;span class=&#34;citation&#34;&gt;@tangming2005&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/tangming2005/status/1489964367336648707?ref_src=twsrc%5Etfw&#34;&gt;February 5, 2022&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;and when you calcuate correlations too:&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
Question: if you have tens of thousands of data points with a correlation of 0.2 and a p-value 10^-11. Is it meaningful to show that? you always get a tiny p-value when you have a lot of data points. &lt;a href=&#34;https://t.co/lVQKOJGnfW&#34;&gt;pic.twitter.com/lVQKOJGnfW&lt;/a&gt;
&lt;/p&gt;
‚Äî Ming &#34;Tommy&#34; Tang (&lt;span class=&#34;citation&#34;&gt;@tangming2005&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/tangming2005/status/1310606786605481985?ref_src=twsrc%5Etfw&#34;&gt;September 28, 2020&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;On the other hand, what cutoffs should one use for the log2Fold change? Traditionally,
people uses log2Fold of 1 which is 2 fold change. Again, I would argue this is
quite subjective and your dataset may have very few number of genes that pass that cutoff and you want to relax the cutoff. The whole idea of using those cutoffs is
to narrow down the gene list so one can pick one of them, do experiments to validate them and build a story for a paper.&lt;/p&gt;
&lt;p&gt;Is 50% of increase of 50% of decrease of gene expression important or not? It depends
on the genes. For example, X chromosome inactivation escaping can cause genes to increase 50% of some gene product in females (XX in female vs XY in male). It causes diseases.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Beta-thalassemia is an autosomal recessive disorder caused by mutations in the HBB (beta-globin) gene. This gene encodes the beta-globin subunit of hemoglobin, the oxygen-carrying protein in red blood cells. Mutations in HBB lead to reduced or absent production of functional beta-globin chains, resulting in ineffective erythropoiesis and hemolytic anemia. A 50% decrease in HBB gene expression can lead to a deficiency of beta-globin chains, causing the clinical manifestations of beta-thalassemia, including anemia, splenomegaly, and skeletal abnormalities.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Mitochondrial and ribosomal genes content are quality control metrics for single-cell RNAseq data.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As more mitochondrial gene expression indicates dying cells. What‚Äôs the cutoff
one should use? Some use 5%, some use 10%, others may use 20%. It is all heuristic.&lt;/p&gt;
&lt;p&gt;Indeed, there are tools such as &lt;a href=&#34;https://www.bioconductor.org/packages/release/bioc/html/miQC.html&#34;&gt;miQC&lt;/a&gt; which uses the data to determine a cutoff.
However, some tissues or cells types express high levels of mitochondrial and ribosomal genes because of their biology.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;metabolically active tissues (e.g., muscle, kidney) have higher mitochondrial transcript content&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;For example, naive poised T cells are known to have higher ribosomal content,
as are malignant cells.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So next time, if you ask me again, I will answer: it depends :)&lt;/p&gt;
&lt;div id=&#34;references&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;references&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;my old blog post &lt;a href=&#34;https://divingintogeneticsandgenomics.com/post/understanding-p-value-multiple-comparisons-fdr-and-q-value/&#34;&gt;Understanding p value, multiple comparisons, FDR and q value&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://genomebiology.biomedcentral.com/articles/10.1186/s13059-022-02820-w&#34;&gt;Biology-inspired data-driven quality control for scientific discovery in single-cell transcriptomics&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://sci-hub.ru/https://www.nature.com/articles/d41586-019-00857-9&#34;&gt;Scientists rise up against statistical significance&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.nepjol.info/index.php/NJE/article/view/14732&#34;&gt;Understanding significance and p-values&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://pubmed.ncbi.nlm.nih.gov/32840568/&#34;&gt;Systematic determination of the mitochondrial proportion in human and mice tissues for single-cell RNA-sequencing data quality control&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4715224/&#34;&gt;Characterization of Deletions of the HBA and HBB Loci by Array Comparative Genomic Hybridization&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Fine tune the best clustering resolution for scRNAseq data: trying out callback</title>
      <link>/post/fine-tune-the-best-clustering-resolution-for-scrnaseq-data-trying-out-callback/</link>
      <pubDate>Wed, 20 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/fine-tune-the-best-clustering-resolution-for-scrnaseq-data-trying-out-callback/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;context-and-problem&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Context and Problem&lt;/h3&gt;
&lt;p&gt;In scRNA-seq, each cell is sequenced individually, allowing for the analysis of gene expression at the single-cell level. This provides a wealth of information about the cellular identities and states. However, the high dimensionality of the data (thousands of genes) and the technical noise in the data can lead to challenges in accurately clustering the cells. Over-clustering is one such challenge, where cells that are biologically similar are clustered into distinct clusters.&lt;/p&gt;
&lt;p&gt;In a &lt;a href=&#34;https://divingintogeneticsandgenomics.com/post/scrnaseq-clustering-significant-test-an-unsolvable-problem/&#34;&gt;previous post&lt;/a&gt;, I tested &lt;a href=&#34;https://github.com/igrabski/sc-SHC&#34;&gt;&lt;code&gt;scSHC&lt;/code&gt;&lt;/a&gt; which tries to solve this problem.&lt;/p&gt;
&lt;p&gt;I recently saw this paper &lt;a href=&#34;https://www.biorxiv.org/content/10.1101/2024.03.08.584180v1.full&#34;&gt;A knockoff calibration method to avoid over-clustering in single-cell RNA-sequencing&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The paper introduces a ‚Äúknockoff calibration method‚Äù to address the over-clustering problem. The method involves the use of knockoff features, similar to the approach described earlier, but tailored to the specific challenges of scRNA-seq data.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Knockoff Features Creation: The algorithm generates knockoff features from the original gene expression data. These knockoff features are designed to mimic the original data but are statistically independent of the cell identities or states.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Clustering with Knockoff Features: The algorithm then applies a clustering algorithm to these knockoff features. Since the knockoff features are independent of the cell identities, the clustering should ideally reflect the true structure of the data without being influenced by the biological identities of the cells.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Calibration: The algorithm uses the clustering results from the knockoff features to calibrate the clustering of the original data. This calibration process adjusts the clustering of the original data to avoid over-clustering, ensuring that the final clusters reflect the true biological identities of the cells.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Improved Clustering: By using knockoff features for calibration, the algorithm aims to improve the accuracy of the clustering, reducing the likelihood of over-clustering. This results in more distinct clusters that better reflect the biological diversity of the single-cell population.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The Knockoff Calibration Method implemented in &lt;a href=&#34;https://github.com/lcrawlab/callback&#34;&gt;&lt;code&gt;callback&lt;/code&gt;&lt;/a&gt; R package:&lt;/p&gt;
&lt;p&gt;Let‚Äôs test it using the same PBMC3k datatset.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(Seurat)
library(scCustomize)
library(patchwork)
library(ggplot2)
library(ComplexHeatmap)
library(SeuratData)
set.seed(1234)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(&amp;quot;pbmc3k&amp;quot;)

pbmc3k&amp;lt;- UpdateSeuratObject(pbmc3k)
pbmc3k&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; An object of class Seurat 
#&amp;gt; 13714 features across 2700 samples within 1 assay 
#&amp;gt; Active assay: RNA (13714 features, 0 variable features)
#&amp;gt;  2 layers present: counts, data&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;routine-processing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;routine processing&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pbmc3k&amp;lt;- pbmc3k %&amp;gt;% 
  NormalizeData(normalization.method = &amp;quot;LogNormalize&amp;quot;, scale.factor = 10000) %&amp;gt;%
  FindVariableFeatures(selection.method = &amp;quot;vst&amp;quot;, nfeatures = 2000) %&amp;gt;%
  ScaleData() %&amp;gt;%
  RunPCA(verbose = FALSE) %&amp;gt;%
  FindNeighbors(dims = 1:10, verbose = FALSE) %&amp;gt;%
  FindClusters(resolution = 0.5, verbose = FALSE) %&amp;gt;%
  RunUMAP(dims = 1:10, verbose = FALSE)


p1&amp;lt;- DimPlot_scCustom(pbmc3k, reduction = &amp;quot;umap&amp;quot;, label = TRUE, group.by = 
                        &amp;quot;RNA_snn_res.0.5&amp;quot;)

p2&amp;lt;- DimPlot_scCustom(pbmc3k, reduction = &amp;quot;umap&amp;quot;, label = TRUE, group.by = &amp;quot;seurat_annotations&amp;quot;, label.size = 3)

p1 + p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-20-fine-tune-the-best-clustering-resolution-for-scrnaseq-data-trying-out-callback_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;janitor::tabyl(pbmc3k@meta.data, seurat_annotations, RNA_snn_res.0.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;  seurat_annotations   0   1   2   3   4   5   6  7  8
#&amp;gt;         Naive CD4 T 608   0  66   0  23   0   0  0  0
#&amp;gt;        Memory CD4 T  69   0 396   0  16   0   2  0  0
#&amp;gt;          CD14+ Mono   0 472   0   0   0   3   0  4  1
#&amp;gt;                   B   0   0   0 343   1   0   0  0  0
#&amp;gt;               CD8 T   2   0   3   0 265   0   1  0  0
#&amp;gt;        FCGR3A+ Mono   0   7   0   0   0 155   0  0  0
#&amp;gt;                  NK   0   0   0   0  16   0 139  0  0
#&amp;gt;                  DC   0   0   0   0   0   0   0 32  0
#&amp;gt;            Platelet   0   0   0   0   0   0   0  0 14
#&amp;gt;                &amp;lt;NA&amp;gt;  17  12   2   6  18   1   6  0  0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs artificially increase the resolution (to 1) to over-cluster it.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## artificially increase the resolution
pbmc3k&amp;lt;- pbmc3k %&amp;gt;%
  FindNeighbors(dims = 1:10, verbose = FALSE) %&amp;gt;%
  FindClusters(resolution = 1, verbose = FALSE) 


p3&amp;lt;- DimPlot_scCustom(pbmc3k, reduction = &amp;quot;umap&amp;quot;, label = TRUE, group.by = &amp;quot;RNA_snn_res.1&amp;quot;)

(p1 + p3) / p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-20-fine-tune-the-best-clustering-resolution-for-scrnaseq-data-trying-out-callback_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;CD4 naive cell cluster is split to 2 clusters (0 -&amp;gt; 0, 5)
the CD14+ monocyte cluster is split into 2 clusters (1 -&amp;gt; 4, 6)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;janitor::tabyl(pbmc3k@meta.data, RNA_snn_res.1, RNA_snn_res.0.5) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;  RNA_snn_res.1   0   1   2   3   4   5   6  7  8
#&amp;gt;              0 471   0   9   0   0   0   0  0  0
#&amp;gt;              1   4   0 455   0   0   0   0  0  0
#&amp;gt;              2   0   0   0 349   0   0   0  0  0
#&amp;gt;              3   0   0   2   0 303   0   0  0  0
#&amp;gt;              4   0 268   0   0   0   1   0  0  0
#&amp;gt;              5 221   0   1   0  36   0   0  0  0
#&amp;gt;              6   0 223   0   0   0   0   0  0  0
#&amp;gt;              7   0   0   0   0   0 158   0  0  0
#&amp;gt;              8   0   0   0   0   0   0 148  0  0
#&amp;gt;              9   0   0   0   0   0   0   0 36  0
#&amp;gt;             10   0   0   0   0   0   0   0  0 15&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;visualize it using &lt;a href=&#34;https://github.com/crazyhottommy/scclusteval&#34; class=&#34;uri&#34;&gt;https://github.com/crazyhottommy/scclusteval&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(scclusteval)

PairWiseJaccardSetsHeatmap(pbmc3k$RNA_snn_res.0.5,
                           pbmc3k$RNA_snn_res.1,
                           show_row_dend = F, show_column_dend = F,
                           cluster_row = F, cluster_column =F)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-20-fine-tune-the-best-clustering-resolution-for-scrnaseq-data-trying-out-callback_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;test-callback&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Test callback&lt;/h3&gt;
&lt;p&gt;Install it here &lt;a href=&#34;https://github.com/lcrawlab/callback&#34; class=&#34;uri&#34;&gt;https://github.com/lcrawlab/callback&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#devtools::install_github(&amp;quot;lcrawlab/callback&amp;quot;)
library(callback)
library(tictoc)

tic()
pbmc3k_callback &amp;lt;- FindClustersCallback(pbmc3k)
toc()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; 53.227 sec elapsed&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p4&amp;lt;- scCustomize::DimPlot_scCustom(pbmc3k_callback)

(p1 + p4) / p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-20-fine-tune-the-best-clustering-resolution-for-scrnaseq-data-trying-out-callback_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;PairWiseJaccardSetsHeatmap(pbmc3k$seurat_annotations,
                           pbmc3k_callback$callback_clusters,
                           show_row_dend = F, show_column_dend = F,
                           cluster_row = F, cluster_column =F)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-20-fine-tune-the-best-clustering-resolution-for-scrnaseq-data-trying-out-callback_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;callback&lt;/code&gt; merges the CD8 T and NK cells into cluster 2, and merges the
naive CD4 T cells and the memory CD4 T cells. Of course, you do not know the
original seurat cluster annotation is 100% correct or not. Distinguishing naive
and memory CD4 is harder too. However, merging NK cells with CD8T cells do make me worry :)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;conclusions&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Similar to &lt;a href=&#34;https://github.com/igrabski/sc-SHC&#34;&gt;&lt;code&gt;scSHC&lt;/code&gt;&lt;/a&gt;, while statistically attractive, we need to use it with precaution and validate the clusters with biology knowledge.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Always use a small dataset that you are familiar with to test a new method.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The cluster number will be depending on the parameter &lt;code&gt;dims = 1:10&lt;/code&gt; in the &lt;code&gt;FindClustersCallback&lt;/code&gt; function too.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I may still cluster with a bunch of different resolutions and make sense of
them using biology knowledge and manually merge or split the clusters.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;what‚Äôs your take?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; ‚îÄ Session info  üòï  ü§ï  üìÆ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#&amp;gt;  hash: confused face, face with head-bandage, postbox
#&amp;gt; 
#&amp;gt;  setting  value
#&amp;gt;  version  R version 4.1.2 (2021-11-01)
#&amp;gt;  os       macOS Big Sur 10.16
#&amp;gt;  system   x86_64, darwin17.0
#&amp;gt;  ui       X11
#&amp;gt;  language (EN)
#&amp;gt;  collate  en_US.UTF-8
#&amp;gt;  ctype    en_US.UTF-8
#&amp;gt;  tz       America/New_York
#&amp;gt;  date     2024-03-22
#&amp;gt;  pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)
#&amp;gt; 
#&amp;gt; ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#&amp;gt;  package            * version    date (UTC) lib source
#&amp;gt;  abind                1.4-5      2016-07-21 [1] CRAN (R 4.1.0)
#&amp;gt;  beeswarm             0.4.0      2021-06-01 [1] CRAN (R 4.1.0)
#&amp;gt;  BiocGenerics         0.40.0     2021-10-26 [1] Bioconductor
#&amp;gt;  blogdown             1.7        2021-12-19 [1] CRAN (R 4.1.2)
#&amp;gt;  bookdown             0.24       2021-09-02 [1] CRAN (R 4.1.0)
#&amp;gt;  bslib                0.3.1      2021-10-06 [1] CRAN (R 4.1.0)
#&amp;gt;  cachem               1.0.6      2021-08-19 [1] CRAN (R 4.1.0)
#&amp;gt;  callback           * 0.0.0      2024-03-15 [1] Github (lcrawlab/callback@655705f)
#&amp;gt;  callr                3.7.0      2021-04-20 [1] CRAN (R 4.1.0)
#&amp;gt;  circlize             0.4.13     2021-06-09 [1] CRAN (R 4.1.0)
#&amp;gt;  cli                  3.6.1      2023-03-23 [1] CRAN (R 4.1.2)
#&amp;gt;  clue                 0.3-60     2021-10-11 [1] CRAN (R 4.1.0)
#&amp;gt;  cluster              2.1.2      2021-04-17 [1] CRAN (R 4.1.2)
#&amp;gt;  codetools            0.2-18     2020-11-04 [1] CRAN (R 4.1.2)
#&amp;gt;  colorspace           2.0-2      2021-06-24 [1] CRAN (R 4.1.0)
#&amp;gt;  ComplexHeatmap     * 2.10.0     2021-10-26 [1] Bioconductor
#&amp;gt;  cowplot              1.1.1      2020-12-30 [1] CRAN (R 4.1.0)
#&amp;gt;  crayon               1.4.2      2021-10-29 [1] CRAN (R 4.1.0)
#&amp;gt;  data.table           1.14.2     2021-09-27 [1] CRAN (R 4.1.0)
#&amp;gt;  DBI                  1.1.1      2021-01-15 [1] CRAN (R 4.1.0)
#&amp;gt;  deldir               1.0-6      2021-10-23 [1] CRAN (R 4.1.0)
#&amp;gt;  desc                 1.4.0      2021-09-28 [1] CRAN (R 4.1.0)
#&amp;gt;  devtools             2.4.2      2021-06-07 [1] CRAN (R 4.1.0)
#&amp;gt;  digest               0.6.28     2021-09-23 [1] CRAN (R 4.1.0)
#&amp;gt;  doParallel           1.0.17     2022-02-07 [1] CRAN (R 4.1.2)
#&amp;gt;  dotCall64            1.1-1      2023-11-28 [1] CRAN (R 4.1.2)
#&amp;gt;  dplyr              * 1.1.2      2023-04-20 [1] CRAN (R 4.1.2)
#&amp;gt;  ellipsis             0.3.2      2021-04-29 [1] CRAN (R 4.1.0)
#&amp;gt;  evaluate             0.14       2019-05-28 [1] CRAN (R 4.1.0)
#&amp;gt;  fansi                0.5.0      2021-05-25 [1] CRAN (R 4.1.0)
#&amp;gt;  farver               2.1.0      2021-02-28 [1] CRAN (R 4.1.0)
#&amp;gt;  fastDummies          1.7.3      2023-07-06 [1] CRAN (R 4.1.2)
#&amp;gt;  fastmap              1.1.0      2021-01-25 [1] CRAN (R 4.1.0)
#&amp;gt;  fitdistrplus         1.1-6      2021-09-28 [1] CRAN (R 4.1.0)
#&amp;gt;  forcats              0.5.1      2021-01-27 [1] CRAN (R 4.1.0)
#&amp;gt;  foreach              1.5.1      2020-10-15 [1] CRAN (R 4.1.0)
#&amp;gt;  fs                   1.5.0      2020-07-31 [1] CRAN (R 4.1.0)
#&amp;gt;  future               1.25.0     2022-04-24 [1] CRAN (R 4.1.2)
#&amp;gt;  future.apply         1.8.1      2021-08-10 [1] CRAN (R 4.1.0)
#&amp;gt;  generics             0.1.3      2022-07-05 [1] CRAN (R 4.1.2)
#&amp;gt;  GetoptLong           1.0.5      2020-12-15 [1] CRAN (R 4.1.0)
#&amp;gt;  ggbeeswarm           0.6.0      2017-08-07 [1] CRAN (R 4.1.0)
#&amp;gt;  ggplot2            * 3.4.4      2023-10-12 [1] CRAN (R 4.1.2)
#&amp;gt;  ggprism              1.0.3.9000 2021-12-07 [1] Github (csdaw/ggprism@e21c3ee)
#&amp;gt;  ggrastr              1.0.1      2021-12-08 [1] CRAN (R 4.1.0)
#&amp;gt;  ggrepel              0.9.3      2023-02-03 [1] CRAN (R 4.1.2)
#&amp;gt;  ggridges             0.5.4      2022-09-26 [1] CRAN (R 4.1.2)
#&amp;gt;  GlobalOptions        0.1.2      2020-06-10 [1] CRAN (R 4.1.0)
#&amp;gt;  globals              0.14.0     2020-11-22 [1] CRAN (R 4.1.0)
#&amp;gt;  glue                 1.6.2      2022-02-24 [1] CRAN (R 4.1.2)
#&amp;gt;  goftest              1.2-3      2021-10-07 [1] CRAN (R 4.1.0)
#&amp;gt;  gridExtra            2.3        2017-09-09 [1] CRAN (R 4.1.0)
#&amp;gt;  gtable               0.3.0      2019-03-25 [1] CRAN (R 4.1.0)
#&amp;gt;  highr                0.9        2021-04-16 [1] CRAN (R 4.1.0)
#&amp;gt;  htmltools            0.5.2      2021-08-25 [1] CRAN (R 4.1.0)
#&amp;gt;  htmlwidgets          1.5.4      2021-09-08 [1] CRAN (R 4.1.0)
#&amp;gt;  httpuv               1.6.3      2021-09-09 [1] CRAN (R 4.1.0)
#&amp;gt;  httr                 1.4.2      2020-07-20 [1] CRAN (R 4.1.0)
#&amp;gt;  ica                  1.0-2      2018-05-24 [1] CRAN (R 4.1.0)
#&amp;gt;  ifnb.SeuratData    * 3.1.0      2024-01-17 [1] local
#&amp;gt;  igraph               1.2.7      2021-10-15 [1] CRAN (R 4.1.0)
#&amp;gt;  IRanges              2.28.0     2021-10-26 [1] Bioconductor
#&amp;gt;  irlba                2.3.5.1    2022-10-03 [1] CRAN (R 4.1.2)
#&amp;gt;  iterators            1.0.13     2020-10-15 [1] CRAN (R 4.1.0)
#&amp;gt;  janitor              2.1.0      2021-01-05 [1] CRAN (R 4.1.0)
#&amp;gt;  jquerylib            0.1.4      2021-04-26 [1] CRAN (R 4.1.0)
#&amp;gt;  jsonlite             1.7.2      2020-12-09 [1] CRAN (R 4.1.0)
#&amp;gt;  KernSmooth           2.23-20    2021-05-03 [1] CRAN (R 4.1.2)
#&amp;gt;  knitr                1.36       2021-09-29 [1] CRAN (R 4.1.0)
#&amp;gt;  knockoff             0.3.6      2022-08-15 [1] CRAN (R 4.1.2)
#&amp;gt;  labeling             0.4.2      2020-10-20 [1] CRAN (R 4.1.0)
#&amp;gt;  lamW                 2.2.3      2023-12-01 [1] CRAN (R 4.1.2)
#&amp;gt;  later                1.3.0      2021-08-18 [1] CRAN (R 4.1.0)
#&amp;gt;  lattice              0.20-45    2021-09-22 [1] CRAN (R 4.1.2)
#&amp;gt;  lazyeval             0.2.2      2019-03-15 [1] CRAN (R 4.1.0)
#&amp;gt;  leiden               0.3.9      2021-07-27 [1] CRAN (R 4.1.0)
#&amp;gt;  lifecycle            1.0.3      2022-10-07 [1] CRAN (R 4.1.2)
#&amp;gt;  limma                3.50.0     2021-10-26 [1] Bioconductor
#&amp;gt;  listenv              0.8.0      2019-12-05 [1] CRAN (R 4.1.0)
#&amp;gt;  lmtest               0.9-39     2021-11-07 [1] CRAN (R 4.1.0)
#&amp;gt;  lubridate            1.8.0      2021-10-07 [1] CRAN (R 4.1.0)
#&amp;gt;  magick               2.7.4      2023-03-09 [1] CRAN (R 4.1.2)
#&amp;gt;  magrittr             2.0.1      2020-11-17 [1] CRAN (R 4.1.0)
#&amp;gt;  MASS                 7.3-54     2021-05-03 [1] CRAN (R 4.1.2)
#&amp;gt;  Matrix               1.6-3      2023-11-14 [1] CRAN (R 4.1.2)
#&amp;gt;  matrixStats          0.61.0     2021-09-17 [1] CRAN (R 4.1.0)
#&amp;gt;  memoise              2.0.0      2021-01-26 [1] CRAN (R 4.1.0)
#&amp;gt;  mime                 0.12       2021-09-28 [1] CRAN (R 4.1.0)
#&amp;gt;  miniUI               0.1.1.1    2018-05-18 [1] CRAN (R 4.1.0)
#&amp;gt;  munsell              0.5.0      2018-06-12 [1] CRAN (R 4.1.0)
#&amp;gt;  nlme                 3.1-153    2021-09-07 [1] CRAN (R 4.1.2)
#&amp;gt;  paletteer            1.4.0      2021-07-20 [1] CRAN (R 4.1.0)
#&amp;gt;  parallelly           1.31.1     2022-04-22 [1] CRAN (R 4.1.2)
#&amp;gt;  patchwork          * 1.1.1      2020-12-17 [1] CRAN (R 4.1.0)
#&amp;gt;  pbapply              1.5-0      2021-09-16 [1] CRAN (R 4.1.0)
#&amp;gt;  pbmc3k.SeuratData  * 3.1.4      2022-08-03 [1] local
#&amp;gt;  pbmcref.SeuratData * 1.0.0      2023-09-14 [1] local
#&amp;gt;  pillar               1.9.0      2023-03-22 [1] CRAN (R 4.1.2)
#&amp;gt;  pkgbuild             1.2.0      2020-12-15 [1] CRAN (R 4.1.0)
#&amp;gt;  pkgconfig            2.0.3      2019-09-22 [1] CRAN (R 4.1.0)
#&amp;gt;  pkgload              1.2.3      2021-10-13 [1] CRAN (R 4.1.0)
#&amp;gt;  plotly               4.10.0     2021-10-09 [1] CRAN (R 4.1.0)
#&amp;gt;  plyr                 1.8.6      2020-03-03 [1] CRAN (R 4.1.0)
#&amp;gt;  png                  0.1-8      2022-11-29 [1] CRAN (R 4.1.2)
#&amp;gt;  polyclip             1.10-0     2019-03-14 [1] CRAN (R 4.1.0)
#&amp;gt;  presto               1.0.0      2023-03-30 [1] Github (immunogenomics/presto@045390a)
#&amp;gt;  prettyunits          1.1.1      2020-01-24 [1] CRAN (R 4.1.0)
#&amp;gt;  prismatic            1.1.0      2021-10-17 [1] CRAN (R 4.1.0)
#&amp;gt;  processx             3.5.2      2021-04-30 [1] CRAN (R 4.1.0)
#&amp;gt;  progressr            0.9.0      2021-09-24 [1] CRAN (R 4.1.0)
#&amp;gt;  promises             1.2.0.1    2021-02-11 [1] CRAN (R 4.1.0)
#&amp;gt;  ps                   1.6.0      2021-02-28 [1] CRAN (R 4.1.0)
#&amp;gt;  purrr                1.0.1      2023-01-10 [1] CRAN (R 4.1.2)
#&amp;gt;  R6                   2.5.1      2021-08-19 [1] CRAN (R 4.1.0)
#&amp;gt;  RANN                 2.6.1      2019-01-08 [1] CRAN (R 4.1.0)
#&amp;gt;  rappdirs             0.3.3      2021-01-31 [1] CRAN (R 4.1.0)
#&amp;gt;  RColorBrewer         1.1-2      2014-12-07 [1] CRAN (R 4.1.0)
#&amp;gt;  Rcpp                 1.0.11     2023-07-06 [1] CRAN (R 4.1.2)
#&amp;gt;  RcppAnnoy            0.0.19     2021-07-30 [1] CRAN (R 4.1.0)
#&amp;gt;  RcppHNSW             0.3.0      2020-09-06 [1] CRAN (R 4.1.0)
#&amp;gt;  RcppParallel         5.1.4      2021-05-04 [1] CRAN (R 4.1.0)
#&amp;gt;  rematch2             2.1.2      2020-05-01 [1] CRAN (R 4.1.0)
#&amp;gt;  remotes              2.4.1      2021-09-29 [1] CRAN (R 4.1.0)
#&amp;gt;  reshape2             1.4.4      2020-04-09 [1] CRAN (R 4.1.0)
#&amp;gt;  reticulate           1.28       2023-01-27 [1] CRAN (R 4.1.2)
#&amp;gt;  rjson                0.2.20     2018-06-08 [1] CRAN (R 4.1.0)
#&amp;gt;  rlang                1.1.3      2024-01-10 [1] CRAN (R 4.1.2)
#&amp;gt;  rmarkdown            2.11       2021-09-14 [1] CRAN (R 4.1.0)
#&amp;gt;  ROCR                 1.0-11     2020-05-02 [1] CRAN (R 4.1.0)
#&amp;gt;  rprojroot            2.0.2      2020-11-15 [1] CRAN (R 4.1.0)
#&amp;gt;  RSpectra             0.16-0     2019-12-01 [1] CRAN (R 4.1.0)
#&amp;gt;  rstudioapi           0.13       2020-11-12 [1] CRAN (R 4.1.0)
#&amp;gt;  Rtsne                0.15       2018-11-10 [1] CRAN (R 4.1.0)
#&amp;gt;  S4Vectors            0.32.2     2021-11-07 [1] Bioconductor
#&amp;gt;  sass                 0.4.0      2021-05-12 [1] CRAN (R 4.1.0)
#&amp;gt;  scales               1.3.0      2023-11-28 [1] CRAN (R 4.1.2)
#&amp;gt;  scattermore          1.2        2023-06-12 [1] CRAN (R 4.1.2)
#&amp;gt;  scclusteval        * 0.0.0.9000 2022-08-05 [1] Github (crazyhottommy/scclusteval@b1b22c7)
#&amp;gt;  scCustomize        * 2.1.2      2024-02-28 [1] CRAN (R 4.1.2)
#&amp;gt;  sctransform          0.4.1      2023-10-19 [1] CRAN (R 4.1.2)
#&amp;gt;  sessioninfo          1.2.1      2021-11-02 [1] CRAN (R 4.1.0)
#&amp;gt;  Seurat             * 5.0.1      2023-11-17 [1] CRAN (R 4.1.2)
#&amp;gt;  SeuratData         * 0.2.2      2022-08-03 [1] Github (satijalab/seurat-data@d6a8ce6)
#&amp;gt;  SeuratObject       * 5.0.1      2023-11-17 [1] CRAN (R 4.1.2)
#&amp;gt;  shape                1.4.6      2021-05-19 [1] CRAN (R 4.1.0)
#&amp;gt;  shiny                1.7.1      2021-10-02 [1] CRAN (R 4.1.0)
#&amp;gt;  snakecase            0.11.0     2019-05-25 [1] CRAN (R 4.1.0)
#&amp;gt;  sp                 * 1.6-0      2023-01-19 [1] CRAN (R 4.1.2)
#&amp;gt;  spam                 2.10-0     2023-10-23 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.data        3.0-0      2022-10-21 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.explore     3.0-6      2023-01-26 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.geom        3.0-6      2023-01-30 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.random      3.1-3      2023-01-25 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.sparse      3.0-0      2022-10-21 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.utils       3.0-1      2022-10-19 [1] CRAN (R 4.1.2)
#&amp;gt;  stringi              1.7.5      2021-10-04 [1] CRAN (R 4.1.0)
#&amp;gt;  stringr              1.5.1      2023-11-14 [1] CRAN (R 4.1.2)
#&amp;gt;  survival             3.2-13     2021-08-24 [1] CRAN (R 4.1.2)
#&amp;gt;  tensor               1.5        2012-05-05 [1] CRAN (R 4.1.0)
#&amp;gt;  testthat             3.1.0      2021-10-04 [1] CRAN (R 4.1.0)
#&amp;gt;  tibble               3.2.1      2023-03-20 [1] CRAN (R 4.1.2)
#&amp;gt;  tictoc             * 1.0.1      2021-04-19 [1] CRAN (R 4.1.0)
#&amp;gt;  tidyr                1.3.0      2023-01-24 [1] CRAN (R 4.1.2)
#&amp;gt;  tidyselect           1.2.0      2022-10-10 [1] CRAN (R 4.1.2)
#&amp;gt;  usethis              2.1.3      2021-10-27 [1] CRAN (R 4.1.0)
#&amp;gt;  utf8                 1.2.2      2021-07-24 [1] CRAN (R 4.1.0)
#&amp;gt;  uwot                 0.1.14     2022-08-22 [1] CRAN (R 4.1.2)
#&amp;gt;  vctrs                0.6.2      2023-04-19 [1] CRAN (R 4.1.2)
#&amp;gt;  vipor                0.4.5      2017-03-22 [1] CRAN (R 4.1.0)
#&amp;gt;  viridisLite          0.4.0      2021-04-13 [1] CRAN (R 4.1.0)
#&amp;gt;  withr                2.5.0      2022-03-03 [1] CRAN (R 4.1.2)
#&amp;gt;  xfun                 0.36       2022-12-21 [1] CRAN (R 4.1.2)
#&amp;gt;  xtable               1.8-4      2019-04-21 [1] CRAN (R 4.1.0)
#&amp;gt;  yaml                 2.2.1      2020-02-01 [1] CRAN (R 4.1.0)
#&amp;gt;  zoo                  1.8-9      2021-03-09 [1] CRAN (R 4.1.0)
#&amp;gt; 
#&amp;gt;  [1] /Library/Frameworks/R.framework/Versions/4.1/Resources/library
#&amp;gt; 
#&amp;gt; ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Downstream of bulk RNAseq: read in salmon output using tximport and then DESeq2</title>
      <link>/post/downstream-of-bulk-rnaseq-read-in-salmon-output-using-tximport-and-then-deseq2/</link>
      <pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/downstream-of-bulk-rnaseq-read-in-salmon-output-using-tximport-and-then-deseq2/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/vembedr/css/vembedr.css&#34; rel=&#34;stylesheet&#34; /&gt;


&lt;p&gt;&lt;strong&gt;Join my &lt;a href=&#34;https://divingintogeneticsandgenomics.ck.page/newsletter&#34;&gt;newsletter&lt;/a&gt;
to not miss a post like this&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&#34;https://divingintogeneticsandgenomics.com/post/how-to-preprocess-geo-bulk-rnaseq-data-with-salmon/&#34;&gt;last blog post&lt;/a&gt;, I showed you how to use &lt;code&gt;salmon&lt;/code&gt; to get counts from
fastq files downloaded from GEO. In this post, I am going to show you how to read
in the &lt;code&gt;.sf&lt;/code&gt; salmon quantification file into R; how to get the &lt;code&gt;tx2gene.txt&lt;/code&gt;
file and do &lt;code&gt;DESeq2&lt;/code&gt; for differential gene expression analysis. Let‚Äôs dive in!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tximport)
library(dplyr)
library(ggplot2)

files&amp;lt;- list.files(path = &amp;quot;~/blog_data&amp;quot;, pattern = &amp;quot;.sf&amp;quot;, full.names = TRUE, 
                   recursive = TRUE)

names(files)&amp;lt;- stringr::str_split(files, pattern = &amp;quot;/&amp;quot;, simplify = TRUE)[,5] %&amp;gt;%
  stringr::str_replace(&amp;quot;_quant&amp;quot;, &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;prepare-the-tx2gene-file&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;prepare the tx2gene file&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# download it again if you have not
# wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_45/gencode.v45.basic.annotation.gtf.gz

# use the import function to read in the gtf file
gtf &amp;lt;- rtracklayer::import(&amp;quot;~/blog_data/gencode.v45.basic.annotation.gtf.gz&amp;quot;)

head(gtf)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; GRanges object with 6 ranges and 22 metadata columns:
#&amp;gt;       seqnames      ranges strand |   source       type     score     phase
#&amp;gt;          &amp;lt;Rle&amp;gt;   &amp;lt;IRanges&amp;gt;  &amp;lt;Rle&amp;gt; | &amp;lt;factor&amp;gt;   &amp;lt;factor&amp;gt; &amp;lt;numeric&amp;gt; &amp;lt;integer&amp;gt;
#&amp;gt;   [1]     chr1 11869-14409      + |   HAVANA gene              NA      &amp;lt;NA&amp;gt;
#&amp;gt;   [2]     chr1 11869-14409      + |   HAVANA transcript        NA      &amp;lt;NA&amp;gt;
#&amp;gt;   [3]     chr1 11869-12227      + |   HAVANA exon              NA      &amp;lt;NA&amp;gt;
#&amp;gt;   [4]     chr1 12613-12721      + |   HAVANA exon              NA      &amp;lt;NA&amp;gt;
#&amp;gt;   [5]     chr1 13221-14409      + |   HAVANA exon              NA      &amp;lt;NA&amp;gt;
#&amp;gt;   [6]     chr1 12010-13670      + |   HAVANA gene              NA      &amp;lt;NA&amp;gt;
#&amp;gt;                 gene_id              gene_type   gene_name       level
#&amp;gt;             &amp;lt;character&amp;gt;            &amp;lt;character&amp;gt; &amp;lt;character&amp;gt; &amp;lt;character&amp;gt;
#&amp;gt;   [1] ENSG00000290825.1                 lncRNA     DDX11L2           2
#&amp;gt;   [2] ENSG00000290825.1                 lncRNA     DDX11L2           2
#&amp;gt;   [3] ENSG00000290825.1                 lncRNA     DDX11L2           2
#&amp;gt;   [4] ENSG00000290825.1                 lncRNA     DDX11L2           2
#&amp;gt;   [5] ENSG00000290825.1                 lncRNA     DDX11L2           2
#&amp;gt;   [6] ENSG00000223972.6 transcribed_unproces..     DDX11L1           2
#&amp;gt;                       tag     transcript_id transcript_type transcript_name
#&amp;gt;               &amp;lt;character&amp;gt;       &amp;lt;character&amp;gt;     &amp;lt;character&amp;gt;     &amp;lt;character&amp;gt;
#&amp;gt;   [1] overlaps_pseudogene              &amp;lt;NA&amp;gt;            &amp;lt;NA&amp;gt;            &amp;lt;NA&amp;gt;
#&amp;gt;   [2]   Ensembl_canonical ENST00000456328.2          lncRNA     DDX11L2-202
#&amp;gt;   [3]   Ensembl_canonical ENST00000456328.2          lncRNA     DDX11L2-202
#&amp;gt;   [4]   Ensembl_canonical ENST00000456328.2          lncRNA     DDX11L2-202
#&amp;gt;   [5]   Ensembl_canonical ENST00000456328.2          lncRNA     DDX11L2-202
#&amp;gt;   [6]                &amp;lt;NA&amp;gt;              &amp;lt;NA&amp;gt;            &amp;lt;NA&amp;gt;            &amp;lt;NA&amp;gt;
#&amp;gt;       transcript_support_level    havana_transcript exon_number
#&amp;gt;                    &amp;lt;character&amp;gt;          &amp;lt;character&amp;gt; &amp;lt;character&amp;gt;
#&amp;gt;   [1]                     &amp;lt;NA&amp;gt;                 &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [2]                        1 OTTHUMT00000362751.1        &amp;lt;NA&amp;gt;
#&amp;gt;   [3]                        1 OTTHUMT00000362751.1           1
#&amp;gt;   [4]                        1 OTTHUMT00000362751.1           2
#&amp;gt;   [5]                        1 OTTHUMT00000362751.1           3
#&amp;gt;   [6]                     &amp;lt;NA&amp;gt;                 &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;                 exon_id     hgnc_id          havana_gene         ont
#&amp;gt;             &amp;lt;character&amp;gt; &amp;lt;character&amp;gt;          &amp;lt;character&amp;gt; &amp;lt;character&amp;gt;
#&amp;gt;   [1]              &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;                 &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [2]              &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;                 &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [3] ENSE00002234944.1        &amp;lt;NA&amp;gt;                 &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [4] ENSE00003582793.1        &amp;lt;NA&amp;gt;                 &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [5] ENSE00002312635.1        &amp;lt;NA&amp;gt;                 &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [6]              &amp;lt;NA&amp;gt;  HGNC:37102 OTTHUMG00000000961.2        &amp;lt;NA&amp;gt;
#&amp;gt;        protein_id      ccdsid  artif_dupl
#&amp;gt;       &amp;lt;character&amp;gt; &amp;lt;character&amp;gt; &amp;lt;character&amp;gt;
#&amp;gt;   [1]        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [2]        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [3]        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [4]        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [5]        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   [6]        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;        &amp;lt;NA&amp;gt;
#&amp;gt;   -------
#&amp;gt;   seqinfo: 25 sequences from an unspecified genome; no seqlengths&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gtf is a &lt;code&gt;GenomicRanges&lt;/code&gt; object. You can use &lt;code&gt;plyranges&lt;/code&gt; from tidyomics &lt;a href=&#34;https://github.com/tidyomics&#34; class=&#34;uri&#34;&gt;https://github.com/tidyomics&lt;/a&gt; to manipulate it.&lt;/p&gt;
&lt;p&gt;I will convert it to a dataframe and use &lt;code&gt;tidyverse&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gtf_df&amp;lt;- as.data.frame(gtf)

# this file is used to import the salmon output to summarize the counts from 
# transcript level to gene level
tx2gene&amp;lt;- gtf_df %&amp;gt;%
        filter(type == &amp;quot;transcript&amp;quot;) %&amp;gt;%
        select(transcript_id, gene_id)


# this file is used to map the ENSEMBL gene id to gene symbols in the DESeq2 results
gene_name_map&amp;lt;- gtf_df %&amp;gt;% 
        filter(type == &amp;quot;gene&amp;quot;) %&amp;gt;% 
        select(gene_id, gene_name) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are interested in using Unix commands&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;zcat gencode.v45.basic.annotation.gtf.gz | \
awk -F &amp;quot;\t&amp;quot; &amp;#39;$3 == &amp;quot;transcript&amp;quot; { print $9 }&amp;#39;| tr -s &amp;quot;;&amp;quot; &amp;quot; &amp;quot;   | \
cut -d &amp;quot; &amp;quot; -f2,4|  sed &amp;#39;s/\&amp;quot;//g&amp;#39; | awk &amp;#39;{print $1&amp;quot;.&amp;quot;$2}&amp;#39; &amp;gt; genes.txt

zcat gencode.v45.basic.annotation.gtf.gz | \
awk -F &amp;quot;\t&amp;quot; &amp;#39;$3 == &amp;quot;transcript&amp;quot; { print $9 }&amp;#39; | tr -s &amp;quot;;&amp;quot; &amp;quot; &amp;quot;   | \
cut -d &amp;quot; &amp;quot; -f6,8|  sed &amp;#39;s/\&amp;quot;//g&amp;#39; | awk &amp;#39;{print $1&amp;quot;.&amp;quot;$2}&amp;#39; &amp;gt; transcripts.txt

paste transcripts.txt genes.txt &amp;gt; tx2genes.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;read-in-the-salmon-output&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Read in the salmon output&lt;/h3&gt;
&lt;p&gt;Use &lt;code&gt;tx2gene&lt;/code&gt; to summarize to gene level.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;txi.salmon &amp;lt;- tximport(files, type = &amp;quot;salmon&amp;quot;, tx2gene = tx2gene)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are ready for &lt;code&gt;DESeq2&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(DESeq2)
meta&amp;lt;- data.frame(condition = c(&amp;quot;normoxia&amp;quot;, &amp;quot;normoxia&amp;quot;, &amp;quot;hypoxia&amp;quot;, &amp;quot;hypoxia&amp;quot;))

rownames(meta)&amp;lt;- colnames(txi.salmon$counts)

meta&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;             condition
#&amp;gt; SRX14311105  normoxia
#&amp;gt; SRX14311106  normoxia
#&amp;gt; SRX14311111   hypoxia
#&amp;gt; SRX14311112   hypoxia&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;routine DESeq2 workflow&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dds &amp;lt;- DESeqDataSetFromTximport(txi.salmon, meta, ~ condition)

dds$condition &amp;lt;- relevel(dds$condition, ref = &amp;quot;normoxia&amp;quot;)

dds &amp;lt;- DESeq(dds)

res &amp;lt;- results(dds, contrast = c(&amp;quot;condition&amp;quot;, &amp;quot;hypoxia&amp;quot;, &amp;quot;normoxia&amp;quot;))

res&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; log2 fold change (MLE): condition hypoxia vs normoxia 
#&amp;gt; Wald test p-value: condition hypoxia vs normoxia 
#&amp;gt; DataFrame with 62742 rows and 6 columns
#&amp;gt;                     baseMean log2FoldChange     lfcSE      stat      pvalue
#&amp;gt;                    &amp;lt;numeric&amp;gt;      &amp;lt;numeric&amp;gt; &amp;lt;numeric&amp;gt; &amp;lt;numeric&amp;gt;   &amp;lt;numeric&amp;gt;
#&amp;gt; ENSG00000000003.16   590.875     -0.0375376 0.1823407 -0.205865 8.36896e-01
#&amp;gt; ENSG00000000005.6      0.000             NA        NA        NA          NA
#&amp;gt; ENSG00000000419.14  2132.232     -0.4060705 0.0905846 -4.482775 7.36787e-06
#&amp;gt; ENSG00000000457.14   258.375      0.1292684 0.2548623  0.507209 6.12008e-01
#&amp;gt; ENSG00000000460.17   424.209     -0.8150114 0.2104556 -3.872606 1.07678e-04
#&amp;gt; ...                      ...            ...       ...       ...         ...
#&amp;gt; ENSG00000293556.1   0.224455        1.13592   4.99736  0.227304    0.820187
#&amp;gt; ENSG00000293557.1   6.144520        0.50388   2.10169  0.239750    0.810524
#&amp;gt; ENSG00000293558.1   1.184183       -3.83345   4.18101 -0.916871    0.359210
#&amp;gt; ENSG00000293559.1   0.000000             NA        NA        NA          NA
#&amp;gt; ENSG00000293560.1   1.574315        3.94434   3.65835  1.078175    0.280955
#&amp;gt;                           padj
#&amp;gt;                      &amp;lt;numeric&amp;gt;
#&amp;gt; ENSG00000000003.16 9.28301e-01
#&amp;gt; ENSG00000000005.6           NA
#&amp;gt; ENSG00000000419.14 5.54264e-05
#&amp;gt; ENSG00000000457.14 7.93342e-01
#&amp;gt; ENSG00000000460.17 6.55843e-04
#&amp;gt; ...                        ...
#&amp;gt; ENSG00000293556.1           NA
#&amp;gt; ENSG00000293557.1           NA
#&amp;gt; ENSG00000293558.1           NA
#&amp;gt; ENSG00000293559.1           NA
#&amp;gt; ENSG00000293560.1           NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs take a look at the p-value distribution in a histogram&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;res %&amp;gt;% as.data.frame() %&amp;gt;%
  arrange(padj) %&amp;gt;%
  ggplot(aes(x=pvalue)) +
  geom_histogram(color = &amp;quot;white&amp;quot;, bins = 50)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-18-downstream-of-bulk-rnaseq-read-in-salmon-output-using-tximport-and-then-deseq2_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Did you see a spike around 0.8? that‚Äôs strange. p-values are random variables
and under the null, they should follow a uniform distribution which means we
should see a spike near p=0 and the rest is flat if there are differentially
expressed genes due to the treatment effect.&lt;/p&gt;
&lt;p&gt;Read:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;my old post &lt;a href=&#34;https://divingintogeneticsandgenomics.com/post/understanding-p-value-multiple-comparisons-fdr-and-q-value/&#34;&gt;Understanding p value, multiple comparisons, FDR and q value&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;and &lt;a href=&#34;http://varianceexplained.org/statistics/interpreting-pvalue-histogram/&#34;&gt;How to interpret a p-value histogram&lt;/a&gt; by
David Robinson.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Genes with small counts can mess up the p-values.
Let‚Äôs compare the counts:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;res %&amp;gt;% as.data.frame() %&amp;gt;%
        tibble::rownames_to_column(var = &amp;quot;gene_id&amp;quot;) %&amp;gt;%
        filter(!is.na(pvalue)) %&amp;gt;%
        mutate(pvalue_bin = if_else(pvalue &amp;gt; 0.75, &amp;quot;high&amp;quot;, &amp;quot;low&amp;quot;)) %&amp;gt;%
        ggplot(aes(x= pvalue_bin, y = log2(baseMean))) +
        geom_boxplot()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-18-downstream-of-bulk-rnaseq-read-in-salmon-output-using-tximport-and-then-deseq2_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;
genes with high p-values do seem to have lower gene expression.&lt;/p&gt;
&lt;p&gt;Let‚Äôs remove them:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# counts across 4 samples should be greater than 10, this number is subjective
dds &amp;lt;- dds[rowSums(counts(dds)) &amp;gt; 10,]

dds &amp;lt;- DESeq(dds)

res &amp;lt;- results(dds, contrast = c(&amp;quot;condition&amp;quot;, &amp;quot;hypoxia&amp;quot;, &amp;quot;normoxia&amp;quot;))

res %&amp;gt;% as.data.frame() %&amp;gt;%
  arrange(padj) %&amp;gt;%
  ggplot(aes(x=pvalue)) +
  geom_histogram(color = &amp;quot;white&amp;quot;, bins = 50)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-18-downstream-of-bulk-rnaseq-read-in-salmon-output-using-tximport-and-then-deseq2_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now, the p-value distribution looks much more normal!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;map-the-ensembl-id-to-gene-symbols&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;map the ENSEMBL ID to gene symbols&lt;/h3&gt;
&lt;p&gt;Now, we have one last task left. The ids for the genes are ENSEMBL IDs, we
want to map it to gene symbols.&lt;/p&gt;
&lt;p&gt;You can use bioconductor packages such as &lt;code&gt;AnnotationDbi::select()&lt;/code&gt; or
&lt;code&gt;clusterProfiler::bitr()&lt;/code&gt; function to map gene ids.&lt;/p&gt;
&lt;p&gt;In this case, we already have the gtf file and &lt;code&gt;gene_name_map&lt;/code&gt; is what we
need.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;add_gene_name&amp;lt;- function(res){
  df&amp;lt;- as.data.frame(res) %&amp;gt;%
    tibble::rownames_to_column(var = &amp;quot;gene_id&amp;quot;) %&amp;gt;%
    left_join(gene_name_map) %&amp;gt;%
    arrange(padj, abs(log2FoldChange))
  return(df)
}


add_gene_name(res) %&amp;gt;%
        head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;              gene_id  baseMean log2FoldChange      lfcSE      stat
#&amp;gt; 1 ENSG00000102144.15 18910.289       1.562405 0.03979063  39.26566
#&amp;gt; 2 ENSG00000059804.17 62423.746       1.824985 0.03108234  58.71453
#&amp;gt; 3  ENSG00000134107.5  6115.319       2.386547 0.05854293  40.76577
#&amp;gt; 4 ENSG00000113739.11  8674.164       2.753104 0.06956149  39.57799
#&amp;gt; 5 ENSG00000146674.16 21865.720       5.333293 0.05964448  89.41804
#&amp;gt; 6  ENSG00000104371.5  4414.600      -3.778082 0.10725864 -35.22403
#&amp;gt;          pvalue         padj gene_name
#&amp;gt; 1  0.000000e+00  0.00000e+00      PGK1
#&amp;gt; 2  0.000000e+00  0.00000e+00    SLC2A3
#&amp;gt; 3  0.000000e+00  0.00000e+00   BHLHE40
#&amp;gt; 4  0.000000e+00  0.00000e+00      STC2
#&amp;gt; 5  0.000000e+00  0.00000e+00    IGFBP3
#&amp;gt; 6 8.573205e-272 2.49766e-268      DKK4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, this is perfect! And I instantly spot &lt;code&gt;PGK1&lt;/code&gt;, &lt;code&gt;SLC2A3&lt;/code&gt;, &lt;code&gt;IGFBP3&lt;/code&gt; etc are the top
differentially expressed genes which I know are hypoxia-inducible :)&lt;/p&gt;
&lt;p&gt;Subscribe to the youtube channel to watch the video!&lt;/p&gt;
&lt;div class=&#34;vembedr&#34;&gt;
&lt;div&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/RWpY7EqHOUw&#34; width=&#34;533&#34; height=&#34;300&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;&#34; data-external=&#34;1&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>How to preprocess GEO bulk RNAseq data with salmon </title>
      <link>/post/how-to-preprocess-geo-bulk-rnaseq-data-with-salmon/</link>
      <pubDate>Wed, 13 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/how-to-preprocess-geo-bulk-rnaseq-data-with-salmon/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/vembedr/css/vembedr.css&#34; rel=&#34;stylesheet&#34; /&gt;


&lt;div id=&#34;install-fastq-dl&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Install fastq-dl&lt;/h3&gt;
&lt;p&gt;To easily download fastq from GEO or ENA, use &lt;a href=&#34;https://github.com/rpetit3/fastq-dl&#34;&gt;fastq-dl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Assume you already have &lt;a href=&#34;https://conda.io/projects/conda/en/latest/user-guide/install/index.html&#34;&gt;&lt;code&gt;conda&lt;/code&gt;&lt;/a&gt; installed, do the following:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;conda config --add channels conda-forge
conda config --add channels bioconda
conda create -n fastq_download -c conda-forge -c bioconda fastq-dl
conda activate fastq_download &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;: use &lt;a href=&#34;https://github.com/mamba-org/mamba&#34;&gt;&lt;code&gt;mamba&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;conda&lt;/code&gt; is too slow for you.
They are all big snakes!!&lt;/p&gt;
&lt;p&gt;We will use bulk RNAseq data from this GEO accession ID:
&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE197576&#34; class=&#34;uri&#34;&gt;https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE197576&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;mkdir hypoxia_RNAseq
cd hypoxia_RNAseq

mkdir data
cd data
## some times the same experiment may have multiple runs (SRR)
## use the --group-by-experiment to merge them, this example only has one SRR
## per sample   

## normoxia sgCTRL
fastq-dl --accession SRX14311105  --group-by-experiment
fastq-dl --accession SRX14311106  --group-by-experiment

## hypoxia sgCTRL
fastq-dl --accession SRX14311111  --group-by-experiment
fastq-dl --accession SRX14311112  --group-by-experiment&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We only have 4 samples here and we typed in the command one by one which is fine.
What if we want to process all of them and you do not want to do it manually.&lt;/p&gt;
&lt;p&gt;Get the metadata using &lt;a href=&#34;https://github.com/NCBI-Hackathons/ncbi-cloud-tutorials/blob/master/SRA%20tutorials/tutorial_SRA_run_selector.md&#34;&gt;SRA Run selector&lt;/a&gt; or use &lt;a href=&#34;https://www.youtube.com/watch?v=NSoU58IqA3Y&#34;&gt;GEOquery&lt;/a&gt; or &lt;a href=&#34;https://www.bioconductor.org/packages/release/bioc/html/GEOmetadb.html&#34;&gt;GEOmetadb&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You may want to do a &lt;code&gt;fastqc&lt;/code&gt; for quality control of the reads and trimming with
&lt;code&gt;fastp&lt;/code&gt; for the sequencing adapters. We will skip it in this tutorial.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;install-salmon&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;install salmon&lt;/h3&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;conda create -n salmon salmon&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;build-an-index&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;build an index&lt;/h3&gt;
&lt;p&gt;We need a transcriptome fasta file to build the index, we also need the gtf file that we can
use to map gene ids.&lt;/p&gt;
&lt;p&gt;Let‚Äôs go to gencode &lt;a href=&#34;https://www.gencodegenes.org/human/&#34; class=&#34;uri&#34;&gt;https://www.gencodegenes.org/human/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There are multiple sources to get the reference files. If you are confused,
watch this video.&lt;/p&gt;
&lt;div class=&#34;vembedr&#34;&gt;
&lt;div&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/eIVlSG11umQ&#34; width=&#34;533&#34; height=&#34;300&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;&#34; data-external=&#34;1&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Download the reference fasta:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;cd hypoxia_RNAseq
mkdir reference
cd reference

wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_45/gencode.v45.annotation.gtf.gz


wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_45/gencode.v45.basic.annotation.gtf.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A quick look at the gtf file:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;zless -S gencode.v45.annotation.gtf.gz | grep -v &amp;quot;#&amp;quot; | \
awk &amp;#39;$3==&amp;quot;gene&amp;quot;&amp;#39; | cut -f9 | head -3

gene_id &amp;quot;ENSG00000290825.1&amp;quot;; gene_type &amp;quot;lncRNA&amp;quot;; gene_name &amp;quot;DDX11L2&amp;quot;; level 2; tag &amp;quot;overlaps_pseudogene&amp;quot;;
gene_id &amp;quot;ENSG00000223972.6&amp;quot;; gene_type &amp;quot;transcribed_unprocessed_pseudogene&amp;quot;; gene_name &amp;quot;DDX11L1&amp;quot;; level 2; hgnc_id &amp;quot;HGNC:37102&amp;quot;; havana_gene &amp;quot;OTTHUMG00000000961.2&amp;quot;;
gene_id &amp;quot;ENSG00000227232.6&amp;quot;; gene_type &amp;quot;unprocessed_pseudogene&amp;quot;; gene_name &amp;quot;WASH7P&amp;quot;; level 2; hgnc_id &amp;quot;HGNC:38034&amp;quot;; havana_gene &amp;quot;OTTHUMG00000000958.1&amp;quot;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs tally the gene_type&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;zless -S gencode.v45.annotation.gtf.gz | grep -v &amp;quot;#&amp;quot; | \
awk &amp;#39;$3==&amp;quot;gene&amp;quot;&amp;#39; | cut -f9 | \
cut -f2 -d &amp;quot;;&amp;quot; | sort | uniq -c | sort -k1,1nr

  20049  gene_type &amp;quot;protein_coding&amp;quot;
  19370  gene_type &amp;quot;lncRNA&amp;quot;
  10143  gene_type &amp;quot;processed_pseudogene&amp;quot;
   2604  gene_type &amp;quot;unprocessed_pseudogene&amp;quot;
   2208  gene_type &amp;quot;misc_RNA&amp;quot;
   1901  gene_type &amp;quot;snRNA&amp;quot;
   1879  gene_type &amp;quot;miRNA&amp;quot;
   1054  gene_type &amp;quot;TEC&amp;quot;
    962  gene_type &amp;quot;transcribed_unprocessed_pseudogene&amp;quot;
    942  gene_type &amp;quot;snoRNA&amp;quot;
    513  gene_type &amp;quot;transcribed_processed_pseudogene&amp;quot;
    497  gene_type &amp;quot;rRNA_pseudogene&amp;quot;
    187  gene_type &amp;quot;IG_V_pseudogene&amp;quot;
    158  gene_type &amp;quot;transcribed_unitary_pseudogene&amp;quot;
    145  gene_type &amp;quot;IG_V_gene&amp;quot;
    107  gene_type &amp;quot;TR_V_gene&amp;quot;
    100  gene_type &amp;quot;unitary_pseudogene&amp;quot;
     79  gene_type &amp;quot;TR_J_gene&amp;quot;
     49  gene_type &amp;quot;scaRNA&amp;quot;
     47  gene_type &amp;quot;rRNA&amp;quot;
     37  gene_type &amp;quot;IG_D_gene&amp;quot;
     33  gene_type &amp;quot;TR_V_pseudogene&amp;quot;
     22  gene_type &amp;quot;Mt_tRNA&amp;quot;
     19  gene_type &amp;quot;artifact&amp;quot;
     18  gene_type &amp;quot;IG_J_gene&amp;quot;
     14  gene_type &amp;quot;IG_C_gene&amp;quot;
      9  gene_type &amp;quot;IG_C_pseudogene&amp;quot;
      8  gene_type &amp;quot;ribozyme&amp;quot;
      6  gene_type &amp;quot;TR_C_gene&amp;quot;
      5  gene_type &amp;quot;TR_D_gene&amp;quot;
      5  gene_type &amp;quot;sRNA&amp;quot;
      4  gene_type &amp;quot;TR_J_pseudogene&amp;quot;
      4  gene_type &amp;quot;vault_RNA&amp;quot;
      3  gene_type &amp;quot;IG_J_pseudogene&amp;quot;
      2  gene_type &amp;quot;Mt_rRNA&amp;quot;
      2  gene_type &amp;quot;translated_processed_pseudogene&amp;quot;
      1  gene_type &amp;quot;IG_pseudogene&amp;quot;
      1  gene_type &amp;quot;scRNA&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will use the &lt;code&gt;gtf&lt;/code&gt; file for downstream analysis.&lt;/p&gt;
&lt;p&gt;Download the transcript fasta file&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_45/gencode.v45.transcripts.fa.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index the transcriptome&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;# list all the conda env
conda env list

# activate the salmon env
conda activate salmon

salmon index -t gencode.v45.transcripts.fa.gz -i gencode.v45_human_index -k 31 --gencode&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;quantification&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;quantification&lt;/h3&gt;
&lt;p&gt;This is a single end read dataset, so I used &lt;code&gt;-r&lt;/code&gt; to feed in the fastq. If you
have paired-end reads, you need to use &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;-2&lt;/code&gt; for the &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt; reads.&lt;/p&gt;
&lt;p&gt;There are also different library types for paired end reads. read &lt;a href=&#34;https://salmon.readthedocs.io/en/latest/library_type.html&#34;&gt;the documentation&lt;/a&gt; for details.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/salmon_lib.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Make sure you know how the library is constructed. I do not know if this library
is stranded or unstranded, so I used &lt;code&gt;-l A&lt;/code&gt; to automatically let
salmon to detect the library type. salmon detected it as &lt;code&gt;U&lt;/code&gt; unstranded.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;cd ..

salmon quant -i reference/gencode.v45_human_index/ -l A -r SRX14311105.fastq.gz -o SRX14311105_quant  --validateMappings&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This finished in a couple of mins, so fast!&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;cat SRX14311105_quant/logs/salmon_quant.log | grep &amp;quot;Mapping rate&amp;quot;
[jointLog] [info] Mapping rate = 93.0329%&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;93% mapping rate!&lt;/p&gt;
&lt;p&gt;Let‚Äôs do the same for the other 3 samples&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;salmon quant -i reference/gencode.v45_human_index/ -l A -r SRX14311106.fastq.gz -o SRX14311106_quant  --validateMappings

salmon quant -i reference/gencode.v45_human_index/ -l A -r SRX14311111.fastq.gz -o SRX14311111_quant  --validateMappings

salmon quant -i reference/gencode.v45_human_index/ -l A -r SRX14311112.fastq.gz -o SRX14311112_quant  --validateMappings&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have the salmon quantification output:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt; find . -name &amp;quot;*sf&amp;quot;
./SRX14311111_quant/quant.sf
./SRX14311105_quant/quant.sf
./SRX14311106_quant/quant.sf
./SRX14311112_quant/quant.sf&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the mapping rates are all pretty high:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;find . -name &amp;quot;salmon_quant.log&amp;quot; | xargs grep &amp;quot;Mapping rate&amp;quot;
./SRX14311111_quant/logs/salmon_quant.log:[jointLog] [info] Mapping rate = 91.5163%
./SRX14311105_quant/logs/salmon_quant.log:[jointLog] [info] Mapping rate = 93.0329%
./SRX14311106_quant/logs/salmon_quant.log:[jointLog] [info] Mapping rate = 92.8808%
./SRX14311112_quant/logs/salmon_quant.log:[jointLog] [info] Mapping rate = 91.4357%&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we can load it into R and use &lt;code&gt;DESeq2&lt;/code&gt;for downstream analysis. That‚Äôs for another post!
Happy Learning!&lt;/p&gt;
&lt;p&gt;Watch the video here:&lt;/p&gt;
&lt;div class=&#34;vembedr&#34;&gt;
&lt;div&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/_Q8fYokTCTs&#34; width=&#34;533&#34; height=&#34;300&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;&#34; data-external=&#34;1&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Do you really understand log2Fold change in single-cell RNAseq data?</title>
      <link>/post/do-you-really-understand-log2fold-change-in-single-cell-rnaseq-data/</link>
      <pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/do-you-really-understand-log2fold-change-in-single-cell-rnaseq-data/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;In Single-cell RNAseq analysis, there is a step to find the marker genes for
each cluster. The output from &lt;code&gt;Seurat&lt;/code&gt; &lt;code&gt;FindAllMarkers&lt;/code&gt; has a column called &lt;code&gt;avg_log2FC&lt;/code&gt;.
It is the gene expression log2 fold change between cluster x and all other clusters.&lt;/p&gt;
&lt;p&gt;How is that calculated? In this &lt;a href=&#34;https://twitter.com/lpachter/status/1694387749967847874&#34;&gt;tweet thread&lt;/a&gt; by Lior Pachter,
he said that there was a discrepancy for the logFC changes between &lt;code&gt;Seurat&lt;/code&gt; and
&lt;code&gt;Scanpy&lt;/code&gt;:
&lt;img src=&#34;/img/logFC_singlecell.jpeg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Actually, both &lt;code&gt;Scanpy&lt;/code&gt; and &lt;code&gt;Seurat&lt;/code&gt; calculate it wrong. Let‚Äôs dive in.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)
library(SeuratData)
library(dplyr)
library(scCustomize)

data(&amp;quot;pbmc3k&amp;quot;)

# some error, need to update the object
pbmc3k&amp;lt;- UpdateSeuratObject(pbmc3k)

pbmc3k&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; An object of class Seurat 
#&amp;gt; 13714 features across 2700 samples within 1 assay 
#&amp;gt; Active assay: RNA (13714 features, 0 variable features)
#&amp;gt;  2 layers present: counts, data&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some routine processing&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pbmc3k&amp;lt;- pbmc3k %&amp;gt;% 
  NormalizeData(normalization.method = &amp;quot;LogNormalize&amp;quot;, scale.factor = 10000) %&amp;gt;%
  FindVariableFeatures(selection.method = &amp;quot;vst&amp;quot;, nfeatures = 2000) %&amp;gt;%
  ScaleData() %&amp;gt;%
  RunPCA(verbose = FALSE) %&amp;gt;%
  FindNeighbors(dims = 1:10, verbose = FALSE) %&amp;gt;%
  FindClusters(resolution = 0.5, verbose = FALSE) %&amp;gt;%
  RunUMAP(dims = 1:10, verbose = FALSE)

pbmc3k&amp;lt;- pbmc3k[, !is.na(pbmc3k$seurat_annotations)]

p1&amp;lt;- DimPlot_scCustom(pbmc3k, reduction = &amp;quot;umap&amp;quot;, label = TRUE, group.by = 
                        &amp;quot;RNA_snn_res.0.5&amp;quot;)

p2&amp;lt;- DimPlot_scCustom(pbmc3k, reduction = &amp;quot;umap&amp;quot;, label = TRUE, group.by = &amp;quot;seurat_annotations&amp;quot;, label.size = 3)

p1 + p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-05-do-you-really-understand-log2fold-change-in-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# use Seurat&amp;#39;s FindAllMarkers function
markers_seurat&amp;lt;- FindAllMarkers(pbmc3k)

head(markers_seurat)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;               p_val avg_log2FC pct.1 pct.2     p_val_adj cluster  gene
#&amp;gt; RPS6  5.467436e-142  0.6963639 1.000 0.995 7.498042e-138       0  RPS6
#&amp;gt; RPS12 1.026837e-138  0.7323892 1.000 0.991 1.408204e-134       0 RPS12
#&amp;gt; RPS27 9.369933e-132  0.7125597 0.999 0.992 1.284993e-127       0 RPS27
#&amp;gt; RPL32 1.289946e-131  0.6221148 0.999 0.995 1.769031e-127       0 RPL32
#&amp;gt; RPS14 9.504872e-124  0.6261648 1.000 0.994 1.303498e-119       0 RPS14
#&amp;gt; CYBA  1.875899e-123 -1.7566153 0.658 0.913 2.572608e-119       0  CYBA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs take a look at CD19 which is a B cell marker. cluster 3 is the B cell cluster.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;markers_seurat %&amp;gt;%
        filter(cluster == 3) %&amp;gt;%
        filter(gene == &amp;quot;CD19&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;               p_val avg_log2FC pct.1 pct.2    p_val_adj cluster gene
#&amp;gt; CD19.3 3.322761e-87    5.62015 0.216 0.007 4.556834e-83       3 CD19&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, &lt;code&gt;FindAllMarkers&lt;/code&gt; uses Wilcoxon Rank Sum test. use &lt;code&gt;?FindAllMarkers&lt;/code&gt;
to see the details of other tests.&lt;/p&gt;
&lt;p&gt;Three things to note.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;the p-values are very small. When you have hundreds or thousands of cells per
cluster, the p-values will be very small. The p-value in statistical tests, including the Wilcoxon rank-sum test (also known as the Mann-Whitney U test), is influenced by both the sample size and the variability. As the sample size increases, the p-value tends to decrease, assuming there is a non-zero effect size.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The p-values are inflated, as we cluster the cells first then use the cluster label
to calculate the p-values. We are double-dipping the data. See this &lt;a href=&#34;https://twitter.com/lucylgao/status/1299763664644313089?lang=en&#34;&gt;twitter thread&lt;/a&gt; for
more details, and this paper &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7202736/&#34;&gt;Valid post-clustering differential analysis for single-cell RNA-Seq&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There are nuances in how the log2 Fold change is calculated. &lt;code&gt;Scanpy&lt;/code&gt; and &lt;code&gt;Seurat&lt;/code&gt;have different implementations.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Seurat formula:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(R_{g}=\log_{2}(\frac{1}{n_{1}}\sum_{i\in G_{1}}(exp(Y_{ig})-1)+1)-log_{2}(\frac{1}{n_{2}}\sum_{i\in G_{2}}(exp(Y_{ig})-1)+1),\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scanpy formula:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(P_{g}=\log_{2}(exp(\frac{1}{n_{1}}\sum_{i\in G_{1}}Y_{ig})-1+\epsilon)-log_{2}(exp(\frac{1}{n_{2}}\sum_{i\in G_{2}}Y_{ig})-1+\epsilon),\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\epsilon=10^{-9}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(Y_{ig}\)&lt;/span&gt; are the log-transformed expression values for cell &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; and gene &lt;span class=&#34;math inline&#34;&gt;\(g\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(G_{1}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(G_{2}\)&lt;/span&gt; are the indices for two groups of cells, and &lt;span class=&#34;math inline&#34;&gt;\(n_{1}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(n_{2}\)&lt;/span&gt; are the numbers of cells in the respective groups.&lt;/p&gt;
&lt;div id=&#34;lets-calculate-the-fold-change-manually&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Let‚Äôs calculate the fold change manually&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NormalizeData(normalization.method = &#34;LogNormalize&#34;, scale.factor = 10000)&lt;/code&gt; this
step divide the raw gene counts with the total counts of that cell (library size)
and then natural log it and times the scaling factor of 10000.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# CD19 natural log library size normalized expression
log_normalized_data&amp;lt;- pbmc3k@assays$RNA@data[&amp;quot;CD19&amp;quot;, ]

# a logical vector indicating the cells from cluster 3
cluster_B_index&amp;lt;- pbmc3k$seurat_clusters == 3

# negate it to get the cells from all other clusters
other_clusters_index&amp;lt;- !cluster_B_index

# the natural log normalized counts for gene x from cluster 0
cluster_B_norm_data&amp;lt;- log_normalized_data[cluster_B_index]
        
# the natural log normalized counts for gene x from all other clusters
other_cluster_norm_data&amp;lt;- log_normalized_data[other_clusters_index]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let‚Äôs &lt;code&gt;exp&lt;/code&gt; it back and minus 1 to get the lib normalized counts without
log transformation; take the mean across cells plus a tiny number, then log2
transform:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cells from B cell cluster
log2_mean_clusterB&amp;lt;- log2(mean(exp(cluster_B_norm_data)-1) + 10^-9)

log2_mean_clusterB&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; [1] 0.5181239&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cells from all other clusters 
log2_mean_other_cluster&amp;lt;- log2(mean(exp(other_cluster_norm_data)-1) +10^-9)

log2_mean_other_cluster&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; [1] -5.1208&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let‚Äôs calculate the log2 fold change:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log2_mean_clusterB - log2_mean_other_cluster&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; [1] 5.638924&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, it seems &lt;code&gt;Seurat&lt;/code&gt; updated their calculation method to add a small value
of &lt;code&gt;10^-9&lt;/code&gt; rather than 1. This is almost the same as the &lt;code&gt;FindAllMarkers&lt;/code&gt; results‚Ä¶&lt;/p&gt;
&lt;p&gt;percentage of cells that are positive of CD19 in B cells and other cells:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pct.in&amp;lt;- mean(cluster_B_norm_data != 0)
pct.in&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; [1] 0.2157434&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pct.out&amp;lt;- mean(other_cluster_norm_data !=0)
pct.out&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; [1] 0.007407407&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The percentages are exactly the same as the &lt;code&gt;FindAllMarkers&lt;/code&gt; output&lt;/p&gt;
&lt;p&gt;If we use the the old formula which add 1 rather than a small value &lt;code&gt;1e^-9&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log2(mean(exp(cluster_B_norm_data)-1) + 1) -
        log2(mean(exp(other_cluster_norm_data)-1) + 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; [1] 1.241319&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The logFC is very different. The pseudo-count can have a large effect when the
counts are small.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;if-we-calculate-the-scanpy-way&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;If we calculate the Scanpy way&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# the natural log normalized counts for gene x from cluster 0
cluster_B_norm_data&amp;lt;- log_normalized_data[cluster_B_index]
        
# the natural log normalized counts for gene x from all other clusters
other_cluster_norm_data&amp;lt;- log_normalized_data[other_clusters_index]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;calculate the mean of the natural log normalized counts and then &lt;code&gt;exp&lt;/code&gt; it back&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log2(exp(mean(cluster_B_norm_data)) -1 + 10^-9) -
        log2(exp(mean(other_cluster_norm_data)) -1 + 10^-9)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; [1] 5.508951&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Scanpy&lt;/code&gt; version take the mean of the natural log noramlized the counts first,
then &lt;code&gt;exp&lt;/code&gt; back, minus 1, add a small number, then log2 transform. It does not
seems correct either&lt;/p&gt;
&lt;p&gt;However, the value is close to the updated Seurat version.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;lets-do-it-for-all-genes-in-the-b-cell-cluster&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Let‚Äôs do it for all genes in the B cell cluster&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seurat_log2FC&amp;lt;- function(method=&amp;quot;old&amp;quot;){
        # natural log library size normalized expression
        log_normalized_data&amp;lt;- pbmc3k@assays$RNA@data

        # a logical vector indicating the cells from cluster 0
        cluster_B_index&amp;lt;- pbmc3k$seurat_clusters == 3

        # negate it to get the cells from all other clusters
        other_clusters_index&amp;lt;- !cluster_B_index

        # the natural log normalized counts for gene x from cluster 3
        cluster_B_norm_data&amp;lt;- log_normalized_data[, cluster_B_index]
        
        # the natural log normalized counts for gene x from all other clusters
        other_cluster_norm_data&amp;lt;- log_normalized_data[,other_clusters_index]
        
        if (method == &amp;quot;new&amp;quot;){
               x&amp;lt;-  apply(cluster_B_norm_data, MARGIN =1,
                          function(x) log2(mean(exp(x)-1) + 10^-9)) 
               y&amp;lt;-  apply(other_cluster_norm_data, MARGIN =1,
                          function(x) log2(mean(exp(x)-1) +10^-9))
               return(x-y)
             
        } else if (method == &amp;quot;old&amp;quot;){
               x&amp;lt;-  apply(cluster_B_norm_data, MARGIN =1,
                          function(x) log2(mean(exp(x)-1) + 1)) 
               y&amp;lt;-  apply(other_cluster_norm_data, MARGIN =1,
                          function(x) log2(mean(exp(x)-1) + 1))
               return(x-y)
        }
}

scanpy_log2FC&amp;lt;- function(){
        # natural log library size normalized expression
        log_normalized_data&amp;lt;- pbmc3k@assays$RNA@data

        # a logical vector indicating the cells from cluster 0
        cluster_B_index&amp;lt;- pbmc3k$seurat_clusters == 3

        # negate it to get the cells from all other clusters
        other_clusters_index&amp;lt;- !cluster_B_index

        # the natural log normalized counts for gene x from cluster 3
        cluster_B_norm_data&amp;lt;- log_normalized_data[, cluster_B_index]
        
        # the natural log normalized counts for gene x from all other clusters
        other_cluster_norm_data&amp;lt;- log_normalized_data[,other_clusters_index]

        x&amp;lt;-  apply(cluster_B_norm_data, MARGIN =1,
                          function(x) log2(exp(mean(x)) -1 + 10^-9))
        
        y&amp;lt;-  apply(other_cluster_norm_data, MARGIN =1,
                          function(x) log2(exp(mean(x)) -1 + 10^-9))
        return(x-y)       
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calculate the Fold changes using the functions for all genes comparing cluster 3
versus all other clusters:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seurat_old_fold&amp;lt;- seurat_log2FC(method = &amp;quot;old&amp;quot;)

seurat_new_fold&amp;lt;- seurat_log2FC(method = &amp;quot;new&amp;quot;)

scanpy_fold&amp;lt;- scanpy_log2FC()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;put them into a single dataframe&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seurat_old_df&amp;lt;- tibble::enframe(seurat_old_fold, name = &amp;quot;gene&amp;quot;, value = &amp;quot;seurat_old&amp;quot;)
seurat_new_df&amp;lt;- tibble::enframe(seurat_new_fold, name = &amp;quot;gene&amp;quot;, value = &amp;quot;seurat_new&amp;quot;)
scanpy_df&amp;lt;- tibble::enframe(scanpy_fold, name = &amp;quot;gene&amp;quot;, value = &amp;quot;scanpy&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;plotting&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
fold_df&amp;lt;- purrr::reduce(list(seurat_old_df, seurat_new_df, scanpy_df ), inner_join)

p1&amp;lt;- ggplot(fold_df) +
        geom_point(aes(x=seurat_old, y = scanpy), size = 0.3, alpha = 0.5)+
        geom_abline(intercept = 0, slope = 1, linetype = 2, color = &amp;quot;red&amp;quot;) +
        coord_equal()


p2&amp;lt;- ggplot(fold_df) +
        geom_point(aes(x=seurat_new, y = scanpy), size = 0.3, alpha = 0.5) +
        geom_abline(intercept = 0, slope = 1, linetype = 2, color = &amp;quot;red&amp;quot;) +
        coord_equal() +
        theme_bw(base_size = 14)

p1 + p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-03-05-do-you-really-understand-log2fold-change-in-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The figure on the left recapitulates the discrepancy showed in the figure in the
beginning of the post. The updated calculation in &lt;code&gt;Seurat&lt;/code&gt; on the right is now
very similar to &lt;code&gt;scanpy&#39;s&lt;/code&gt; calculation.&lt;/p&gt;
&lt;p&gt;The updated Seurat formula:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(R_{g}=\log_{2}(\frac{1}{n_{1}}\sum_{i\in G_{1}}(exp(Y_{ig})-1)+\epsilon)-log_{2}(\frac{1}{n_{2}}\sum_{i\in G_{2}}(exp(Y_{ig})-1)+\epsilon),\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\epsilon=10^{-9}\)&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Conclusions&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Details matters. Do not blindly trust packages even they are established ones.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Small differences in treating the pseudo-counts can have big differences.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Single-cell is a field developing so fast that we do not have consensus on many things.
The &lt;code&gt;R&lt;/code&gt; world is split into &lt;code&gt;Seurat&lt;/code&gt; and &lt;code&gt;Bioconductor&lt;/code&gt; and the &lt;code&gt;python&lt;/code&gt; world is dominated
by the &lt;code&gt;scverse&lt;/code&gt;. We should encourage interactions between different communities to solve
common challenges.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;further-reading&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Further reading&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/bnprks/BPCells/issues/45&#34;&gt;Markers different in BPCells than in Seurat&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; ‚îÄ Session info  üòÉ  üñçÔ∏è  üèí   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#&amp;gt;  hash: grinning face with big eyes, crayon, ice hockey
#&amp;gt; 
#&amp;gt;  setting  value
#&amp;gt;  version  R version 4.1.2 (2021-11-01)
#&amp;gt;  os       macOS Big Sur 10.16
#&amp;gt;  system   x86_64, darwin17.0
#&amp;gt;  ui       X11
#&amp;gt;  language (EN)
#&amp;gt;  collate  en_US.UTF-8
#&amp;gt;  ctype    en_US.UTF-8
#&amp;gt;  tz       America/New_York
#&amp;gt;  date     2024-03-07
#&amp;gt;  pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)
#&amp;gt; 
#&amp;gt; ‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#&amp;gt;  package            * version    date (UTC) lib source
#&amp;gt;  abind                1.4-5      2016-07-21 [1] CRAN (R 4.1.0)
#&amp;gt;  beeswarm             0.4.0      2021-06-01 [1] CRAN (R 4.1.0)
#&amp;gt;  blogdown             1.7        2021-12-19 [1] CRAN (R 4.1.2)
#&amp;gt;  bookdown             0.24       2021-09-02 [1] CRAN (R 4.1.0)
#&amp;gt;  bslib                0.3.1      2021-10-06 [1] CRAN (R 4.1.0)
#&amp;gt;  cachem               1.0.6      2021-08-19 [1] CRAN (R 4.1.0)
#&amp;gt;  callr                3.7.0      2021-04-20 [1] CRAN (R 4.1.0)
#&amp;gt;  circlize             0.4.13     2021-06-09 [1] CRAN (R 4.1.0)
#&amp;gt;  cli                  3.6.1      2023-03-23 [1] CRAN (R 4.1.2)
#&amp;gt;  cluster              2.1.2      2021-04-17 [1] CRAN (R 4.1.2)
#&amp;gt;  codetools            0.2-18     2020-11-04 [1] CRAN (R 4.1.2)
#&amp;gt;  colorspace           2.0-2      2021-06-24 [1] CRAN (R 4.1.0)
#&amp;gt;  cowplot              1.1.1      2020-12-30 [1] CRAN (R 4.1.0)
#&amp;gt;  crayon               1.4.2      2021-10-29 [1] CRAN (R 4.1.0)
#&amp;gt;  data.table           1.14.2     2021-09-27 [1] CRAN (R 4.1.0)
#&amp;gt;  DBI                  1.1.1      2021-01-15 [1] CRAN (R 4.1.0)
#&amp;gt;  deldir               1.0-6      2021-10-23 [1] CRAN (R 4.1.0)
#&amp;gt;  desc                 1.4.0      2021-09-28 [1] CRAN (R 4.1.0)
#&amp;gt;  devtools             2.4.2      2021-06-07 [1] CRAN (R 4.1.0)
#&amp;gt;  digest               0.6.28     2021-09-23 [1] CRAN (R 4.1.0)
#&amp;gt;  dotCall64            1.1-1      2023-11-28 [1] CRAN (R 4.1.2)
#&amp;gt;  dplyr              * 1.1.2      2023-04-20 [1] CRAN (R 4.1.2)
#&amp;gt;  ellipsis             0.3.2      2021-04-29 [1] CRAN (R 4.1.0)
#&amp;gt;  evaluate             0.14       2019-05-28 [1] CRAN (R 4.1.0)
#&amp;gt;  fansi                0.5.0      2021-05-25 [1] CRAN (R 4.1.0)
#&amp;gt;  farver               2.1.0      2021-02-28 [1] CRAN (R 4.1.0)
#&amp;gt;  fastDummies          1.7.3      2023-07-06 [1] CRAN (R 4.1.2)
#&amp;gt;  fastmap              1.1.0      2021-01-25 [1] CRAN (R 4.1.0)
#&amp;gt;  fitdistrplus         1.1-6      2021-09-28 [1] CRAN (R 4.1.0)
#&amp;gt;  forcats              0.5.1      2021-01-27 [1] CRAN (R 4.1.0)
#&amp;gt;  fs                   1.5.0      2020-07-31 [1] CRAN (R 4.1.0)
#&amp;gt;  future               1.25.0     2022-04-24 [1] CRAN (R 4.1.2)
#&amp;gt;  future.apply         1.8.1      2021-08-10 [1] CRAN (R 4.1.0)
#&amp;gt;  generics             0.1.3      2022-07-05 [1] CRAN (R 4.1.2)
#&amp;gt;  ggbeeswarm           0.6.0      2017-08-07 [1] CRAN (R 4.1.0)
#&amp;gt;  ggplot2            * 3.4.4      2023-10-12 [1] CRAN (R 4.1.2)
#&amp;gt;  ggprism              1.0.3.9000 2021-12-07 [1] Github (csdaw/ggprism@e21c3ee)
#&amp;gt;  ggrastr              1.0.1      2021-12-08 [1] CRAN (R 4.1.0)
#&amp;gt;  ggrepel              0.9.3      2023-02-03 [1] CRAN (R 4.1.2)
#&amp;gt;  ggridges             0.5.4      2022-09-26 [1] CRAN (R 4.1.2)
#&amp;gt;  GlobalOptions        0.1.2      2020-06-10 [1] CRAN (R 4.1.0)
#&amp;gt;  globals              0.14.0     2020-11-22 [1] CRAN (R 4.1.0)
#&amp;gt;  glue                 1.6.2      2022-02-24 [1] CRAN (R 4.1.2)
#&amp;gt;  goftest              1.2-3      2021-10-07 [1] CRAN (R 4.1.0)
#&amp;gt;  gridExtra            2.3        2017-09-09 [1] CRAN (R 4.1.0)
#&amp;gt;  gtable               0.3.0      2019-03-25 [1] CRAN (R 4.1.0)
#&amp;gt;  highr                0.9        2021-04-16 [1] CRAN (R 4.1.0)
#&amp;gt;  htmltools            0.5.2      2021-08-25 [1] CRAN (R 4.1.0)
#&amp;gt;  htmlwidgets          1.5.4      2021-09-08 [1] CRAN (R 4.1.0)
#&amp;gt;  httpuv               1.6.3      2021-09-09 [1] CRAN (R 4.1.0)
#&amp;gt;  httr                 1.4.2      2020-07-20 [1] CRAN (R 4.1.0)
#&amp;gt;  ica                  1.0-2      2018-05-24 [1] CRAN (R 4.1.0)
#&amp;gt;  ifnb.SeuratData    * 3.1.0      2024-01-17 [1] local
#&amp;gt;  igraph               1.2.7      2021-10-15 [1] CRAN (R 4.1.0)
#&amp;gt;  irlba                2.3.5.1    2022-10-03 [1] CRAN (R 4.1.2)
#&amp;gt;  janitor              2.1.0      2021-01-05 [1] CRAN (R 4.1.0)
#&amp;gt;  jquerylib            0.1.4      2021-04-26 [1] CRAN (R 4.1.0)
#&amp;gt;  jsonlite             1.7.2      2020-12-09 [1] CRAN (R 4.1.0)
#&amp;gt;  KernSmooth           2.23-20    2021-05-03 [1] CRAN (R 4.1.2)
#&amp;gt;  knitr                1.36       2021-09-29 [1] CRAN (R 4.1.0)
#&amp;gt;  labeling             0.4.2      2020-10-20 [1] CRAN (R 4.1.0)
#&amp;gt;  later                1.3.0      2021-08-18 [1] CRAN (R 4.1.0)
#&amp;gt;  lattice              0.20-45    2021-09-22 [1] CRAN (R 4.1.2)
#&amp;gt;  lazyeval             0.2.2      2019-03-15 [1] CRAN (R 4.1.0)
#&amp;gt;  leiden               0.3.9      2021-07-27 [1] CRAN (R 4.1.0)
#&amp;gt;  lifecycle            1.0.3      2022-10-07 [1] CRAN (R 4.1.2)
#&amp;gt;  limma                3.50.0     2021-10-26 [1] Bioconductor
#&amp;gt;  listenv              0.8.0      2019-12-05 [1] CRAN (R 4.1.0)
#&amp;gt;  lmtest               0.9-39     2021-11-07 [1] CRAN (R 4.1.0)
#&amp;gt;  lubridate            1.8.0      2021-10-07 [1] CRAN (R 4.1.0)
#&amp;gt;  magrittr             2.0.1      2020-11-17 [1] CRAN (R 4.1.0)
#&amp;gt;  MASS                 7.3-54     2021-05-03 [1] CRAN (R 4.1.2)
#&amp;gt;  Matrix               1.6-3      2023-11-14 [1] CRAN (R 4.1.2)
#&amp;gt;  matrixStats          0.61.0     2021-09-17 [1] CRAN (R 4.1.0)
#&amp;gt;  memoise              2.0.0      2021-01-26 [1] CRAN (R 4.1.0)
#&amp;gt;  mime                 0.12       2021-09-28 [1] CRAN (R 4.1.0)
#&amp;gt;  miniUI               0.1.1.1    2018-05-18 [1] CRAN (R 4.1.0)
#&amp;gt;  munsell              0.5.0      2018-06-12 [1] CRAN (R 4.1.0)
#&amp;gt;  nlme                 3.1-153    2021-09-07 [1] CRAN (R 4.1.2)
#&amp;gt;  paletteer            1.4.0      2021-07-20 [1] CRAN (R 4.1.0)
#&amp;gt;  parallelly           1.31.1     2022-04-22 [1] CRAN (R 4.1.2)
#&amp;gt;  patchwork            1.1.1      2020-12-17 [1] CRAN (R 4.1.0)
#&amp;gt;  pbapply              1.5-0      2021-09-16 [1] CRAN (R 4.1.0)
#&amp;gt;  pbmc3k.SeuratData  * 3.1.4      2022-08-03 [1] local
#&amp;gt;  pbmcref.SeuratData * 1.0.0      2023-09-14 [1] local
#&amp;gt;  pillar               1.9.0      2023-03-22 [1] CRAN (R 4.1.2)
#&amp;gt;  pkgbuild             1.2.0      2020-12-15 [1] CRAN (R 4.1.0)
#&amp;gt;  pkgconfig            2.0.3      2019-09-22 [1] CRAN (R 4.1.0)
#&amp;gt;  pkgload              1.2.3      2021-10-13 [1] CRAN (R 4.1.0)
#&amp;gt;  plotly               4.10.0     2021-10-09 [1] CRAN (R 4.1.0)
#&amp;gt;  plyr                 1.8.6      2020-03-03 [1] CRAN (R 4.1.0)
#&amp;gt;  png                  0.1-8      2022-11-29 [1] CRAN (R 4.1.2)
#&amp;gt;  polyclip             1.10-0     2019-03-14 [1] CRAN (R 4.1.0)
#&amp;gt;  presto               1.0.0      2023-03-30 [1] Github (immunogenomics/presto@045390a)
#&amp;gt;  prettyunits          1.1.1      2020-01-24 [1] CRAN (R 4.1.0)
#&amp;gt;  prismatic            1.1.0      2021-10-17 [1] CRAN (R 4.1.0)
#&amp;gt;  processx             3.5.2      2021-04-30 [1] CRAN (R 4.1.0)
#&amp;gt;  progressr            0.9.0      2021-09-24 [1] CRAN (R 4.1.0)
#&amp;gt;  promises             1.2.0.1    2021-02-11 [1] CRAN (R 4.1.0)
#&amp;gt;  ps                   1.6.0      2021-02-28 [1] CRAN (R 4.1.0)
#&amp;gt;  purrr                1.0.1      2023-01-10 [1] CRAN (R 4.1.2)
#&amp;gt;  R6                   2.5.1      2021-08-19 [1] CRAN (R 4.1.0)
#&amp;gt;  RANN                 2.6.1      2019-01-08 [1] CRAN (R 4.1.0)
#&amp;gt;  rappdirs             0.3.3      2021-01-31 [1] CRAN (R 4.1.0)
#&amp;gt;  RColorBrewer         1.1-2      2014-12-07 [1] CRAN (R 4.1.0)
#&amp;gt;  Rcpp                 1.0.11     2023-07-06 [1] CRAN (R 4.1.2)
#&amp;gt;  RcppAnnoy            0.0.19     2021-07-30 [1] CRAN (R 4.1.0)
#&amp;gt;  RcppHNSW             0.3.0      2020-09-06 [1] CRAN (R 4.1.0)
#&amp;gt;  rematch2             2.1.2      2020-05-01 [1] CRAN (R 4.1.0)
#&amp;gt;  remotes              2.4.1      2021-09-29 [1] CRAN (R 4.1.0)
#&amp;gt;  reshape2             1.4.4      2020-04-09 [1] CRAN (R 4.1.0)
#&amp;gt;  reticulate           1.28       2023-01-27 [1] CRAN (R 4.1.2)
#&amp;gt;  rlang                1.1.3      2024-01-10 [1] CRAN (R 4.1.2)
#&amp;gt;  rmarkdown            2.11       2021-09-14 [1] CRAN (R 4.1.0)
#&amp;gt;  ROCR                 1.0-11     2020-05-02 [1] CRAN (R 4.1.0)
#&amp;gt;  rprojroot            2.0.2      2020-11-15 [1] CRAN (R 4.1.0)
#&amp;gt;  RSpectra             0.16-0     2019-12-01 [1] CRAN (R 4.1.0)
#&amp;gt;  rstudioapi           0.13       2020-11-12 [1] CRAN (R 4.1.0)
#&amp;gt;  Rtsne                0.15       2018-11-10 [1] CRAN (R 4.1.0)
#&amp;gt;  sass                 0.4.0      2021-05-12 [1] CRAN (R 4.1.0)
#&amp;gt;  scales               1.3.0      2023-11-28 [1] CRAN (R 4.1.2)
#&amp;gt;  scattermore          1.2        2023-06-12 [1] CRAN (R 4.1.2)
#&amp;gt;  scCustomize        * 2.1.2      2024-02-28 [1] CRAN (R 4.1.2)
#&amp;gt;  sctransform          0.4.1      2023-10-19 [1] CRAN (R 4.1.2)
#&amp;gt;  sessioninfo          1.2.1      2021-11-02 [1] CRAN (R 4.1.0)
#&amp;gt;  Seurat             * 5.0.1      2023-11-17 [1] CRAN (R 4.1.2)
#&amp;gt;  SeuratData         * 0.2.2      2022-08-03 [1] Github (satijalab/seurat-data@d6a8ce6)
#&amp;gt;  SeuratObject       * 5.0.1      2023-11-17 [1] CRAN (R 4.1.2)
#&amp;gt;  shape                1.4.6      2021-05-19 [1] CRAN (R 4.1.0)
#&amp;gt;  shiny                1.7.1      2021-10-02 [1] CRAN (R 4.1.0)
#&amp;gt;  snakecase            0.11.0     2019-05-25 [1] CRAN (R 4.1.0)
#&amp;gt;  sp                 * 1.6-0      2023-01-19 [1] CRAN (R 4.1.2)
#&amp;gt;  spam                 2.10-0     2023-10-23 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.data        3.0-0      2022-10-21 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.explore     3.0-6      2023-01-26 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.geom        3.0-6      2023-01-30 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.random      3.1-3      2023-01-25 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.sparse      3.0-0      2022-10-21 [1] CRAN (R 4.1.2)
#&amp;gt;  spatstat.utils       3.0-1      2022-10-19 [1] CRAN (R 4.1.2)
#&amp;gt;  stringi              1.7.5      2021-10-04 [1] CRAN (R 4.1.0)
#&amp;gt;  stringr              1.5.1      2023-11-14 [1] CRAN (R 4.1.2)
#&amp;gt;  survival             3.2-13     2021-08-24 [1] CRAN (R 4.1.2)
#&amp;gt;  tensor               1.5        2012-05-05 [1] CRAN (R 4.1.0)
#&amp;gt;  testthat             3.1.0      2021-10-04 [1] CRAN (R 4.1.0)
#&amp;gt;  tibble               3.2.1      2023-03-20 [1] CRAN (R 4.1.2)
#&amp;gt;  tidyr                1.3.0      2023-01-24 [1] CRAN (R 4.1.2)
#&amp;gt;  tidyselect           1.2.0      2022-10-10 [1] CRAN (R 4.1.2)
#&amp;gt;  usethis              2.1.3      2021-10-27 [1] CRAN (R 4.1.0)
#&amp;gt;  utf8                 1.2.2      2021-07-24 [1] CRAN (R 4.1.0)
#&amp;gt;  uwot                 0.1.14     2022-08-22 [1] CRAN (R 4.1.2)
#&amp;gt;  vctrs                0.6.2      2023-04-19 [1] CRAN (R 4.1.2)
#&amp;gt;  vipor                0.4.5      2017-03-22 [1] CRAN (R 4.1.0)
#&amp;gt;  viridisLite          0.4.0      2021-04-13 [1] CRAN (R 4.1.0)
#&amp;gt;  withr                2.5.0      2022-03-03 [1] CRAN (R 4.1.2)
#&amp;gt;  xfun                 0.36       2022-12-21 [1] CRAN (R 4.1.2)
#&amp;gt;  xtable               1.8-4      2019-04-21 [1] CRAN (R 4.1.0)
#&amp;gt;  yaml                 2.2.1      2020-02-01 [1] CRAN (R 4.1.0)
#&amp;gt;  zoo                  1.8-9      2021-03-09 [1] CRAN (R 4.1.0)
#&amp;gt; 
#&amp;gt;  [1] /Library/Frameworks/R.framework/Versions/4.1/Resources/library
#&amp;gt; 
#&amp;gt; ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Hidden skills beyond programming for computational biology</title>
      <link>/post/hidden-skills-beyond-programming-for-computational-biology/</link>
      <pubDate>Fri, 23 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/hidden-skills-beyond-programming-for-computational-biology/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/vembedr/css/vembedr.css&#34; rel=&#34;stylesheet&#34; /&gt;


&lt;p&gt;There are some hidden gems beyond the typical programming skills that have been instrumental in my journey. These are the often-overlooked yet crucial practices that have empowered me to tackle challenges and make sense of data in meaningful ways.&lt;/p&gt;
&lt;p&gt;Firstly, let‚Äôs talk about patience. It‚Äôs not as glamorous as diving straight into analysis, but taking the time for thorough quality control is invaluable. Before you get carried away, understand the experimental design. If you‚Äôre working with published data, don‚Äôt just import it and run ‚Äì delve into the paper, grasp the nuances. This initial investment sets you up for a much smoother, more productive ride later.&lt;/p&gt;
&lt;p&gt;Next, let‚Äôs embrace the power of exploration data analysis or (EDA). Don‚Äôt just trust the data blindly. Look at it with a curious eye, searching for patterns and potential issues. Print it out the lines and see them with you eyes, check for missing values, utilize principal component analysis ‚Äì whatever helps you identify anomalies and get a feel for the data‚Äôs story.&lt;/p&gt;
&lt;p&gt;Sanity checks are your guardians against errors and inconsistencies. They‚Äôre like detective work for your data. Be vigilant for outliers, missing values, and patterns that seem out of place. Compare your results to positive and negative controls (like wet experimentalists), and most importantly, ensure they align with what you know about biology. Remember, data analysis is not just about crunching numbers; it‚Äôs about drawing meaningful biological insights.&lt;/p&gt;
&lt;p&gt;Finally, independent thinking is your secret weapon. Don‚Äôt be afraid to step outside the script of tutorials. Ask yourself if the method you‚Äôre using truly aligns with your question and data. Be prepared to adapt, modify, and even invent new approaches as needed. Remember, the tools are just that ‚Äì tools. It‚Äôs your critical thinking and ability to approach data creatively that will set you apart.&lt;/p&gt;
&lt;p&gt;By incorporating these hidden skills into your bioinformatics toolbox, you‚Äôll be well on your way to not only wielding the latest techniques but also wielding them thoughtfully and effectively.&lt;/p&gt;
&lt;p&gt;Remember, it‚Äôs not just about the how, but also about the why and the how else. So, stay curious, question assumptions, and above all, have fun exploring the fascinating world of bioinformatics!&lt;/p&gt;
&lt;p&gt;Watch the full video here:&lt;/p&gt;
&lt;div class=&#34;vembedr&#34;&gt;
&lt;div&gt;
&lt;iframe src=&#34;https://www.youtube.com/embed/1TajTK2VViI&#34; width=&#34;533&#34; height=&#34;300&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;&#34; data-external=&#34;1&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A community challenge to predict clinical outcomes after immune checkpoint blockade in non-small cell lung cancer</title>
      <link>/publication/2024-02-21-immune-prediction/</link>
      <pubDate>Wed, 21 Feb 2024 00:00:00 -0500</pubDate>
      
      <guid>/publication/2024-02-21-immune-prediction/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Single-cell RNAseq data integration: methods and challenges</title>
      <link>/talk/2024-pythia/</link>
      <pubDate>Wed, 24 Jan 2024 11:00:00 -0500</pubDate>
      
      <guid>/talk/2024-pythia/</guid>
      <description>&lt;p&gt;Say hi to 2024 with the first webinar in our &amp;ldquo;Omics Connect&amp;rdquo; series!&lt;/p&gt;

&lt;p&gt;Integration of data from different experimental batches is one of the most crucial yet challenging steps in single-cell data analysis workflows. In this webinar, we are honored to invite Dr. üéØ Ming &amp;ldquo;Tommy&amp;rdquo; Tang, Director of Computational Biology at Immunitas Therapeutics, to discuss the latest methods and challenges of single-cell RNA-seq integration.&lt;/p&gt;

&lt;p&gt;You will also learn from Jenny Pham, Head of Scientific Marketing and Training Programs at Pythia Biosciences, about the single-cell analysis workflows supported in Pythia&amp;rsquo;s CDIAM Multi-Omics Platform through which you can integrate scRNA-seq data with other types of omics for aggregate insights.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/pythia.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to make a multi-group dotplot for single-cell RNAseq data</title>
      <link>/post/how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data/</link>
      <pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;Dotplots are very popular for visualizing single-cell RNAseq data. In essence,
the dot size represents the percentage of cells that are positive for that gene;
the color intensity represents the average gene expression of that gene in a
cell type.&lt;/p&gt;
&lt;p&gt;It is easy to plot one using &lt;code&gt;Seurat::dotplot&lt;/code&gt; or &lt;code&gt;Sccustomize::clustered_dotplot&lt;/code&gt;.
However, when you have multiple groups/conditions in your data and you want to
visualize it by groups, it is not that straightforward.&lt;/p&gt;
&lt;p&gt;However, if you understand that the underlying data are just the percentages of
positive cells and the average expression values and the dotplot is essentially
just a heatmap, you can write R code to visualize the data in anyway you want.&lt;/p&gt;
&lt;p&gt;Let‚Äôs use this data from &lt;a href=&#34;https://satijalab.org/seurat/articles/integration_introduction&#34; class=&#34;uri&#34;&gt;https://satijalab.org/seurat/articles/integration_introduction&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The object contains data from human PBMC from two conditions, interferon-stimulated and control cells (stored in the stim column in the object metadata). We will aim to integrate the two conditions together, so that we can jointly identify cell subpopulations across datasets, and then explore how each group differs across conditions&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)
library(SeuratData)
library(patchwork)
library(harmony)
library(dplyr)
# install dataset
InstallData(&amp;quot;ifnb&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# load dataset
ifnb &amp;lt;- LoadData(&amp;quot;ifnb&amp;quot;)
ifnb&amp;lt;- UpdateSeuratObject(ifnb)

ifnb&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; An object of class Seurat 
#&amp;gt; 14053 features across 13999 samples within 1 assay 
#&amp;gt; Active assay: RNA (14053 features, 0 variable features)
#&amp;gt;  2 layers present: counts, data&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two conditions: control and stimulated.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(ifnb$stim)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; 
#&amp;gt; CTRL STIM 
#&amp;gt; 6548 7451&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;routine processing&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ifnb&amp;lt;- ifnb %&amp;gt;%
  NormalizeData(normalization.method = &amp;quot;LogNormalize&amp;quot;, scale.factor = 10000) %&amp;gt;%
  FindVariableFeatures( selection.method = &amp;quot;vst&amp;quot;, nfeatures = 2000) %&amp;gt;%
  ScaleData() %&amp;gt;%
  RunPCA() %&amp;gt;%
  RunHarmony(group.by.vars = &amp;quot;stim&amp;quot;, dims.use = 1:30) %&amp;gt;%
  RunUMAP(reduction = &amp;quot;harmony&amp;quot;, dims = 1:30) %&amp;gt;%
  FindNeighbors(reduction = &amp;quot;harmony&amp;quot;, dims = 1:30) %&amp;gt;% 
  FindClusters(resolution = 0.6)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt; Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck
#&amp;gt; 
#&amp;gt; Number of nodes: 13999
#&amp;gt; Number of edges: 519190
#&amp;gt; 
#&amp;gt; Running Louvain algorithm...
#&amp;gt; Maximum modularity in 10 random starts: 0.8855
#&amp;gt; Number of communities: 14
#&amp;gt; Elapsed time: 2 seconds&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs take a look at the UMAP:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Visualization
DimPlot(ifnb, reduction = &amp;quot;umap&amp;quot;, group.by = c(&amp;quot;stim&amp;quot;, &amp;quot;seurat_annotations&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-01-16-how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Let‚Äôs make a dotplot using &lt;code&gt;Seurat&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Idents(ifnb)&amp;lt;- ifnb$seurat_annotations
# NEEDS TO BE FIXED AND SET ORDER CORRECTLY
Idents(ifnb) &amp;lt;- factor(Idents(ifnb), 
                       levels = c(&amp;quot;pDC&amp;quot;, &amp;quot;Eryth&amp;quot;, &amp;quot;Mk&amp;quot;, &amp;quot;DC&amp;quot;, 
                                                &amp;quot;CD14 Mono&amp;quot;, &amp;quot;CD16 Mono&amp;quot;,&amp;quot;B Activated&amp;quot;, 
                                                &amp;quot;B&amp;quot;, &amp;quot;CD8 T&amp;quot;, &amp;quot;NK&amp;quot;, &amp;quot;T activated&amp;quot;, 
                                                &amp;quot;CD4 Naive T&amp;quot;, &amp;quot;CD4 Memory T&amp;quot;))

markers.to.plot &amp;lt;- c(&amp;quot;CD3D&amp;quot;, &amp;quot;CREM&amp;quot;, &amp;quot;HSPH1&amp;quot;, &amp;quot;SELL&amp;quot;, &amp;quot;GIMAP5&amp;quot;, &amp;quot;CACYBP&amp;quot;, &amp;quot;GNLY&amp;quot;, 
                     &amp;quot;NKG7&amp;quot;, &amp;quot;CCL5&amp;quot;, &amp;quot;CD8A&amp;quot;, &amp;quot;MS4A1&amp;quot;, &amp;quot;CD79A&amp;quot;, &amp;quot;MIR155HG&amp;quot;, &amp;quot;NME1&amp;quot;, 
                     &amp;quot;FCGR3A&amp;quot;, &amp;quot;VMO1&amp;quot;, &amp;quot;CCL2&amp;quot;, &amp;quot;S100A9&amp;quot;, &amp;quot;HLA-DQA1&amp;quot;, &amp;quot;GPR183&amp;quot;, 
                     &amp;quot;PPBP&amp;quot;, &amp;quot;GNG11&amp;quot;, &amp;quot;HBA2&amp;quot;, &amp;quot;HBB&amp;quot;, &amp;quot;TSPAN13&amp;quot;, &amp;quot;IL3RA&amp;quot;, &amp;quot;IGJ&amp;quot;, 
                     &amp;quot;PRSS57&amp;quot;)

DotPlot(ifnb, features = markers.to.plot, cols = c(&amp;quot;blue&amp;quot;, &amp;quot;red&amp;quot;), 
        dot.scale = 8, split.by = &amp;quot;stim&amp;quot;) +
        RotatedAxis()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-01-16-how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can also use &lt;a href=&#34;https://samuel-marsh.github.io/scCustomize/articles/Gene_Expression_Plotting.html&#34;&gt;&lt;code&gt;scCusstomize&lt;/code&gt;&lt;/a&gt; to cluster the dotplots, but you can not split by condition.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;scCustomize::Clustered_DotPlot(ifnb, features = markers.to.plot,
                               plot_km_elbow = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-01-16-how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You can rotate the x and y axis:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;scCustomize::Clustered_DotPlot(ifnb, features = markers.to.plot,
                               plot_km_elbow = FALSE, flip = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-01-16-how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;What if I want to split the dotplot by the condition?&lt;/p&gt;
&lt;div id=&#34;customized-multi-group-dotplot&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Customized multi-group dotplot&lt;/h3&gt;
&lt;p&gt;We need to get the percentage of positive cells and average expression by group.&lt;/p&gt;
&lt;p&gt;For a single gene, put the groups into multiple rows, and each column is a
cell type.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# group1 is the cell type/cluster annotation 
# group2 is any condition you want to further group, in this case, the stim 

GetMatrixFromSeuratByGroupSingle&amp;lt;- function(obj, feature, group1, group2){
  if (length(feature) != 1){
          stop(&amp;quot;please only provide only one gene name&amp;quot;)
  }
  exp_mat&amp;lt;- obj@assays$RNA@data[feature, ,drop=FALSE]
  count_mat&amp;lt;- obj@assays$RNA@counts[feature,,drop=FALSE ]
  
  meta&amp;lt;- obj@meta.data %&amp;gt;%
  tibble::rownames_to_column(var = &amp;quot;cell&amp;quot;)
        
  # get the average expression matrix
  exp_df&amp;lt;- as.matrix(exp_mat) %&amp;gt;% 
    as.data.frame() %&amp;gt;% 
    tibble::rownames_to_column(var=&amp;quot;gene&amp;quot;) %&amp;gt;%
    tidyr::pivot_longer(!gene, names_to = &amp;quot;cell&amp;quot;, values_to = &amp;quot;expression&amp;quot;) %&amp;gt;%
    left_join(meta) %&amp;gt;%
    group_by(gene,{{group1}}, {{group2}}) %&amp;gt;%
    summarise(average_expression = mean(expression)) %&amp;gt;%
    tidyr::pivot_wider(names_from = {{group1}}, 
                       values_from= average_expression) 
  
  exp_mat&amp;lt;- exp_df[, -c(1,2)] %&amp;gt;% as.matrix()
  rownames(exp_mat)&amp;lt;- exp_df %&amp;gt;% pull({{group2}})
  
  # get the percentage positive cell matrix
  count_df&amp;lt;- as.matrix(count_mat) %&amp;gt;% 
    as.data.frame() %&amp;gt;% 
    tibble::rownames_to_column(var=&amp;quot;gene&amp;quot;) %&amp;gt;%
    tidyr::pivot_longer(!gene, names_to = &amp;quot;cell&amp;quot;, values_to = &amp;quot;count&amp;quot;) %&amp;gt;%
    left_join(meta) %&amp;gt;%
    group_by(gene, {{group1}}, {{group2}}) %&amp;gt;%
    summarise(percentage = mean(count &amp;gt;0)) %&amp;gt;%
    tidyr::pivot_wider(names_from = {{group1}}, 
                       values_from= percentage) 

  percent_mat&amp;lt;- count_df[, -c(1,2)] %&amp;gt;% as.matrix()
  rownames(percent_mat)&amp;lt;- count_df %&amp;gt;% pull({{group2}})
  
  if (!identical(dim(exp_mat), dim(percent_mat))) {
    stop(&amp;quot;the dimension of the two matrice should be the same!&amp;quot;)
  }
  
  if(! all.equal(colnames(exp_mat), colnames(percent_mat))) {
    stop(&amp;quot;column names of the two matrice should be the same!&amp;quot;)
  }
  
  if(! all.equal(rownames(exp_mat), rownames(percent_mat))) {
    stop(&amp;quot;column names of the two matrice should be the same!&amp;quot;)
  }
  return(list(exp_mat = exp_mat, percent_mat = percent_mat))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs get the matrices for one gene&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mat&amp;lt;- GetMatrixFromSeuratByGroupSingle(obj= ifnb, 
                                 feature = &amp;quot;ISG15&amp;quot;, 
                                 seurat_annotations,
                                 stim)

# take a look at the matrices
mat$exp_mat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;      CD14 Mono CD4 Naive T CD4 Memory T CD16 Mono         B     CD8 T
#&amp;gt; CTRL 0.7261719   0.3808203    0.4733928  1.117586 0.5495651 0.7284956
#&amp;gt; STIM 6.0702937   3.8087751    4.0137093  5.712665 4.3502870 4.0260494
#&amp;gt;      T activated        NK        DC B Activated        Mk       pDC     Eryth
#&amp;gt; CTRL   0.8074327 0.7889602 0.6561191   0.3800281 0.5941432 0.4085024 0.2929348
#&amp;gt; STIM   4.1129324 4.5385409 5.7027258   4.0121762 4.0114610 4.5247511 3.9331893&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mat$percent_mat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;      CD14 Mono CD4 Naive T CD4 Memory T CD16 Mono         B     CD8 T
#&amp;gt; CTRL  0.323702   0.1666667    0.2072177  0.495069 0.2334152 0.3011364
#&amp;gt; STIM  1.000000   0.9927916    0.9900332  1.000000 0.9982487 0.9891775
#&amp;gt;      T activated        NK        DC B Activated        Mk       pDC    Eryth
#&amp;gt; CTRL   0.3233333 0.3154362 0.3527132   0.1891892 0.2608696 0.2156863 0.173913
#&amp;gt; STIM   0.9759760 0.9875389 1.0000000   1.0000000 0.9752066 1.0000000 1.000000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two matrices:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;the average expression for each cell type per condition&lt;/li&gt;
&lt;li&gt;the percentage of ISG15 positive cells for each cell type per condition&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, Let‚Äôs visualize it using &lt;code&gt;ComplexHeatmap&lt;/code&gt;. See my &lt;a href=&#34;https://divingintogeneticsandgenomics.com/post/clustered-dotplot-for-single-cell-rnaseq/&#34;&gt;previous post&lt;/a&gt; too.&lt;/p&gt;
&lt;p&gt;Always explore the data range before you decide how to map the data values to
colors.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ComplexHeatmap)

quantile(mat$exp_mat, c(0.1, 0.5, 0.8, 0.9))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;       10%       50%       80%       90% 
#&amp;gt; 0.3946614 2.4631808 4.3502870 5.1206334&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;col_fun&amp;lt;-  circlize::colorRamp2(c(0, 2, 5), c(&amp;quot;#FDE725FF&amp;quot;, &amp;quot;#238A8DFF&amp;quot;, &amp;quot;#440154FF&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt; will be mapped to &lt;code&gt;#FDE725FF&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; will be mapped to &lt;code&gt;#238A8DFF&lt;/code&gt; and
&lt;code&gt;5&lt;/code&gt; will be mapped to &lt;code&gt;#440154FF&lt;/code&gt;. The value in-between will be linearlly
interpolated to get corresponding colors&lt;/p&gt;
&lt;p&gt;Use the &lt;code&gt;layer_fun&lt;/code&gt; to decide the size of the dots. Within the &lt;code&gt;grid.circle&lt;/code&gt;,
we specify the radius &lt;code&gt;r= sqrt(pindex(mat$percent_mat, i, j))&lt;/code&gt; of the circle to
be the square root of the percentage, so the area size of the dots correspond to
the percentage.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;layer_fun = function(j, i, x, y, w, h, fill){
    grid.rect(x = x, y = y, width = w, height = h, 
              gp = gpar(col = &amp;quot;gray&amp;quot;, fill = NA))
    grid.circle(x=x,y=y,r= sqrt(pindex(mat$percent_mat, i, j)) * unit(4, &amp;quot;mm&amp;quot;),
                gp = gpar(fill = col_fun(pindex(mat$exp_mat, i, j)), col = NA))}
  
hp&amp;lt;- Heatmap(mat$exp_mat,
             heatmap_legend_param=list(title= &amp;quot;expression&amp;quot;),
             column_title = &amp;quot;ISG15&amp;quot;, 
             col=col_fun,
             rect_gp = gpar(type = &amp;quot;none&amp;quot;),
             layer_fun = layer_fun,
             row_names_gp = gpar(fontsize = 8),
             border = &amp;quot;black&amp;quot;,
             cluster_rows = FALSE, 
             cluster_columns = FALSE,
             row_names_side  = &amp;quot;left&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;make the legend for the dot size. Make sure the size is the same as the in the
&lt;code&gt;layer_fun&lt;/code&gt; which is &lt;code&gt;unit(4, &#34;mm&#34;)&lt;/code&gt;. You can change the size as you want.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lgd_list = list(
    Legend( labels = c(0, 10, 25, 50, 75), title = &amp;quot;percentage&amp;quot;,
            graphics = list(
              function(x, y, w, h) grid.circle(x = x, y = y, r = 0  * unit(4, &amp;quot;mm&amp;quot;),
                                               gp = gpar(fill = &amp;quot;black&amp;quot;)),
              function(x, y, w, h) grid.circle(x = x, y = y, r = sqrt(0.1)  * unit(4, &amp;quot;mm&amp;quot;),
                                               gp = gpar(fill = &amp;quot;black&amp;quot;)),
              function(x, y, w, h) grid.circle(x = x, y = y, r = sqrt(0.25) * unit(4, &amp;quot;mm&amp;quot;),
                                               gp = gpar(fill = &amp;quot;black&amp;quot;)),
              function(x, y, w, h) grid.circle(x = x, y = y, r = sqrt(0.5) * unit(4, &amp;quot;mm&amp;quot;),
                                               gp = gpar(fill = &amp;quot;black&amp;quot;)),
              function(x, y, w, h) grid.circle(x = x, y = y, r = sqrt(0.75) * unit(4, &amp;quot;mm&amp;quot;),
                                               gp = gpar(fill = &amp;quot;black&amp;quot;))),
            row_gap = unit(2.5, &amp;quot;mm&amp;quot;)
            ))

draw(hp, annotation_legend_list = lgd_list, ht_gap = unit(1, &amp;quot;cm&amp;quot;),
     annotation_legend_side = &amp;quot;right&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-01-16-how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;plot-multiple-genes-across-multiple-groupsconditions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;plot Multiple genes across multiple groups/conditions&lt;/h3&gt;
&lt;p&gt;Let‚Äôs change the function a little. The major difference is this line:
&lt;code&gt;tidyr::pivot_wider(names_from = c({{group1}}, {{group2}}),                         values_from= average_expression,                        names_sep=&#34;|&#34;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;So the data will be wrangled as:
rows are genes, columns are &lt;code&gt;cell_type|condition&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;GetMatrixFromSeuratByGroupMulti&amp;lt;- function(obj, features, group1, group2){
  exp_mat&amp;lt;- obj@assays$RNA@data[features, ,drop=FALSE]
  count_mat&amp;lt;- obj@assays$RNA@counts[features,,drop=FALSE ]
  
  meta&amp;lt;- obj@meta.data %&amp;gt;%
  tibble::rownames_to_column(var = &amp;quot;cell&amp;quot;)
  
  # get the average expression matrix        
  exp_df&amp;lt;- as.matrix(exp_mat) %&amp;gt;% 
    as.data.frame() %&amp;gt;% 
    tibble::rownames_to_column(var=&amp;quot;gene&amp;quot;) %&amp;gt;%
    tidyr::pivot_longer(!gene, names_to = &amp;quot;cell&amp;quot;, values_to = &amp;quot;expression&amp;quot;) %&amp;gt;%
    left_join(meta) %&amp;gt;%
    group_by(gene,{{group1}}, {{group2}}) %&amp;gt;%
    summarise(average_expression = mean(expression)) %&amp;gt;%
    # the trick is to make the data wider in columns: cell_type|group
    tidyr::pivot_wider(names_from = c({{group1}}, {{group2}}), 
                       values_from= average_expression,
                       names_sep=&amp;quot;|&amp;quot;) 
  
  # convert to a matrix
  exp_mat&amp;lt;- exp_df[, -1] %&amp;gt;% as.matrix()
  rownames(exp_mat)&amp;lt;- exp_df$gene
  
  # get percentage of positive cells matrix
  count_df&amp;lt;- as.matrix(count_mat) %&amp;gt;% 
    as.data.frame() %&amp;gt;% 
    tibble::rownames_to_column(var=&amp;quot;gene&amp;quot;) %&amp;gt;%
    tidyr::pivot_longer(!gene, names_to = &amp;quot;cell&amp;quot;, values_to = &amp;quot;count&amp;quot;) %&amp;gt;%
    left_join(meta) %&amp;gt;%
    group_by(gene, {{group1}}, {{group2}}) %&amp;gt;%
    summarise(percentage = mean(count &amp;gt;0)) %&amp;gt;%
    tidyr::pivot_wider(names_from = c({{group1}}, {{group2}}), 
                       values_from= percentage,
                       names_sep=&amp;quot;|&amp;quot;)

  percent_mat&amp;lt;- count_df[, -1] %&amp;gt;% as.matrix()
  rownames(percent_mat)&amp;lt;- count_df$gene
  
  if (!identical(dim(exp_mat), dim(percent_mat))) {
    stop(&amp;quot;the dimension of the two matrice should be the same!&amp;quot;)
  }
  
  if(! all.equal(colnames(exp_mat), colnames(percent_mat))) {
    stop(&amp;quot;column names of the two matrice should be the same!&amp;quot;)
  }
  
  if(! all.equal(rownames(exp_mat), rownames(percent_mat))) {
    stop(&amp;quot;column names of the two matrice should be the same!&amp;quot;)
  }
  return(list(exp_mat = exp_mat, percent_mat = percent_mat))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs take a look at the matrices:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mat2&amp;lt;- GetMatrixFromSeuratByGroupMulti(obj= ifnb, 
                                       features = c(&amp;quot;ISG15&amp;quot;, &amp;quot;CXCL10&amp;quot;, &amp;quot;LYZ&amp;quot;, &amp;quot;CXCL9&amp;quot;),
                                       seurat_annotations, stim)

mat2$exp_mat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;        CD14 Mono|CTRL CD14 Mono|STIM CD4 Naive T|CTRL CD4 Naive T|STIM
#&amp;gt; CXCL10    0.087345121      5.0736492      0.002201396       0.61035184
#&amp;gt; CXCL9     0.003388209      0.1206664      0.000000000       0.00000000
#&amp;gt; ISG15     0.726171852      6.0702937      0.380820344       3.80877512
#&amp;gt; LYZ       2.414988107      2.6774910      0.041199264       0.04494943
#&amp;gt;        CD4 Memory T|CTRL CD4 Memory T|STIM CD16 Mono|CTRL CD16 Mono|STIM
#&amp;gt; CXCL10       0.004476775       0.668992851      0.7766469     5.00934744
#&amp;gt; CXCL9        0.000000000       0.002439572      0.0000000     0.02062243
#&amp;gt; ISG15        0.473392848       4.013709315      1.1175865     5.71266540
#&amp;gt; LYZ          0.033556360       0.064249244      1.3894338     0.98728252
#&amp;gt;            B|CTRL     B|STIM CD8 T|CTRL  CD8 T|STIM T activated|CTRL
#&amp;gt; CXCL10 0.02465307 2.40598430 0.00000000 0.509013005       0.00657299
#&amp;gt; CXCL9  0.00000000 0.01577367 0.00000000 0.004820181       0.00000000
#&amp;gt; ISG15  0.54956508 4.35028697 0.72849556 4.026049357       0.80743267
#&amp;gt; LYZ    0.04108924 0.04744420 0.03553156 0.041455107       0.04261386
#&amp;gt;        T activated|STIM    NK|CTRL   NK|STIM     DC|CTRL   DC|STIM
#&amp;gt; CXCL10       1.16903785 0.00000000 0.4221097 0.028490195 4.7406904
#&amp;gt; CXCL9        0.00000000 0.00000000 0.0000000 0.006332865 0.4458563
#&amp;gt; ISG15        4.11293242 0.78896021 4.5385409 0.656119064 5.7027258
#&amp;gt; LYZ          0.01990898 0.01638341 0.0857032 3.773146881 3.2401631
#&amp;gt;        B Activated|CTRL B Activated|STIM    Mk|CTRL    Mk|STIM   pDC|CTRL
#&amp;gt; CXCL10       0.01261649       2.26825925 0.07612572 1.31048801 0.04369413
#&amp;gt; CXCL9        0.00000000       0.02436157 0.00000000 0.01622667 0.00000000
#&amp;gt; ISG15        0.38002811       4.01217616 0.59414320 4.01146096 0.40850237
#&amp;gt; LYZ          0.06561868       0.07417401 0.72371186 0.32235497 0.24321177
#&amp;gt;          pDC|STIM Eryth|CTRL Eryth|STIM
#&amp;gt; CXCL10 2.25108405  0.0000000  1.6256344
#&amp;gt; CXCL9  0.06612518  0.0000000  0.0000000
#&amp;gt; ISG15  4.52475112  0.2929348  3.9331893
#&amp;gt; LYZ    0.02124968  0.6171084  0.3471586&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mat2$percent_mat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#&amp;gt;        CD14 Mono|CTRL CD14 Mono|STIM CD4 Naive T|CTRL CD4 Naive T|STIM
#&amp;gt; CXCL10    0.035214447     0.98369818      0.001022495       0.25557012
#&amp;gt; CXCL9     0.001805869     0.07033069      0.000000000       0.00000000
#&amp;gt; ISG15     0.323702032     1.00000000      0.166666667       0.99279161
#&amp;gt; LYZ       0.817155756     0.88868188      0.019427403       0.02162516
#&amp;gt;        CD4 Memory T|CTRL CD4 Memory T|STIM CD16 Mono|CTRL CD16 Mono|STIM
#&amp;gt; CXCL10       0.002328289        0.27574751      0.2761341     0.98510242
#&amp;gt; CXCL9        0.000000000        0.00110742      0.0000000     0.01489758
#&amp;gt; ISG15        0.207217695        0.99003322      0.4950690     1.00000000
#&amp;gt; LYZ          0.016298021        0.02990033      0.6114398     0.47858473
#&amp;gt;            B|CTRL      B|STIM CD8 T|CTRL  CD8 T|STIM T activated|CTRL
#&amp;gt; CXCL10 0.00982801 0.651488616 0.00000000 0.225108225      0.003333333
#&amp;gt; CXCL9  0.00000000 0.007005254 0.00000000 0.002164502      0.000000000
#&amp;gt; ISG15  0.23341523 0.998248687 0.30113636 0.989177489      0.323333333
#&amp;gt; LYZ    0.01965602 0.022767075 0.01704545 0.019480519      0.020000000
#&amp;gt;        T activated|STIM     NK|CTRL    NK|STIM     DC|CTRL   DC|STIM
#&amp;gt; CXCL10      0.396396396 0.000000000 0.17445483 0.011627907 0.9766355
#&amp;gt; CXCL9       0.000000000 0.000000000 0.00000000 0.003875969 0.2570093
#&amp;gt; ISG15       0.975975976 0.315436242 0.98753894 0.352713178 1.0000000
#&amp;gt; LYZ         0.009009009 0.006711409 0.03738318 0.968992248 0.9626168
#&amp;gt;        B Activated|CTRL B Activated|STIM    Mk|CTRL     Mk|STIM   pDC|CTRL
#&amp;gt; CXCL10      0.005405405       0.60591133 0.02608696 0.371900826 0.01960784
#&amp;gt; CXCL9       0.000000000       0.01477833 0.00000000 0.008264463 0.00000000
#&amp;gt; ISG15       0.189189189       1.00000000 0.26086957 0.975206612 0.21568627
#&amp;gt; LYZ         0.037837838       0.03940887 0.26956522 0.123966942 0.11764706
#&amp;gt;          pDC|STIM Eryth|CTRL Eryth|STIM
#&amp;gt; CXCL10 0.70370370  0.0000000     0.4375
#&amp;gt; CXCL9  0.03703704  0.0000000     0.0000
#&amp;gt; ISG15  1.00000000  0.1739130     1.0000
#&amp;gt; LYZ    0.01234568  0.2608696     0.1875&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you have the matrices, you can plot the dotplot as you want.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# change the layer function, because you need mat2$percent_mat for the percentages
layer_fun2 = function(j, i, x, y, w, h, fill){
    grid.rect(x = x, y = y, width = w, height = h, 
              gp = gpar(col = &amp;quot;gray&amp;quot;, fill = NA))
    grid.circle(x=x,y=y,
                r= sqrt(pindex(mat2$percent_mat, i, j)) * unit(4, &amp;quot;mm&amp;quot;),
                gp = gpar(fill = col_fun(pindex(mat2$exp_mat, i, j)), col = NA))}

hp2&amp;lt;- Heatmap(mat2$exp_mat,
             heatmap_legend_param=list(title= &amp;quot;expression&amp;quot;),
             column_title = &amp;quot;genes&amp;quot;, 
             col=col_fun,
             rect_gp = gpar(type = &amp;quot;none&amp;quot;),
             layer_fun = layer_fun2,
             row_names_gp = gpar(fontsize = 8),
             border = &amp;quot;black&amp;quot;,
             cluster_rows = FALSE, 
             cluster_columns = FALSE,
             row_names_side  = &amp;quot;left&amp;quot;)


draw(hp2, annotation_legend_list = lgd_list, ht_gap = unit(1, &amp;quot;cm&amp;quot;),
     annotation_legend_side = &amp;quot;right&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-01-16-how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;If you do want to cluster the columns and rows&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hp3&amp;lt;- Heatmap(mat2$exp_mat,
             heatmap_legend_param=list(title= &amp;quot;expression&amp;quot;),
             column_title = &amp;quot;genes&amp;quot;, 
             col=col_fun,
             rect_gp = gpar(type = &amp;quot;none&amp;quot;),
             layer_fun = layer_fun2,
             row_names_gp = gpar(fontsize = 8),
             border = &amp;quot;black&amp;quot;,
             cluster_rows = TRUE, 
             cluster_columns = TRUE,
             row_names_side  = &amp;quot;left&amp;quot;)


draw(hp3, annotation_legend_list = lgd_list, ht_gap = unit(1, &amp;quot;cm&amp;quot;),
     annotation_legend_side = &amp;quot;right&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2024-01-16-how-to-make-a-multi-group-dotplot-for-single-cell-rnaseq-data_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;With the matrices available, you can do subsetting of the matrices, arrange the
rows and columns as you want and even add annotation bars. As you see, once you
master the basics, you can plot anything as you want without relying on pre-built
packages.&lt;/p&gt;
&lt;p&gt;We can wrap the above code into a function for easier usage, but I will leave it
as a homework for the readers.&lt;/p&gt;
&lt;p&gt;Of course, you do not want to re-invent the wheels, use a well-maintained package
when possible, build your own wheel when necessary.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;further-reading&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Further reading&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/TheHumphreysLab/plot1cell/tree/master&#34;&gt;&lt;code&gt;plot1cell&lt;/code&gt;&lt;/a&gt; is trying
to solve the similar problem, but it is not that flexible.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Great Things Take Time: How Decades of Effort Led to My Dream Career</title>
      <link>/post/great-things-take-time-how-decades-of-effort-led-to-my-dream-career/</link>
      <pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>/post/great-things-take-time-how-decades-of-effort-led-to-my-dream-career/</guid>
      <description>&lt;p&gt;Everyone is unique. Only you can talk about the story about yourself, and I realized that no matter how many times I have told my story, I have to tell it again, again, again, and again. Because no matter how many times I tell it, there is always someone who hear my story the first time. I hope it can inspire more people every time I tell it.&lt;/p&gt;

&lt;p&gt;Fast backward 37 years ago, 1986. I was born in a low-income family in China. My dad was a middle school teacher, my mom was caring for me and my sister, it was more than a full-time job for her. We could never make ends meet.  My dad had a mental disease and we had to take care of him.&lt;/p&gt;

&lt;p&gt;In my third grade, what was worse was that my mom was diagnosed with tuberculosis. She had to lay in bed for months. I became quite independent at an early age. One morning, I was cooking porridge for the family, and I dropped the whole pot on the ground.&lt;/p&gt;

&lt;p&gt;I kneeled on the floor and started to clean it up. I cried. I asked myself why life was so hard.
Have you asked yourself the same question when you have troubles in life; when you feel the whole world has abandoned you? It turned out the misery was nothing when I look back now, but that‚Äôs a little segway. My mom held my hands in the bed, she said: son, only knowledge can change your life.&lt;/p&gt;

&lt;p&gt;I studied really, really hard. I would finish all my homework in a park before it became too dark and went home. 10 years (note the time) after that day I was in high school and ready to take the college entrance exam. I got into the best high school in the town. In fact, I ranked #1 when I got into it.&lt;/p&gt;

&lt;p&gt;Everyone had a high hope for me, especially my mom. Unfortunately, I did not do well in the exam and only got into a so-so key university. My mom cried, it is tears of sorrow. She could not believe her son could let her down. She held my hands again: son, only knowledge can change your life.&lt;/p&gt;

&lt;p&gt;We decided to go back to high school, study for one more year and retake the exam next year. It was not an easy decision. One of my classmates who initially decided to stay went to the University before the deadline. He said to me: Tommy, it is a key university, I can not waste another year and I can not guarantee that I will do better than this time.‚Äù&lt;/p&gt;

&lt;p&gt;Yeah, I could not guarantee anything either. The only thing I can guarantee is to show up every day, study every day and grind every day.  My effort got paid off. The next year, I got into a top University ranking top 0.1% among 200K students. My mom cried again. This time, tears of joy.&lt;/p&gt;

&lt;p&gt;August 8th, 2008, I started a new chapter of my life by coming to the States, to pursue my PhD at the University of Florida. For me, it was like a child being thrown into a candy store. All of a sudden, I have access to a top-notch wet lab and tons of new things for me to learn.&lt;/p&gt;

&lt;p&gt;Four years into my Ph.D. I‚Äôve already published two first-author papers in well-respected journals. I was very happy. Until one day, my adviser asked me to analyze a public dataset. The file was so big that it crashed Excel. Suddenly I realized that I didn‚Äôt have data analysis skills. A bit of frustration was an understatement. I started to learn it by myself.&lt;/p&gt;

&lt;p&gt;When the busy lab day was over, I dashed back to my apartment to resume my learning on Coursera, watching videos, taking notes, and doing homework. It opened a whole new world for me. I took almost 40 courses in various subjects of statistics, programming, and computation in the first few years.&lt;/p&gt;

&lt;p&gt;It was not easy. I was the only one on the floor to learn bioinformatics and had no one to turn to. I spent hours, and hours googling how-to and error messages. 2 years later, I went on to do a computational biology postdoc. And 10 years later (note the time), I became a director of bioinformatics in a biotech start-up using my skills to develop new medicine for cancer patients and the rest was history.&lt;/p&gt;

&lt;p&gt;The last 10 years were a wild ride, I can not imagine what‚Äôs going to happen in 10 years.&lt;/p&gt;

&lt;p&gt;Dear fellow Toastmasters. If there is only one takeaway from my story today, it is this:
 Great things take great effort. No one succeeds overnight. Every successful person you see, there is 10 years of work behind the scenes. If you enlarge the time horizon to decades, if you work hard for 10 years, doing basic things better for 10 years, It is unreasonable for you to not succeed.&lt;/p&gt;

&lt;p&gt;If you attend Toastmasters for 10 years, it is unreasonable for you not to get better.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
