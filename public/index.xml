<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DNA confesses Data speak on DNA confesses Data speak</title>
    <link>/</link>
    <description>Recent content in DNA confesses Data speak on DNA confesses Data speak</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018 Ming Tang</copyright>
    <lastBuildDate>Sun, 15 Oct 2017 00:00:00 -0400</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Enhancement of scRNAseq heatmap using complexheatmap</title>
      <link>/post/enhancement-of-scrnaseq-heatmap-using-complexheatmap/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/enhancement-of-scrnaseq-heatmap-using-complexheatmap/</guid>
      <description>

&lt;p&gt;When it comes to make a heatmap, &lt;a href=&#34;https://jokergoo.github.io/ComplexHeatmap-reference/book/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;ComplexHeatmap&lt;/code&gt;&lt;/a&gt; by Zuguang Gu is my favorite. Check it out! You will be amazed on how flexible it is and the documentation is in top niche.&lt;/p&gt;

&lt;p&gt;For Single-cell RNAseq, &lt;code&gt;Seurat&lt;/code&gt; provides a &lt;code&gt;DoHeatmap&lt;/code&gt; function using &lt;code&gt;ggplot2&lt;/code&gt;. There are two limitations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;when your genes are not in the top variable gene list, the &lt;code&gt;scale.data&lt;/code&gt; will not have that gene and &lt;code&gt;DoHeatmap&lt;/code&gt; will drop those genes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ggplot2&lt;/code&gt; does not support clustering of the rows or columns.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I highly recommend you to read two posts I wrote as well on heatmap:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://rpubs.com/crazyhottommy/a-tale-of-two-heatmap-functions&#34; target=&#34;_blank&#34;&gt;A tale of two heatmap functions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://rpubs.com/crazyhottommy/heatmap_demystified&#34; target=&#34;_blank&#34;&gt;Heatmap demystified&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let me walk you through how I replicate and enhance the Seurat version of heatmap using &lt;code&gt;ComplexHeatmap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;follow the tutorial &lt;a href=&#34;https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html&#34; target=&#34;_blank&#34;&gt;https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(dplyr)
library(Seurat)
library(ComplexHeatmap)
# https://github.com/immunogenomics/presto
library(presto)
library(tictoc)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Load the PBMC dataset
pbmc.data &amp;lt;- Read10X(data.dir = &amp;quot;~/Downloads/filtered_gene_bc_matrices/hg19/&amp;quot;)
pbmc &amp;lt;- CreateSeuratObject(counts = pbmc.data, project = &amp;quot;pbmc3k&amp;quot;, min.cells = 3, min.features = 200)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning: Feature names cannot have underscores (&#39;_&#39;), replacing with dashes
## (&#39;-&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pbmc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## An object of class Seurat 
## 13714 features across 2700 samples within 1 assay 
## Active assay: RNA (13714 features)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pbmc[[&amp;quot;percent.mt&amp;quot;]] &amp;lt;- PercentageFeatureSet(pbmc, pattern = &amp;quot;^MT-&amp;quot;)

## ScaleData uses top variable genes only
pbmc&amp;lt;- pbmc %&amp;gt;% 
  NormalizeData(normalization.method = &amp;quot;LogNormalize&amp;quot;, scale.factor = 10000) %&amp;gt;%
  FindVariableFeatures(selection.method = &amp;quot;vst&amp;quot;, nfeatures = 2000) %&amp;gt;%
  ScaleData() %&amp;gt;%
  RunPCA() %&amp;gt;%
  FindNeighbors(dims = 1:10) %&amp;gt;%
  FindClusters(resolution = 0.5) %&amp;gt;%
  RunUMAP(dims = 1:10)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck
## 
## Number of nodes: 2700
## Number of edges: 97958
## 
## Running Louvain algorithm...
## Maximum modularity in 10 random starts: 0.8717
## Number of communities: 9
## Elapsed time: 0 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric
## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39;
## This message will be shown once per session
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;DimPlot(pbmc, reduction = &amp;quot;umap&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/post/2020-09-10-enhancement-of-scrnaseq-heatmap-using-complexheatmap.en_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The UMAP plot looks a bit different from the tutorial, but the structure is similar enough (You see how difficult it is to reproduce the exactly the same figure even with the same code:)).&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s find marker genes for each cluster. I like &lt;code&gt;presto&lt;/code&gt; for this purpose. It is much faster than Seurat.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tic()
markers&amp;lt;- presto::wilcoxauc(pbmc, &#39;seurat_clusters&#39;, assay = &#39;data&#39;)
toc()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## 0.364 sec elapsed
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;markers&amp;lt;- top_markers(markers, n = 10, auc_min = 0.5, pct_in_min = 20, pct_out_max = 20)

markers
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 10
##     rank `0`      `1`    `2`    `3`      `4`   `5`         `6`   `7`     `8`    
##    &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;  
##  1     1 CCR7     S100A8 AQP3   CD79A    GZMA  FCGR3A      GZMB  FCER1A  PPBP   
##  2     2 PIK3IP1  FCN1   TRAT1  CD79B    CST7  IFITM3      PRF1  CLEC10A NRGN   
##  3     3 PRKCQ-A… LGALS2 SPOCK2 MS4A1    GZMK  RP11-290F2… GNLY  HLA-DQ… PF4    
##  4     4 LEF1     CFD    CD27   HLA-DQA1 LYAR  CFD         FGFB… CPVL    SDPR   
##  5     5 TCF7     GRN    TRADD  HLA-DQB1 GZMM  MS4A7       CST7  HLA-DMB GNG11  
##  6     6 CD27     MS4A6A CD3G   TCL1A    CD8A  CD68        GZMA  CD33    SPARC  
##  7     7 MAL      AP1S2  RGCC   LINC009… KLRG1 SPI1        FCGR… CTSH    RGS18  
##  8     8 RGCC     CD14   CD40LG HLA-DMA  PRF1  RHOC        SPON2 RNASE6  HIST1H…
##  9     9 CD3G     CD68   LAT    VPREB3   GZMH  HCK         CCL4  KLF4    TPM4   
## 10    10 LDLRAP1  LGALS3 FLT3LG HLA-DQA2 HOPX  IFI30       APMAP RNF130  GP9
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;doheatmap&#34;&gt;DoHeatmap&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;all_markers&amp;lt;- markers %&amp;gt;%
  select(-rank) %&amp;gt;% 
  unclass() %&amp;gt;% 
  stack() %&amp;gt;%
  pull(values) %&amp;gt;%
  unique() %&amp;gt;%
   .[!is.na(.)]
DoHeatmap(pbmc, features = all_markers) + NoLegend()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Warning in DoHeatmap(pbmc, features = all_markers): The following features were
## omitted as they were not found in the scale.data slot for the RNA assay: TPM4,
## RNF130, KLF4, RNASE6, CTSH, CD33, CPVL, APMAP, HCK, RHOC, RP11-290F20.3, CD8A,
## GZMM, VPREB3, FLT3LG, LAT, CD40LG, SPOCK2, TRAT1, CD68, CD14, AP1S2, GRN, CD3G,
## RGCC, CD27, TCF7, LEF1, PRKCQ-AS1, PIK3IP1, CCR7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/post/2020-09-10-enhancement-of-scrnaseq-heatmap-using-complexheatmap.en_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;you see warnings:&amp;ldquo;the following features were omitted as they were not found in the scale.data slot for the RNA assay&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;replicate-the-heatmap-using-complexheatmap&#34;&gt;replicate the heatmap using Complexheatmap&lt;/h3&gt;

&lt;p&gt;We can go back to the &lt;code&gt;data&lt;/code&gt; slot to get all the genes&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mat&amp;lt;- pbmc[[&amp;quot;RNA&amp;quot;]]@data[all_markers, ] %&amp;gt;% as.matrix()

## scale the rows
mat&amp;lt;- t(scale(t(mat)))

cluster_anno&amp;lt;- pbmc@meta.data$seurat_clusters
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map the color to the scaled expression values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# what&#39;s the value range in the matrix
quantile(mat, c(0.1, 0.95))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##        10%        95% 
## -0.5277426  2.3470090
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Seurat::PurpleAndYellow()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;#FF00FF&amp;quot; &amp;quot;#F400F4&amp;quot; &amp;quot;#EA00EA&amp;quot; &amp;quot;#DF00DF&amp;quot; &amp;quot;#D500D5&amp;quot; &amp;quot;#CA00CA&amp;quot; &amp;quot;#BF00BF&amp;quot;
##  [8] &amp;quot;#B500B5&amp;quot; &amp;quot;#AA00AA&amp;quot; &amp;quot;#9F009F&amp;quot; &amp;quot;#950095&amp;quot; &amp;quot;#8A008A&amp;quot; &amp;quot;#800080&amp;quot; &amp;quot;#750075&amp;quot;
## [15] &amp;quot;#6A006A&amp;quot; &amp;quot;#600060&amp;quot; &amp;quot;#550055&amp;quot; &amp;quot;#4A004A&amp;quot; &amp;quot;#400040&amp;quot; &amp;quot;#350035&amp;quot; &amp;quot;#2B002B&amp;quot;
## [22] &amp;quot;#200020&amp;quot; &amp;quot;#150015&amp;quot; &amp;quot;#0B000B&amp;quot; &amp;quot;#000000&amp;quot; &amp;quot;#000000&amp;quot; &amp;quot;#0B0B00&amp;quot; &amp;quot;#151500&amp;quot;
## [29] &amp;quot;#202000&amp;quot; &amp;quot;#2B2B00&amp;quot; &amp;quot;#353500&amp;quot; &amp;quot;#404000&amp;quot; &amp;quot;#4A4A00&amp;quot; &amp;quot;#555500&amp;quot; &amp;quot;#606000&amp;quot;
## [36] &amp;quot;#6A6A00&amp;quot; &amp;quot;#757500&amp;quot; &amp;quot;#808000&amp;quot; &amp;quot;#8A8A00&amp;quot; &amp;quot;#959500&amp;quot; &amp;quot;#9F9F00&amp;quot; &amp;quot;#AAAA00&amp;quot;
## [43] &amp;quot;#B5B500&amp;quot; &amp;quot;#BFBF00&amp;quot; &amp;quot;#CACA00&amp;quot; &amp;quot;#D4D400&amp;quot; &amp;quot;#DFDF00&amp;quot; &amp;quot;#EAEA00&amp;quot; &amp;quot;#F4F400&amp;quot;
## [50] &amp;quot;#FFFF00&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;## make the black color map to 0. the yellow map to highest and the purle map to the lowest
col_fun = circlize::colorRamp2(c(-1, 0, 3), c(&amp;quot;#FF00FF&amp;quot;, &amp;quot;black&amp;quot;, &amp;quot;#FFFF00&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;plot the heatmap&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Heatmap(mat, name = &amp;quot;Expression&amp;quot;,  
        column_split = factor(cluster_anno),
        cluster_columns = TRUE,
        show_column_dend = FALSE,
        cluster_column_slices = TRUE,
        column_title_gp = gpar(fontsize = 8),
        column_gap = unit(0.5, &amp;quot;mm&amp;quot;),
        cluster_rows = TRUE,
        show_row_dend = FALSE,
        col = col_fun,
        row_names_gp = gpar(fontsize = 4),
        column_title_rot = 90,
        top_annotation = HeatmapAnnotation(foo = anno_block(gp = gpar(fill = scales::hue_pal()(9)))),
        show_column_names = FALSE,
        use_raster = TRUE,
        raster_quality = 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/post/2020-09-10-enhancement-of-scrnaseq-heatmap-using-complexheatmap.en_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to the capability to plot all the genes, one can cluster the rows (genes) and the columns (cells) within each slice (cell type), and slices can be further clustered as well.&lt;/p&gt;

&lt;p&gt;Several other notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When you have too many cells (&amp;gt; 10,000), the &lt;code&gt;use_raster&lt;/code&gt; option really helps. Also consider downsample the Seurat object to a smaller number of cells for plotting the heatmap. Your screen resolution is not as high as 300,000 pixels if you have 300,000 cells (columns).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please read &lt;a href=&#34;https://jokergoo.github.io/2020/06/30/rasterization-in-complexheatmap/&#34; target=&#34;_blank&#34;&gt;https://jokergoo.github.io/2020/06/30/rasterization-in-complexheatmap/&lt;/a&gt;
and &lt;a href=&#34;https://gdevailly.netlify.app/post/plotting-big-matrices-in-r/&#34; target=&#34;_blank&#34;&gt;Plotting heatmaps from big matrices in R&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;check &lt;a href=&#34;https://github.com/stemangiola/tidyHeatmap&#34; target=&#34;_blank&#34;&gt;tidyHeatmap&lt;/a&gt; built upon &lt;code&gt;Complexheatmap&lt;/code&gt; for tidy dataframe.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/YuLab-SMU/aplot&#34; target=&#34;_blank&#34;&gt;aplot&lt;/a&gt; from Guangchuang Yu.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/rlbarter/superheat&#34; target=&#34;_blank&#34;&gt;superheat&lt;/a&gt; from Rebecca Barter.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>dplyr::count misses factor levels: a case in comparing scRNAseq cell type abundance </title>
      <link>/post/dplyr-count-misses-factor-levels-a-case-in-comparing-scrnaseq-cell-type-abundance/</link>
      <pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/dplyr-count-misses-factor-levels-a-case-in-comparing-scrnaseq-cell-type-abundance/</guid>
      <description>&lt;p&gt;It is very common to see in the scRNAseq papers that the authors compare cell type abundance across groups (e.g., treatment vs control, responder vs non-responder).&lt;/p&gt;
&lt;p&gt;Let’s create some dummy data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
set.seed(23)

# we have 6 treatment samples and 6 control samples, 3 clusters A,B,C
# but in the treatment samples, cluster C is absent (0 cells) in sample7
sample_id&amp;lt;- c(paste0(&amp;quot;sample&amp;quot;, 1:6, &amp;quot;_control&amp;quot;, rep(c(&amp;quot;_A&amp;quot;,&amp;quot;_B&amp;quot;,&amp;quot;_C&amp;quot;),each = 6)), paste0(&amp;quot;sample&amp;quot;, 8:12, &amp;quot;_treatment&amp;quot;, rep(c(&amp;quot;_A&amp;quot;,&amp;quot;_B&amp;quot;, &amp;quot;_C&amp;quot;), each = 5)))

sample_id&amp;lt;- c(sample_id, &amp;quot;sample7_treatment_A&amp;quot;, &amp;quot;sample7_treatment_B&amp;quot;)
cell_id&amp;lt;- paste0(&amp;quot;cell&amp;quot;, 1:20000)

cell_df&amp;lt;- tibble::tibble(sample_id = sample(sample_id, size = length(cell_id), replace = TRUE), 
         cell_id = cell_id) %&amp;gt;%
  tidyr::separate(sample_id, into = c(&amp;quot;sample_id&amp;quot;, &amp;quot;group&amp;quot;, &amp;quot;cluster_id&amp;quot;), sep= &amp;quot;_&amp;quot;)


cell_num&amp;lt;- cell_df %&amp;gt;% 
  group_by(group, cluster_id, sample_id)%&amp;gt;%
  summarize(n=n()) 

cell_num&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 35 x 4
## # Groups:   group, cluster_id [6]
##    group   cluster_id sample_id     n
##    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;
##  1 control A          sample1     551
##  2 control A          sample2     546
##  3 control A          sample3     544
##  4 control A          sample4     585
##  5 control A          sample5     588
##  6 control A          sample6     542
##  7 control B          sample1     550
##  8 control B          sample2     562
##  9 control B          sample3     574
## 10 control B          sample4     563
## # … with 25 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_cells&amp;lt;- cell_df %&amp;gt;%
  group_by(sample_id) %&amp;gt;%
  summarise(total = n())

total_cells&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 12 x 2
##    sample_id total
##    &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;
##  1 sample1    1673
##  2 sample10   1713
##  3 sample11   1691
##  4 sample12   1696
##  5 sample2    1633
##  6 sample3    1700
##  7 sample4    1711
##  8 sample5    1768
##  9 sample6    1727
## 10 sample7    1225
## 11 sample8    1720
## 12 sample9    1743&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;join the two dataframe to get percentage of cells per cluster per sample&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cell_percentage&amp;lt;- left_join(cell_num, total_cells) %&amp;gt;%
  mutate(percentage = n/total)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Joining, by = &amp;quot;sample_id&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cell_percentage&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 35 x 6
## # Groups:   group, cluster_id [6]
##    group   cluster_id sample_id     n total percentage
##    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;      &amp;lt;dbl&amp;gt;
##  1 control A          sample1     551  1673      0.329
##  2 control A          sample2     546  1633      0.334
##  3 control A          sample3     544  1700      0.32 
##  4 control A          sample4     585  1711      0.342
##  5 control A          sample5     588  1768      0.333
##  6 control A          sample6     542  1727      0.314
##  7 control B          sample1     550  1673      0.329
##  8 control B          sample2     562  1633      0.344
##  9 control B          sample3     574  1700      0.338
## 10 control B          sample4     563  1711      0.329
## # … with 25 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s plot a boxplot&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cell_percentage %&amp;gt;%
  ggplot(aes(x = group, y = percentage)) +
  geom_boxplot(outlier.shape = NA, aes(fill = group)) +
  geom_jitter() +
  scale_y_continuous(labels = scales::percent) +
  facet_wrap(~cluster_id) +
  theme_bw()+
  xlab(&amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-08-26-dplyr-count-misses-factor-levels-a-case-in-comparing-scrnaseq-cell-type-abundance.en_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;YES, if you are careful enough&lt;/strong&gt;, you will find the treatment group in cluster C only contains 5 points.
Because if a cluster is completely missing for a sample, there will not be any cells in the original &lt;code&gt;cell_df&lt;/code&gt;. However, the percentage should be 0% for that data point and you should show it in the boxplot as the jitter point. Otherwise, the result can be misleading. You can spot on such mistakes when you plot out the points on top of the boxplot.&lt;/p&gt;
&lt;div id=&#34;how-to-fix-it&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;How to fix it&lt;/h3&gt;
&lt;p&gt;The trick is to make the factor contains all the levels of all the combinations. When use &lt;code&gt;group_by&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt;, add &lt;code&gt;.drop =FALSE&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sample_id&amp;lt;- paste0(&amp;quot;sample&amp;quot;, 1:12)
cluster_id&amp;lt;- c(&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;)


factor_levels&amp;lt;- tidyr::expand_grid(sample_id, cluster_id) %&amp;gt;%
  mutate(group = c(rep(&amp;quot;control&amp;quot;, 18), rep(&amp;quot;treatment&amp;quot;, 18))) %&amp;gt;%
  mutate(sample_id = paste(sample_id, cluster_id, group, sep=&amp;quot;_&amp;quot;))

cell_num2&amp;lt;- cell_df %&amp;gt;%
  mutate(sample_id = paste(sample_id, cluster_id, group, sep=&amp;quot;_&amp;quot;)) %&amp;gt;%
  mutate(sample_id = factor(sample_id, levels = factor_levels$sample_id)) %&amp;gt;%
  group_by(sample_id, .drop=FALSE) %&amp;gt;%
  summarise(n=n()) %&amp;gt;%
  tidyr::separate(sample_id, c(&amp;quot;sample_id&amp;quot;, &amp;quot;cluster_id&amp;quot;, &amp;quot;group&amp;quot;)) 


## the 0 correctly showed up
cell_num2 %&amp;gt;%
  filter(sample_id == &amp;quot;sample7&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 4
##   sample_id cluster_id group         n
##   &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;
## 1 sample7   A          treatment   604
## 2 sample7   B          treatment   621
## 3 sample7   C          treatment     0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s replot the boxplot and see the difference:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cell_percentage&amp;lt;- left_join(cell_num2, total_cells) %&amp;gt;%
  mutate(percentage = n/total)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Joining, by = &amp;quot;sample_id&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# replot the same boxplot
cell_percentage %&amp;gt;%
  ggplot(aes(x = group, y = percentage)) +
  geom_boxplot(outlier.shape = NA, aes(fill = group)) +
  geom_jitter() +
  scale_y_continuous(labels = scales::percent) +
  facet_wrap(~cluster_id) +
  theme_bw()+
  xlab(&amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-08-26-dplyr-count-misses-factor-levels-a-case-in-comparing-scrnaseq-cell-type-abundance.en_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now the 0 percentage point for sample7 in cluster C showed up.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Conclusions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Be careful with the 0 count cell in some clusters in some samples. If you work with &lt;code&gt;Seurat&lt;/code&gt;, people tend to use &lt;code&gt;seurat_obj@meta.data %&amp;gt;% group_by(cluster_id, sample_id, group)&lt;/code&gt;, but this will miss the samples in which some clusters are missing.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For differential abundance comparison between treatment vs control, directly comparing percentages are not optimal. Follow tutorial on using raw cell counts &lt;a href=&#34;https://osca.bioconductor.org/multi-sample-comparisons.html#&#34; class=&#34;uri&#34;&gt;https://osca.bioconductor.org/multi-sample-comparisons.html#&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;More tools can be found at &lt;a href=&#34;https://github.com/crazyhottommy/scRNAseq-analysis-notes#cell-type-prioritizationdifferential-abundance-test&#34; class=&#34;uri&#34;&gt;https://github.com/crazyhottommy/scRNAseq-analysis-notes#cell-type-prioritizationdifferential-abundance-test&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Integrative analyses of single-cell transcriptome and regulome using MAESTRO</title>
      <link>/publication/2020-08-07-maestro/</link>
      <pubDate>Fri, 07 Aug 2020 00:00:00 -0400</pubDate>
      
      <guid>/publication/2020-08-07-maestro/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>setting up Travis CI for github repos</title>
      <link>/post/setting-up-travis-ci-for-github-repos/</link>
      <pubDate>Wed, 15 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/setting-up-travis-ci-for-github-repos/</guid>
      <description>

&lt;p&gt;I wanted to set up Travis CI long time ago. Finally, I have a chance to do so.
There are already many posts on how to do it. I write it down here for my own future reference.
Thanks &lt;a href=&#34;https://twitter.com/fooliu&#34; target=&#34;_blank&#34;&gt;Tao Liu&lt;/a&gt; for the instructions. I have been learning a lot from him in collabrating with the &lt;a href=&#34;https://github.com/liulab-dfci/MAESTRO&#34; target=&#34;_blank&#34;&gt;MAESTRO&lt;/a&gt; project.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;read the official documentation &lt;a href=&#34;https://docs.travis-ci.com/user/tutorial/&#34; target=&#34;_blank&#34;&gt;https://docs.travis-ci.com/user/tutorial/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jean Fan&amp;rsquo;s blog post &lt;a href=&#34;https://jef.works/blog/2019/02/17/automate-testing-of-your-R-package/&#34; target=&#34;_blank&#34;&gt;https://jef.works/blog/2019/02/17/automate-testing-of-your-R-package/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;R specific &lt;a href=&#34;https://docs.travis-ci.com/user/languages/r/&#34; target=&#34;_blank&#34;&gt;https://docs.travis-ci.com/user/languages/r/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Blog post from Julia &lt;a href=&#34;https://juliasilge.com/blog/beginners-guide-to-travis/&#34; target=&#34;_blank&#34;&gt;https://juliasilge.com/blog/beginners-guide-to-travis/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;step-1&#34;&gt;Step 1&lt;/h3&gt;

&lt;p&gt;go to github marketplace: &lt;a href=&#34;https://github.com/marketplace&#34; target=&#34;_blank&#34;&gt;https://github.com/marketplace&lt;/a&gt;.
Search for &lt;code&gt;Travis CI&lt;/code&gt;. It is free for open source project. choose the free plan. Click &lt;code&gt;install for free&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;step-2&#34;&gt;step 2&lt;/h3&gt;

&lt;p&gt;Inside the github repo, create a &lt;code&gt;.travis.yml&lt;/code&gt; file. See an example for the MAESTRO:&lt;a href=&#34;https://github.com/liulab-dfci/MAESTRO/blob/master/.travis.yml&#34; target=&#34;_blank&#34;&gt;https://github.com/liulab-dfci/MAESTRO/blob/master/.travis.yml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I also have one for my &lt;a href=&#34;https://github.com/crazyhottommy/scclusteval/blob/master/.travis.yml&#34; target=&#34;_blank&#34;&gt;scclusteval&lt;/a&gt; R package.&lt;/p&gt;

&lt;p&gt;After setting it up, after each commit or pull request, a test is automatically run in travis and you will get notification to see if the build passed or not. This is really nice!&lt;/p&gt;

&lt;h3 id=&#34;step-3-embedding-status-images-to-the-github-readme&#34;&gt;step 3 Embedding Status Images to the github README&lt;/h3&gt;

&lt;p&gt;You can embed a buid status badge in the README.md of your github repo following:
&lt;a href=&#34;https://docs.travis-ci.com/user/status-images/&#34; target=&#34;_blank&#34;&gt;https://docs.travis-ci.com/user/status-images/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>build your own singularity image</title>
      <link>/post/build-your-own-singularity-image/</link>
      <pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/build-your-own-singularity-image/</guid>
      <description>

&lt;p&gt;I was using the &lt;a href=&#34;https://hub.docker.com/r/rocker/tidyverse/&#34; target=&#34;_blank&#34;&gt;tidyverse rocker image&lt;/a&gt; on HPC by &lt;code&gt;singularity pull&lt;/code&gt;. see my previous &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/run-rstudio-server-with-singularity-on-hpc/&#34; target=&#34;_blank&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Everything was OK until I encountered problems installing &lt;code&gt;jpeg&lt;/code&gt; and &lt;code&gt;Cairo&lt;/code&gt; R packages. Later, I also had an error installing &lt;a href=&#34;https://github.com/ncborcherding/scRepertoire&#34; target=&#34;_blank&#34;&gt;scRepertoire&lt;/a&gt; dependency &lt;code&gt;gsl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It turns out I have to install debian packages inside the container:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ apt update &amp;amp;&amp;amp; apt install -y --no-install-recommends libjpeg62-turbo-dev zlib1g-dev libpng-dev \
	&amp;amp;&amp;amp; apt install -y --no-install-recommends libx11-dev libcairo2-dev libxt-dev \
	&amp;amp;&amp;amp; apt install -y libgsl-dev 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, singularity file system is read-only.&lt;/p&gt;

&lt;p&gt;You &lt;strong&gt;CAN NOT&lt;/strong&gt; do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;singularity shell rstudio.simg
## and then inside the container
apt install -y --no-install-recommends libjpeg62-turbo-dev zlib1g-dev libpng-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nathan Weeks, our previous docker expert at Harvard FAS informatics told me:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Easiest would be to extend the Docker image, then create a new Singularity image from that.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The followings are the steps I took.&lt;/p&gt;

&lt;h3 id=&#34;prepare-a-dockerfile&#34;&gt;prepare a dockerfile&lt;/h3&gt;

&lt;p&gt;On my local mac which has docker running prepare a &lt;a href=&#34;https://github.com/crazyhottommy/rocker_tidyvese_jpeg_cairo&#34; target=&#34;_blank&#34;&gt;Dockerfile&lt;/a&gt; and put it into a folder &lt;code&gt;rocker-jpeg&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM rocker/tidyverse:3.6.3
RUN apt update &amp;amp;&amp;amp; apt install -y --no-install-recommends libjpeg62-turbo-dev zlib1g-dev libpng-dev \
	&amp;amp;&amp;amp; apt install -y --no-install-recommends libx11-dev libcairo2-dev libxt-dev \
	&amp;amp;&amp;amp; apt install -y libgsl-dev \
 	&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;build-the-docker-image&#34;&gt;build the docker image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd rocker-jpeg
## build the extended docker image
$ docker build -t rocker-with-jpeg:3.6.3 .

## push to docker hub
$ docker tag rocker-with-jpeg:3.6.3 crazyhottommy/rocker-with-jpeg:3.6.3

$ docker push crazyhottommy/rocker-with-jpeg:3.6.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, I can install those packages successfully:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -it rocker-with-jpeg:3.6.3 bash
$ R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inside R console:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;&amp;gt; install.package(c(&amp;quot;jpeg&amp;quot;, &amp;quot;Cario&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;use-the-image&#34;&gt;use the image&lt;/h3&gt;

&lt;p&gt;I can now either directly &lt;code&gt;singularity pull docker://crazyhottommy/rocker-with-jpeg:3.6.3&lt;/code&gt;
to get the singularity image or convert the docker image to singularity image at my local mac:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -v /var/run/docker.sock:/var/run/docker.sock -v /tmp/singularity:/output --privileged -t --rm quay.io/singularity/docker2singularity:v3.6.3 my-rocker-with-jpeg:3.6.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting singularity image will be in &lt;code&gt;/tmp/singularity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: My previous colleague Seth Sahil mentioned that I may want to use the &lt;a href=&#34;https://hub.docker.com/r/rocker/geospatial&#34; target=&#34;_blank&#34;&gt;geospacial rocker image&lt;/a&gt; since it includes most of the libraries.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>reproducible computing for your own benifit</title>
      <link>/talk/2020-reproducible-computing/</link>
      <pubDate>Tue, 02 Jun 2020 14:30:00 -0400</pubDate>
      
      <guid>/talk/2020-reproducible-computing/</guid>
      <description>&lt;p&gt;We are hiring several new computational biologists in Shirley Liu Lab. All the new hires together with wet lab people
are going through a 5-week long intensive bioinformatics training: &lt;a href=&#34;https://liulab-dfci.github.io/teaching&#34; target=&#34;_blank&#34;&gt;STAT115&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am TAing for 2 weeks and I gave a talk on reproducible computing. Please find the PDF here and share!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Evaluating single-cell cluster stability using the Jaccard similarity index</title>
      <link>/publication/2020-05-29-scclusteval/</link>
      <pubDate>Fri, 29 May 2020 00:00:00 -0400</pubDate>
      
      <guid>/publication/2020-05-29-scclusteval/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>customize FeaturePlot in Seurat for multi-condition comparisons using patchwork</title>
      <link>/post/customize-featureplot-in-seurat-for-multi-condition-comparisons-using-patchwork/</link>
      <pubDate>Sat, 23 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/customize-featureplot-in-seurat-for-multi-condition-comparisons-using-patchwork/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://satijalab.org/seurat/&#34;&gt;&lt;code&gt;Seurat&lt;/code&gt;&lt;/a&gt; is great for scRNAseq analysis and it provides many easy-to-use &lt;code&gt;ggplot2&lt;/code&gt; wrappers for visualization. However, this brings the cost of flexibility. For example, In &lt;a href=&#34;https://github.com/satijalab/seurat/blob/master/R/visualization.R#L888&#34;&gt;&lt;code&gt;FeaturePlot&lt;/code&gt;&lt;/a&gt;, one can specify multiple genes and also &lt;code&gt;split.by&lt;/code&gt; to further split to multiple the conditions in the &lt;code&gt;meta.data&lt;/code&gt;. If &lt;code&gt;split.by&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;ncol&lt;/code&gt; is ignored so you can not arrange the grid.&lt;/p&gt;
&lt;p&gt;This is best to understand with an example.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(Seurat)
library(patchwork)
library(ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Load the PBMC dataset
pbmc.data &amp;lt;- Read10X(data.dir = &amp;quot;~/blog_data/filtered_gene_bc_matrices/hg19/&amp;quot;)
# Initialize the Seurat object with the raw (non-normalized data).
pbmc &amp;lt;- CreateSeuratObject(counts = pbmc.data, project = &amp;quot;pbmc3k&amp;quot;, min.cells = 3, min.features = 200)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Feature names cannot have underscores (&amp;#39;_&amp;#39;), replacing with dashes
## (&amp;#39;-&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pbmc &amp;lt;- pbmc %&amp;gt;% 
  NormalizeData() %&amp;gt;%
  FindVariableFeatures() %&amp;gt;%
  ScaleData() %&amp;gt;%
  RunPCA() %&amp;gt;%
  RunUMAP(dims = 1:10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric
## To use Python UMAP via reticulate, set umap.method to &amp;#39;umap-learn&amp;#39; and metric to &amp;#39;correlation&amp;#39;
## This message will be shown once per session&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;add-some-dummy-metadata&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;add some dummy metadata&lt;/h3&gt;
&lt;p&gt;let’s pretend that the cells are from 5 different samples.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sample_names&amp;lt;- sample(paste0(&amp;quot;sample&amp;quot;, 1:5), size = ncol(pbmc), replace =TRUE)
pbmc$samples&amp;lt;- factor(sample_names)
pbmc@meta.data %&amp;gt;% head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                orig.ident nCount_RNA nFeature_RNA samples
## AAACATACAACCAC     pbmc3k       2419          779 sample5
## AAACATTGAGCTAC     pbmc3k       4903         1352 sample4
## AAACATTGATCAGC     pbmc3k       3147         1129 sample4
## AAACCGTGCTTCCG     pbmc3k       2639          960 sample5
## AAACCGTGTATGCG     pbmc3k        980          521 sample2
## AAACGCACTGGTAC     pbmc3k       2163          781 sample1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(pbmc@meta.data$samples)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## sample1 sample2 sample3 sample4 sample5 
##     545     553     506     544     552&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;FeaturePlot(pbmc, features = &amp;quot;MS4A1&amp;quot;, split.by = &amp;quot;samples&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-05-23-customize-featureplot-in-seurat-for-multi-condition-comparisons-using-patchwork.en_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You will have 5 UMAP showing in the same row and can not arrange to multiple rows.&lt;/p&gt;
&lt;p&gt;I do not want to re-implement the &lt;code&gt;FeaturePlot&lt;/code&gt; function but rather rearrange the ggplot2 output by &lt;code&gt;patchwork&lt;/code&gt;.
I wrote the following function for this purpose.&lt;/p&gt;
&lt;p&gt;Note, only a single gene can be specified. The idea is to generate a single UMAP plot for each sample and save them into a list and then arrange them by &lt;code&gt;patchwork&lt;/code&gt;. Also make sure the &lt;code&gt;metadata_column&lt;/code&gt; is a factor.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;FeaturePlotSingle&amp;lt;- function(obj, feature, metadata_column, ...){
  all_cells&amp;lt;- colnames(obj)
  groups&amp;lt;- levels(obj@meta.data[, metadata_column])
  
  # the minimal and maximal of the value to make the legend scale the same. 
  minimal&amp;lt;- min(obj[[&amp;#39;RNA&amp;#39;]]@data[feature, ])
  maximal&amp;lt;- max(obj[[&amp;#39;RNA&amp;#39;]]@data[feature, ])
  ps&amp;lt;- list()
  for (group in groups) {
    subset_indx&amp;lt;- obj@meta.data[, metadata_column] == group
    subset_cells&amp;lt;- all_cells[subset_indx]
    p&amp;lt;- FeaturePlot(obj, features = feature, cells= subset_cells, ...) +
      scale_color_viridis_c(limits=c(minimal, maximal), direction = 1) +
      ggtitle(group) +
      theme(plot.title = element_text(size = 10, face = &amp;quot;bold&amp;quot;))
    ps[[group]]&amp;lt;- p
  }
  
  
  return(ps)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s test the function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p_list&amp;lt;- FeaturePlotSingle(pbmc, feature= &amp;quot;MS4A1&amp;quot;, metadata_column = &amp;quot;samples&amp;quot;, pt.size = 0.05, order =TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Scale for &amp;#39;colour&amp;#39; is already present. Adding another scale for &amp;#39;colour&amp;#39;,
## which will replace the existing scale.
## Scale for &amp;#39;colour&amp;#39; is already present. Adding another scale for &amp;#39;colour&amp;#39;,
## which will replace the existing scale.
## Scale for &amp;#39;colour&amp;#39; is already present. Adding another scale for &amp;#39;colour&amp;#39;,
## which will replace the existing scale.
## Scale for &amp;#39;colour&amp;#39; is already present. Adding another scale for &amp;#39;colour&amp;#39;,
## which will replace the existing scale.
## Scale for &amp;#39;colour&amp;#39; is already present. Adding another scale for &amp;#39;colour&amp;#39;,
## which will replace the existing scale.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;layout1&amp;lt;-&amp;quot;
ABC
#DE
&amp;quot;

wrap_plots(p_list ,guides = &amp;#39;collect&amp;#39;, design = layout1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-05-23-customize-featureplot-in-seurat-for-multi-condition-comparisons-using-patchwork.en_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You can do even better by moving the legend to the empty space!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## insert the legend space holder to the fourth 
p_list2&amp;lt;- append(p_list, list(legend = guide_area()), 3)


layout2&amp;lt;-&amp;quot;
ABC
DEF
&amp;quot;
wrap_plots(p_list2, guides = &amp;#39;collect&amp;#39;, design = layout2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-05-23-customize-featureplot-in-seurat-for-multi-condition-comparisons-using-patchwork.en_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;patchwork&lt;/code&gt; is amazing and really flexible!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>KMT2D Deficiency Impairs Super-Enhancers to Confer a Glycolytic Vulnerability in Lung Cancer</title>
      <link>/publication/2020-04-03-kmt2d-lung-cancer/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 -0400</pubDate>
      
      <guid>/publication/2020-04-03-kmt2d-lung-cancer/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fast analysis of scATAC-seq data using a predefined set of genomic regions</title>
      <link>/publication/2020-03-20-kallisto-scatac/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 -0400</pubDate>
      
      <guid>/publication/2020-03-20-kallisto-scatac/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>stacked violin plot for visualizing single-cell data in Seurat</title>
      <link>/post/stacked-violin-plot-for-visualizing-single-cell-data-in-seurat/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/stacked-violin-plot-for-visualizing-single-cell-data-in-seurat/</guid>
      <description>&lt;p&gt;In &lt;code&gt;scanpy&lt;/code&gt;, there is a &lt;a href=&#34;https://icb-scanpy-tutorials.readthedocs-hosted.com/en/latest/visualizing-marker-genes.html&#34;&gt;function&lt;/a&gt; to create a stacked violin plot.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/posts_img/scanpy.png&#34; /&gt;
There is no such function in &lt;code&gt;Seurat&lt;/code&gt;, and many people were asking for this feature.
e.g. &lt;a href=&#34;https://github.com/satijalab/seurat/issues/300&#34; class=&#34;uri&#34;&gt;https://github.com/satijalab/seurat/issues/300&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/satijalab/seurat/issues/463&#34; class=&#34;uri&#34;&gt;https://github.com/satijalab/seurat/issues/463&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The developers have not implemented this feature yet. In this post, I am trying to make a stacked violin plot in &lt;code&gt;Seurat&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The idea is to create a violin plot per gene using the &lt;code&gt;VlnPlot&lt;/code&gt; in Seurat, then
customize the axis text/tick and reduce the margin for each plot and finally concatenate by
&lt;code&gt;cowplot::plot_grid&lt;/code&gt; or &lt;code&gt;patchwork::wrap_plots&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)
library(patchwork)
library(ggplot2)

## remove the x-axis text and tick
## plot.margin to adjust the white space between each plot.
## ... pass any arguments to VlnPlot in Seurat
modify_vlnplot&amp;lt;- function(obj, 
                          feature, 
                          pt.size = 0, 
                          plot.margin = unit(c(-0.75, 0, -0.75, 0), &amp;quot;cm&amp;quot;),
                          ...) {
  p&amp;lt;- VlnPlot(obj, features = feature, pt.size = pt.size, ... )  + 
    xlab(&amp;quot;&amp;quot;) + ylab(feature) + ggtitle(&amp;quot;&amp;quot;) + 
    theme(legend.position = &amp;quot;none&amp;quot;, 
          axis.text.x = element_blank(), 
          axis.ticks.x = element_blank(), 
          axis.title.y = element_text(size = rel(1), angle = 0), 
          axis.text.y = element_text(size = rel(1)), 
          plot.margin = plot.margin ) 
  return(p)
}

## extract the max value of the y axis
extract_max&amp;lt;- function(p){
  ymax&amp;lt;- max(ggplot_build(p)$layout$panel_scales_y[[1]]$range$range)
  return(ceiling(ymax))
}


## main function
StackedVlnPlot&amp;lt;- function(obj, features,
                          pt.size = 0, 
                          plot.margin = unit(c(-0.75, 0, -0.75, 0), &amp;quot;cm&amp;quot;),
                          ...) {
  
  plot_list&amp;lt;- purrr::map(features, function(x) modify_vlnplot(obj = obj,feature = x, ...))
  
  # Add back x-axis title to bottom plot. patchwork is going to support this?
  plot_list[[length(plot_list)]]&amp;lt;- plot_list[[length(plot_list)]] +
    theme(axis.text.x=element_text(), axis.ticks.x = element_line())
  
  # change the y-axis tick to only max value 
  ymaxs&amp;lt;- purrr::map_dbl(plot_list, extract_max)
  plot_list&amp;lt;- purrr::map2(plot_list, ymaxs, function(x,y) x + 
                            scale_y_continuous(breaks = c(y)) + 
                            expand_limits(y = y))

  p&amp;lt;- patchwork::wrap_plots(plotlist = plot_list, ncol = 1)
  return(p)
}&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;testing-the-function&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Testing the function&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pbmc&amp;lt;- readRDS(&amp;quot;~/projects/EvaluateSingleCellClustering/data/pbmc_5k_v3.rds&amp;quot;)
features&amp;lt;- c(&amp;quot;CD79A&amp;quot;, &amp;quot;MS4A1&amp;quot;, &amp;quot;CD8A&amp;quot;, &amp;quot;CD8B&amp;quot;, &amp;quot;LYZ&amp;quot;, &amp;quot;LGALS3&amp;quot;, &amp;quot;S100A8&amp;quot;, &amp;quot;GNLY&amp;quot;,
             &amp;quot;NKG7&amp;quot;, &amp;quot;KLRB1&amp;quot;, &amp;quot;FCGR3A&amp;quot;, &amp;quot;FCER1A&amp;quot;, &amp;quot;CST3&amp;quot;)

StackedVlnPlot(obj = pbmc, features = features)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-17-stacked-violin-plot-for-visualizing-single-cell-data-in-seurat_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## any arguments for Vlnplot can be passed to the StackedVlnPlot. e.g. idents.
## only cluster 1-5
StackedVlnPlot(obj = pbmc, features = features, idents = c(1,2,3,4,5) )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-17-stacked-violin-plot-for-visualizing-single-cell-data-in-seurat_files/figure-html/unnamed-chunk-2-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The code can be better designed, and also I should add checks &lt;code&gt;...&lt;/code&gt; using &lt;a href=&#34;https://ellipsis.r-lib.org/&#34;&gt;&lt;code&gt;ellipsis&lt;/code&gt;&lt;/a&gt; package. Nevertheless, it is working and gives me desired layout :)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Tools and tricks for a data scientist</title>
      <link>/talk/2020-tools-tricks-data-science/</link>
      <pubDate>Mon, 09 Mar 2020 14:30:00 -0400</pubDate>
      
      <guid>/talk/2020-tools-tricks-data-science/</guid>
      <description>&lt;p&gt;In the lab meeting today, I introduced some of the linux tricks and apps I have been using
for my daily work. I consider myself as a genomic data scientist. It is a bioinformatician&amp;rsquo;s rebranding according to &lt;a href=&#34;https://twitter.com/JasonWilliamsNY/status/1236671856788242436&#34; target=&#34;_blank&#34;&gt;Jason Williams&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am sharing the PDF here, hope you find some of the tricks are useful too!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Monty Hall problem- a peek through simulation</title>
      <link>/post/monty-hall-problem-a-peek-through-simulation/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/monty-hall-problem-a-peek-through-simulation/</guid>
      <description>&lt;p&gt;I am taking this STATE-80 course from Harvard Extension School. This course teaches
commonly used distributions and probability theory. The instructor Hatch is a
really good teacher and he uses simulation for all the demonstrations along with
the formulas.&lt;/p&gt;
&lt;p&gt;In week 6, we revisited the &lt;a href=&#34;https://en.wikipedia.org/wiki/Monty_Hall_problem&#34;&gt;Monty Hall problem&lt;/a&gt; which we played on the first day of
class.&lt;/p&gt;
&lt;p&gt;If you have not heard about it, I quoted from the wiki:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Suppose you’re on a game show, and you’re given the choice of three doors: Behind one door is a car; behind the others, goats. You pick a door, say No. 1, and the host, who knows what’s behind the doors, opens another door, say No. 3, which has a goat. He then says to you, “Do you want to pick door No. 2?” Is it to your advantage to switch your choice?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/img/Monty_open_door.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The answer is that it &lt;strong&gt;is&lt;/strong&gt; to your advantage to switch the door. The probability of switching the door and get the car is &lt;span class=&#34;math inline&#34;&gt;\(2/3\)&lt;/span&gt; and the probability of not switching is &lt;span class=&#34;math inline&#34;&gt;\(1/3\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Why if I switch I have a better chance to win the car? If the host opened a door with a goat, the car is behind the door of what I have chosen and the one I have not. Is not it 50% of chance to win the car whether I switch or not? It is so counter-intuitive that even &lt;a href=&#34;https://en.wikipedia.org/wiki/Paul_Erd%C5%91s&#34;&gt;Paul Erdős&lt;/a&gt; did not get it at first.&lt;/p&gt;
&lt;p&gt;Let’s tackle it by simulation first and then I will give the formulas to deduce the result.&lt;/p&gt;
&lt;p&gt;The code was copied from Hatch’s lecture notes. The variable names are clearly given and the comments also help you understand the code.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(123)

number.of.goats &amp;lt;- 2

number.of.cars &amp;lt;- 1

cars.goats.vector &amp;lt;-
    c(
        rep( &amp;quot;Goat&amp;quot;, number.of.goats ),
        rep( &amp;quot;Car&amp;quot;, number.of.cars )
    )

total.doors &amp;lt;-
    number.of.goats + number.of.cars

door.vector &amp;lt;- 1:total.doors

number.of.replications &amp;lt;- 10000

outcome.vector &amp;lt;- logical( number.of.replications )

for( replication.index in 1:number.of.replications ) {
    
    # First, we&amp;#39;ll mix up the cars and goats
    # behind the doors
    
    random.cars.goats.vector &amp;lt;-
        sample( cars.goats.vector )
    
    
    # Next, let&amp;#39;s figure out which doors have
    # a goat behind them
    
    goat.doors.vector &amp;lt;-
        which( random.cars.goats.vector == &amp;quot;Goat&amp;quot; )
    
    
    # Now the contestant makes the initial pick
    
    initial.door.pick &amp;lt;-
        sample(
            door.vector,
            size = 1
        )
    
    # The game show host determines which doors
    # can be opened:
    
    possible.to.open.doors.vector &amp;lt;-
        setdiff(
            goat.doors.vector,
            initial.door.pick
        )
    
    if( length( possible.to.open.doors.vector ) == 1 ) {
        
        open.door &amp;lt;- possible.to.open.doors.vector
        
    } else {
        
        open.door &amp;lt;-
            sample(
                possible.to.open.doors.vector,
                size = 1
            )
        
    }
    
    possible.final.door.vector &amp;lt;-
        setdiff(
            door.vector,
            c( initial.door.pick, open.door )
        )
    
    if( length( possible.final.door.vector ) == 1 ) {
        
        final.door.pick &amp;lt;- possible.final.door.vector
        
    } else {
        
        final.door.pick &amp;lt;-
            sample(
                possible.final.door.vector,
                size = 1
            )
        
    }
    
    outcome.vector[ replication.index ] &amp;lt;-
        random.cars.goats.vector[ final.door.pick ] == &amp;quot;Car&amp;quot;

}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let’s check how many times one wins car:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cat( &amp;quot;Sample mean of outcome vector:&amp;quot;,
     round( mean( outcome.vector ), 5 ) )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Sample mean of outcome vector: 0.6705&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is it surprising?! Let me explain in plain words:&lt;/p&gt;
&lt;p&gt;Let’s focus on the strategy of always switching the door after the host opens a door.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;If initially you picked a door behind which there is a car, the host opened a door (from either one) with goat, and you switch. The probability of getting the car is &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;. You had the car behind your initial pick! If you switch, you get the goat.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If initially you picked a door behind which there is a goat, the host &lt;strong&gt;had&lt;/strong&gt; to open the other door with goat, and you switch. The probability of getting the car is &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;, because the host has leaked the information that the car is in the other door that you are going to switch to.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The probability of picking a door that a car behind the door for your initial pick is &lt;span class=&#34;math inline&#34;&gt;\(1/3\)&lt;/span&gt; (from 1, your chance is 0 to win the car). The probability of picking a door that a goat is behind the door for your initial pick is &lt;span class=&#34;math inline&#34;&gt;\(2/3\)&lt;/span&gt; (from 2, your chance is 1 to win the car). So in the long run, you have &lt;span class=&#34;math inline&#34;&gt;\(2/3\)&lt;/span&gt; chance to win the car.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&#34;calculate-by-formulas&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Calculate by formulas&lt;/h3&gt;
&lt;p&gt;The trick to using conditional probabilities is to pick the right event to condition on. For the Monty Hall problem, we will condition on the event that Marie selects the door with the car behind it as her initial choice, and we’ll denote this event &lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;. Then the event &lt;span class=&#34;math inline&#34;&gt;\(A^c\)&lt;/span&gt; is that Marie does &lt;em&gt;not&lt;/em&gt; select the car door as her initial choice, but instead selects a door with a goat behind it. Also, let &lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt; denote the event the event that Marie wins the car in the end. Now suppose Marie adopts the strategy of accepting the offer to change her initial selection after seeing another door opened with a goat behind it.&lt;/p&gt;
&lt;p&gt;As I mentioned above:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B\ |\ A)\ =\ 0
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B\ |\ A^c)\ =\ 1
\]&lt;/span&gt;
What’s the probability that Marie will initially select the door with the car behind it? It’s just 1/3. So we have:
&lt;span class=&#34;math display&#34;&gt;\[
\Pr(A)\ =\ 1/3
\]&lt;/span&gt;
Then by the complement trick, we have:
&lt;span class=&#34;math display&#34;&gt;\[
\Pr(A^c)\ =\ 1 - \Pr(A)\ =\ 2/3
\]&lt;/span&gt;
Now we can use the Law of Total Probability:
&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B)\ =\ \Pr(B\ |\ A) \cdot \Pr(A) + \Pr(B\ |\ A^c) \cdot \Pr(A^c)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Substituting, we obtain:
&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B)\ =\ \left ( 0 \cdot \frac{1}{3} \right ) + \left ( 1 \cdot \frac{2}{3} \right )\ =\ \frac{2}{3}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;monty-hall-with-more-doors&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Monty Hall with more doors&lt;/h3&gt;
&lt;p&gt;Let’s try a Monty hall game with 4 doors behind which are 1 car and 3 goats. Just change&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;number.of.goats &amp;lt;- 3

number.of.cars &amp;lt;- 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will get around &lt;span class=&#34;math inline&#34;&gt;\(3/8\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;With 4 doors, if you initially select a door with a goat, the host opens a door with goat, you will be leaving two doors: one with goat and the other one with car. So you will have &lt;span class=&#34;math inline&#34;&gt;\(1/2\)&lt;/span&gt; chance to win the car.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\Pr(B)\ =\ \left ( 0 \cdot \frac{1}{4} \right ) + \left ( 1/2 \cdot \frac{3}{4} \right )\ =\ \frac{3}{8}
\]&lt;/span&gt;
It is always to your advantage to switch the door because the host has leaked information about the car :)&lt;/p&gt;
&lt;p&gt;Simulation is a very good tool to teach statistic concept and especially for the non-intuitive ones.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>compare kallisto-bustools and cellranger for single nuclei sequencing data</title>
      <link>/post/compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data/</guid>
      <description>&lt;p&gt;In my last &lt;a href=&#34;https://divingintogeneticsandgenomics.rbind.io/post/cellranger-mk-reference-with-transgenes/&#34;&gt;post&lt;/a&gt;, I tried to include transgenes to the cellranger reference and want to
get the counts for the transgenes. However, even after I extended the &lt;code&gt;Tdtomato&lt;/code&gt; and &lt;code&gt;Cre&lt;/code&gt; with
the potential 3’UTR, I still get very few cells express them. This is confusing to me.&lt;/p&gt;
&lt;p&gt;My next thought is: maybe the STAR aligner is doing something weird that excluded those reads?
At this point, I want to give &lt;a href=&#34;https://github.com/pachterlab/kb_python&#34;&gt;&lt;code&gt;kb-python&lt;/code&gt;&lt;/a&gt;, a python wrapper on &lt;code&gt;kallisto&lt;/code&gt; and &lt;code&gt;bustools&lt;/code&gt; a try.&lt;/p&gt;
&lt;p&gt;Before &lt;code&gt;kb-python&lt;/code&gt;, the workflow for processing single-nuclei data using &lt;code&gt;kallisto&lt;/code&gt; and &lt;code&gt;bustools&lt;/code&gt; is cumbersome. see this &lt;a href=&#34;https://github.com/BUStools/getting_started/blob/master/kallisto_bus_mouse_nuclei_tutorial.ipynb&#34;&gt;tutorial&lt;/a&gt; and &lt;a href=&#34;https://www.kallistobus.tools/velocity_index_tutorial.html&#34;&gt;Building a cDNA and intron index&lt;/a&gt;. I was unwilling to try it out until &lt;code&gt;kb-python&lt;/code&gt; supports single-nuclei data as well. &lt;code&gt;kb-python&lt;/code&gt; automates all the steps and greatly simplify the processing.&lt;/p&gt;
&lt;p&gt;kb-python uses the gtf file and genome fasta file for indexing, and it will create the cDNA and intron fasta and the transcript to gene mapping file on the fly.&lt;/p&gt;
&lt;p&gt;It requires the entries with exons should also have a corresponding entry with transcript in the third column of the gtf file.&lt;/p&gt;
&lt;p&gt;Just duplicated the rows below and concatenate with the &lt;code&gt;genes.gtf&lt;/code&gt; from the cellranger website.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;tdtomato        custom  transcript      1       1880    .       +       .       gene_id &amp;quot;ENSMUSGtdtomato&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;tdtomato1&amp;quot;; gene_name &amp;quot;Tdtomato&amp;quot;
tdtomato        custom  exon    1       1880    .       +       .       gene_id &amp;quot;ENSMUSGtdtomato&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;tdtomato1&amp;quot;; gene_name &amp;quot;Tdtomato&amp;quot;
cre     custom  transcript      1       1067    .       +       .       gene_id &amp;quot;ENSMUSGcre&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;cre1&amp;quot;; gene_name &amp;quot;Cre&amp;quot;
cre     custom  exon    1       1067    .       +       .       gene_id &amp;quot;ENSMUSGcre&amp;quot;; gene_version &amp;quot;1&amp;quot;; transcript_id &amp;quot;cre1&amp;quot;; gene_name &amp;quot;Cre&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The developers of &lt;code&gt;kb-python&lt;/code&gt; included a &lt;a href=&#34;https://colab.research.google.com/github/pachterlab/kallistobustools/blob/master/notebooks/kb_single_nucleus.ipynb&#34;&gt;tutorial&lt;/a&gt; for pre-processing single-nuclei data.&lt;/p&gt;
&lt;p&gt;Following it and make a reference:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;## install kbpython
conda create -n kbpython pip
conda activate kbpython
pip install git+https://github.com/pachterlab/kb_python@count-kite

# make a reference
# you can specify -n 8 to split the index to 8 files to reduce the memory usage.
time kb ref -i index.idx -g t2g.txt -f1 cdna.fa -f2 intron.fa -c1 cdna_t2c.txt -c2 intron_t2c.txt --workflow nucleus -n 1 genome.fa genes.gtf &amp;gt; log.txt  2&amp;gt;&amp;amp;1

real    266m53.243s
user    229m5.505s
sys     37m7.056s

## count
ref_dir=&amp;quot;/reference_genome_by_tommy/kallisto_bus_ref/mm10_nuclei_single&amp;quot;

fastq_dir=&amp;quot;novaseq/outs/fastq_path/HJF3WDMXX/Sample1&amp;quot;

time kb count -i ${ref_dir}/index.idx \
-g ${ref_dir}/t2g.txt -c1 ${ref_dir}/cdna_t2c.txt -c2 ${ref_dir}/intron_t2c.txt -x 10xv2 -o sample1_kb_h5ad -t 15 --workflow nucleus --h5ad \
${fastq_dir}/Sample1_S1_L001_R1_001.fastq.gz \
${fastq_dir}/Sample1_S1_L001_R2_001.fastq.gz \
${fastq_dir}/Sample1_S1_L002_R1_001.fastq.gz \
${fastq_dir}/Sample1_S1_L002_R2_001.fastq.gz

real    101m39.986s
user    899m28.925s
sys     114m7.979s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside the &lt;code&gt;sample1_kb_h5ad&lt;/code&gt; output folder, there is a &lt;code&gt;counts_unfiltered&lt;/code&gt; folder which contains the files we are going to work with.&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;ls counts_unfiltered/
adata.h5ad  spliced.barcodes.txt  spliced.genes.txt  spliced.mtx  unspliced.barcodes.txt  unspliced.genes.txt  unspliced.mtx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two matrices, spliced and unspliced. We need to sum up them together to get the final counts. The &lt;code&gt;adata.h5ad&lt;/code&gt; is H5AD file contains the summed up matrix.&lt;/p&gt;
&lt;p&gt;Some tips after playing with &lt;code&gt;kb-python&lt;/code&gt; for a bit:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Specify the wrong protocol will give you errors. &lt;strong&gt;If you specify &lt;code&gt;10xv2&lt;/code&gt;, go and check the raw fastq and make sure it is 16 bp cell barcode + 10 bp UMI. If you specify &lt;code&gt;10xv3&lt;/code&gt;, make sure it is 16 bp cell barcode + 12 bp UMI.&lt;/strong&gt; Ideally, &lt;code&gt;kb-python&lt;/code&gt; should check the input.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sometimes, if you specify &lt;code&gt;--h5ad&lt;/code&gt;, when combining the two spliced and unspliced sparse matrix, it gives error: &amp;quot;in _get_arrayXarray csr_sample_values(M, N, self.indptr, self.indices, self.data, ValueError: could not convert integer scalar&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you specify whitelist by &lt;code&gt;-w&lt;/code&gt;, use the unzipped txt file. Otherwise, you may get “died with &amp;lt;Signals.SIGSEGV: 11&amp;gt;” error.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;kb-python&lt;/code&gt; is strict with your gtf file. You may get an error when making references. I had some non-model gff3 file downloaded from NCBI and then converted to gtf using &lt;code&gt;gffread&lt;/code&gt;, but &lt;code&gt;kb-python&lt;/code&gt; complains about it.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;downstream-analysis-in-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Downstream analysis in R&lt;/h3&gt;
&lt;p&gt;Now, let’s import the data into R.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)

Sample1&amp;lt;- ReadH5AD(&amp;quot;~/github_repos/blogdown_data/counts_unfiltered/adata.h5ad&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I got this error:
“Pulling expression matrices and metadata
Data is unscaled
Error in file[[&amp;quot;obs&amp;quot;]][] :
object of type ‘environment’ is not subsettable”&lt;/p&gt;
&lt;p&gt;I have to work with the &lt;code&gt;.mtx&lt;/code&gt; files.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Matrix)
library(tidyverse)

# a function to read in the kallisto count matrix
read_kallisto_sparse&amp;lt;- function(cells, regions, mtx){
  mtx&amp;lt;- Matrix::readMM(mtx)
  # the sparse matrix with rows are cells and columns are peaks/features
  mtx&amp;lt;- t(mtx)
  regions&amp;lt;- read_tsv(regions, col_names = FALSE)
  cells&amp;lt;- read_tsv(cells, col_names = FALSE)
  rownames(mtx)&amp;lt;- regions$X1
  # cellranger add -1 to the cell barcode, I add it for later compare with cellranger output
  colnames(mtx)&amp;lt;- paste0(cells$X1, &amp;quot;-1&amp;quot;)
  return(mtx)
}

spliced&amp;lt;- read_kallisto_sparse(cells = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/spliced.barcodes.txt&amp;quot;,
                               regions = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/spliced.genes.txt&amp;quot;,
                               mtx = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/spliced.mtx&amp;quot;)

unspliced&amp;lt;- read_kallisto_sparse(cells = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/unspliced.barcodes.txt&amp;quot;,
                               regions = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/unspliced.genes.txt&amp;quot;,
                               mtx = &amp;quot;~/github_repos/blogdown_data/counts_unfiltered/unspliced.mtx&amp;quot;)

## common index
common_cells&amp;lt;- intersect(colnames(spliced), colnames(unspliced))
spliced&amp;lt;- spliced[, colnames(spliced) %in% common_cells]
unspliced&amp;lt;- unspliced[, colnames(unspliced) %in% common_cells]

# make sure the cells and genes are lined up
all.equal(colnames(spliced), colnames(unspliced))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all.equal(rownames(spliced), rownames(unspliced))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## add up the counts
Sample1_kb&amp;lt;- spliced + unspliced

# the rowname and colnames are lost, put them back
rownames(Sample1_kb)&amp;lt;- rownames(spliced)
colnames(Sample1_kb)&amp;lt;- colnames(spliced)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The matrices are unfiltered, we can filter out some cells using the knee-plot. There are several nice posts on how to
by the &lt;a href=&#34;https://github.com/CGATOxford/UMI-tools&#34;&gt;&lt;code&gt;UMI-tools&lt;/code&gt;&lt;/a&gt; developers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://cgatoxford.wordpress.com/2017/05/18/estimating-the-number-of-true-cell-barcodes-in-single-cell-rna-seq/&#34; class=&#34;uri&#34;&gt;https://cgatoxford.wordpress.com/2017/05/18/estimating-the-number-of-true-cell-barcodes-in-single-cell-rna-seq/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://cgatoxford.wordpress.com/2017/05/23/estimating-the-number-of-true-cell-barcodes-in-single-cell-rna-seq-part-2/&#34; class=&#34;uri&#34;&gt;https://cgatoxford.wordpress.com/2017/05/23/estimating-the-number-of-true-cell-barcodes-in-single-cell-rna-seq-part-2/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(DropletUtils)

tot_counts &amp;lt;- Matrix::colSums(Sample1_kb)

## many of them have very low counts per cell
summary(tot_counts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     0.0     2.0     3.0   287.2    16.0 96681.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Compute barcode rank from Dropletutils
bc_rank &amp;lt;- barcodeRanks(Sample1_kb)

qplot(bc_rank$total, bc_rank$rank, geom = &amp;quot;line&amp;quot;) +
  geom_vline(xintercept = bc_rank$knee, color = &amp;quot;blue&amp;quot;, linetype = 2) +
  geom_vline(xintercept = bc_rank$inflection, color = &amp;quot;green&amp;quot;, linetype = 2) +
  annotate(&amp;quot;text&amp;quot;, y = 1000, x = 1.5 * c(bc_rank$knee, bc_rank$inflection),
           label = c(&amp;quot;knee&amp;quot;, &amp;quot;inflection&amp;quot;), color = c(&amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;)) +
  scale_x_log10() +
  scale_y_log10() +
  labs(y = &amp;quot;Barcode rank&amp;quot;, x = &amp;quot;Total UMI count&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Filter the matrix using this cutoff
Sample1_kb &amp;lt;- Sample1_kb[, tot_counts &amp;gt; bc_rank$inflection]

## 73676 cells are left
dim(Sample1_kb)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 28694 73676&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is way more than the cells we have in this experiment. As I will show later, cellranger gives ~10,000 cells which is about the right number of cells we have.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;kallisto-bustools-and-cellranger-correlation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;kallisto + bustools and cellranger correlation&lt;/h3&gt;
&lt;p&gt;cellranger output&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Seurat)
# this is the cellranger output. read in the sparse matrix
Sample1_cr&amp;lt;- Read10X_h5(filename = &amp;quot;~/github_repos/blogdown_data/filtered_feature_bc_matrix.h5&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## cells pass cellranger and Seurat filter
colnames(Sample1_cr) %&amp;gt;% 
  length()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10937&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## how many cells from the kb-python are in the cellranger output
(colnames(Sample1_kb) %in% colnames(Sample1_cr)) %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
## FALSE  TRUE 
## 62739 10937&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All the cells in &lt;code&gt;kb-python&lt;/code&gt; output are in &lt;code&gt;cellranger&lt;/code&gt; output.&lt;/p&gt;
&lt;p&gt;subset the &lt;code&gt;kb-python&lt;/code&gt; matrix and rearrange the rows and columns to match each other.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# kb-python uses the ENSMBEL id
rownames(Sample1_kb) %&amp;gt;% head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;ENSMUSG00000026535.9&amp;quot;  &amp;quot;ENSMUSG00000026315.13&amp;quot; &amp;quot;ENSMUSG00000000817.10&amp;quot;
## [4] &amp;quot;ENSMUSG00000063558.4&amp;quot;  &amp;quot;ENSMUSG00000001138.13&amp;quot; &amp;quot;ENSMUSG00000001143.13&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cellranger uses the gene symbol
rownames(Sample1_cr) %&amp;gt;% head()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Xkr4&amp;quot;    &amp;quot;Gm1992&amp;quot;  &amp;quot;Gm37381&amp;quot; &amp;quot;Rp1&amp;quot;     &amp;quot;Rp1.1&amp;quot;   &amp;quot;Sox17&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## read in the transcript to gene map file t2g.txt was created when making kb-python index.
t2g&amp;lt;- read_tsv(&amp;quot;~/github_repos/blogdown_data/t2g.txt&amp;quot;, col_names = FALSE, col_types = cols(.default = col_character()))

head(t2g)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 8
##   X1             X2             X3     X4       X5    X6      X7      X8   
##   &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;
## 1 ENSMUST000000… ENSMUSG000000… Ifi20… Ifi202b… 1     173962… 173982… -    
## 2 ENSMUST000000… ENSMUSG000000… Serpi… Serpinb… 1     107590… 107608… +    
## 3 ENSMUST000000… ENSMUSG000000… Fasl   Fasl-001 1     161780… 161788… -    
## 4 ENSMUST000000… ENSMUSG000000… Aox1   Aox1-001 1     580299… 581064… +    
## 5 ENSMUST000000… ENSMUSG000000… Cnnm3  Cnnm3-0… 1     365118… 365282… +    
## 6 ENSMUST000000… ENSMUSG000000… Lman2l Lman2l-… 1     364231… 364452… -&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ensemble2symbol&amp;lt;- t2g %&amp;gt;% 
  dplyr::select(X2,X3) %&amp;gt;% distinct()

head(ensemble2symbol)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 2
##   X2                    X3      
##   &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;   
## 1 ENSMUSG00000026535.9  Ifi202b 
## 2 ENSMUSG00000026315.13 Serpinb8
## 3 ENSMUSG00000000817.10 Fasl    
## 4 ENSMUSG00000063558.4  Aox1    
## 5 ENSMUSG00000001138.13 Cnnm3   
## 6 ENSMUSG00000001143.13 Lman2l&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# not all genes in cellranger matrix are in this mapping file...
table(rownames(Sample1_cr) %in% ensemble2symbol$X3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
##    67 28627&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## what are the genes?
problematic_genes&amp;lt;- rownames(Sample1_cr)[!(rownames(Sample1_cr) %in% ensemble2symbol$X3)]
problematic_genes&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Rp1.1&amp;quot;           &amp;quot;Gm15853.1&amp;quot;       &amp;quot;Gm16701.1&amp;quot;      
##  [4] &amp;quot;Olfr1284.1&amp;quot;      &amp;quot;Olfr1309.1&amp;quot;      &amp;quot;Olfr1316.1&amp;quot;     
##  [7] &amp;quot;Gm2464.1&amp;quot;        &amp;quot;Schip1.1&amp;quot;        &amp;quot;Flg.1&amp;quot;          
## [10] &amp;quot;Flg.2&amp;quot;           &amp;quot;Flg.3&amp;quot;           &amp;quot;Flg.4&amp;quot;          
## [13] &amp;quot;Flg.5&amp;quot;           &amp;quot;Flg.6&amp;quot;           &amp;quot;Hist2h2bb.1&amp;quot;    
## [16] &amp;quot;Smim20.1&amp;quot;        &amp;quot;Dancr.1&amp;quot;         &amp;quot;Gbp6.1&amp;quot;         
## [19] &amp;quot;D130017N08Rik.1&amp;quot; &amp;quot;Umad1.1&amp;quot;         &amp;quot;Ccdc142.1&amp;quot;      
## [22] &amp;quot;Zfand4.1&amp;quot;        &amp;quot;C1s2.1&amp;quot;          &amp;quot;Atn1.1&amp;quot;         
## [25] &amp;quot;Pik3c2g.1&amp;quot;       &amp;quot;Nova2.1&amp;quot;         &amp;quot;Apoc2.1&amp;quot;        
## [28] &amp;quot;Ltbp4.1&amp;quot;         &amp;quot;U2af1l4.1&amp;quot;       &amp;quot;Tead2.1&amp;quot;        
## [31] &amp;quot;Cd37.1&amp;quot;          &amp;quot;Tulp2.1&amp;quot;         &amp;quot;Tulp2.2&amp;quot;        
## [34] &amp;quot;Ntn5.1&amp;quot;          &amp;quot;Ntn5.2&amp;quot;          &amp;quot;Syngr4.1&amp;quot;       
## [37] &amp;quot;l7Rn6.1&amp;quot;         &amp;quot;Itgam.1&amp;quot;         &amp;quot;Tgfb1i1.1&amp;quot;      
## [40] &amp;quot;Olfr790.1&amp;quot;       &amp;quot;Olfr809.1&amp;quot;       &amp;quot;Map2k7.1&amp;quot;       
## [43] &amp;quot;Olfr730.1&amp;quot;       &amp;quot;Fbxw14.1&amp;quot;        &amp;quot;Olfr1396.1&amp;quot;     
## [46] &amp;quot;Olfr1366.1&amp;quot;      &amp;quot;3110039M20Rik.1&amp;quot; &amp;quot;Ighv5-8.1&amp;quot;      
## [49] &amp;quot;Ighv1-13.1&amp;quot;      &amp;quot;4930556M19Rik.1&amp;quot; &amp;quot;Sgsm3.1&amp;quot;        
## [52] &amp;quot;Olfr170.1&amp;quot;       &amp;quot;Olfr108.1&amp;quot;       &amp;quot;Olfr126.1&amp;quot;      
## [55] &amp;quot;Pcdha11.1&amp;quot;       &amp;quot;Pcdhga8.1&amp;quot;       &amp;quot;Olfr1496.1&amp;quot;     
## [58] &amp;quot;Fam205a2.1&amp;quot;      &amp;quot;Ccl21b.1&amp;quot;        &amp;quot;Il11ra2.1&amp;quot;      
## [61] &amp;quot;Ccl27a.1&amp;quot;        &amp;quot;Ccl21c.1&amp;quot;        &amp;quot;Gm3286.1&amp;quot;       
## [64] &amp;quot;Ccl27a.2&amp;quot;        &amp;quot;Il11ra2.2&amp;quot;       &amp;quot;Ccl19.1&amp;quot;        
## [67] &amp;quot;Ccl21a.1&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## how about we remove the .1 and .2
problematic_genes %&amp;gt;% str_replace(&amp;quot;\\.[1-9]$&amp;quot;, &amp;quot;&amp;quot;) %in% ensemble2symbol$X3 %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
## TRUE 
##   67&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;They all are in the &lt;code&gt;ensemble2symbol&lt;/code&gt; file now if remove the version number.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# there are other gene symbols ends with .1 and .2... but has a corresponding name in ensemble2symbol...
# I can not use str_replace(&amp;quot;\\.1$&amp;quot;, &amp;quot;&amp;quot;)
# rownames(Sample1_cr) [rownames(Sample1_cr) %&amp;gt;% str_detect(&amp;quot;\\.[0-9]$&amp;quot;) ] 

# find the index and replace with the symbols without version number
problematic_indx&amp;lt;- which(rownames(Sample1_cr) %in% problematic_genes)

rownames(Sample1_cr)[problematic_indx]&amp;lt;- problematic_genes %&amp;gt;% 
  str_replace(&amp;quot;\\.[1-9]$&amp;quot;, &amp;quot;&amp;quot;)

rownames(Sample1_kb) %in% ensemble2symbol$X2 %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
##  TRUE 
## 28694&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rownames(Sample1_cr) %in% ensemble2symbol$X3 %&amp;gt;% table()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## .
##  TRUE 
## 28694&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# a dictionary like vector with names are ensemble id and values are gene symbol
gene_map&amp;lt;- ensemble2symbol %&amp;gt;% tibble::deframe() 

## change the ensembel id with gene symbol
rownames(Sample1_kb)&amp;lt;- gene_map[rownames(Sample1_kb)] %&amp;gt;% unname()

#rearrange the columns and rows
Sample1_kb&amp;lt;- Sample1_kb[rownames(Sample1_cr),colnames(Sample1_cr)]

## final check the rows and columns are lined up
all.equal(colnames(Sample1_kb), colnames(Sample1_cr))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all.equal(rownames(Sample1_kb), rownames(Sample1_cr))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let me check the transgene expression in both pipelines.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# from kb-python
table(Sample1_kb[&amp;quot;Cre&amp;quot;, ] !=0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
## 10728   209&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(Sample1_kb[&amp;quot;Tdtomato&amp;quot;, ]!=0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
## 10715   222&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# from cellranger
table(Sample1_cr[&amp;quot;Cre&amp;quot;, ] !=0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
## 10742   195&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(Sample1_cr[&amp;quot;Tdtomato&amp;quot;, ]!=0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
## 10783   154&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kb-python&lt;/code&gt; detected more cells express the transgens, but still the number is very low. I will
need to keep investigating the reason.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;calculate-the-correlation-between-the-two-pipelines&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Calculate the correlation between the two pipelines&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cor(matrixA, matrixB)&lt;/code&gt; calculates the pair-wise correlation, one can use diag() to extract the
column correlations, but for big data matrix, it is not efficient.&lt;/p&gt;
&lt;p&gt;googled and found &lt;a href=&#34;https://stackoverflow.com/questions/6713973/how-do-i-calculate-correlation-between-corresponding-columns-of-two-matrices-and&#34; class=&#34;uri&#34;&gt;https://stackoverflow.com/questions/6713973/how-do-i-calculate-correlation-between-corresponding-columns-of-two-matrices-and&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# from arrayMagic Bioconductor package
colCors = function(x, y) { 
   sqr = function(x) x*x
   if(!is.matrix(x)||!is.matrix(y)||any(dim(x)!=dim(y)))
     stop(&amp;quot;Please supply two matrices of equal size.&amp;quot;)
   x   = sweep(x, 2, colMeans(x))
   y   = sweep(y, 2, colMeans(y))
   cor = colSums(x*y) /  sqrt(colSums(sqr(x))*colSums(sqr(y)))
   return(cor)
}

cors&amp;lt;- colCors(as.matrix(Sample1_cr), as.matrix(Sample1_kb))
head(cors)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## AAACCCAAGCAAGTGC-1 AAACCCAAGCGTGAGT-1 AAACCCAAGCTAGAAT-1 
##          0.9667430          0.8787159          0.9046970 
## AAACCCAAGCTCGTGC-1 AAACCCAAGCTGAAGC-1 AAACCCAAGCTGTCCG-1 
##          0.7184020          0.9463552          0.9077403&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I will make figures similar to the ones in the original &lt;code&gt;kallisto&lt;/code&gt; + &lt;code&gt;bustool&lt;/code&gt; paper &lt;a href=&#34;https://www.biorxiv.org/content/10.1101/673285v1&#34; class=&#34;uri&#34;&gt;https://www.biorxiv.org/content/10.1101/673285v1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Fig2B plots a scatter plot of the total number of UMIs for each cell from the two pipelines.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# set up the theme for all figures
# take suggestions for theme https://twitter.com/ChenxinLi2/status/1228958667686338560
theme_set(theme_minimal() +
  theme(axis.line = element_line(colour = &amp;quot;black&amp;quot;, 
                      size = 1, linetype = &amp;quot;solid&amp;quot;),
        text = element_text(size = 18, color = &amp;quot;black&amp;quot;),  #face = &amp;quot;bold&amp;quot;
        axis.text.x = element_text(size = 18, color = &amp;quot;black&amp;quot;),
        axis.text.y = element_text(size = 18, color = &amp;quot;black&amp;quot;)))


Matrix::colSums(Sample1_cr) %&amp;gt;%
  enframe(name = &amp;quot;cell&amp;quot;, value = &amp;quot;CR_totalUMI&amp;quot;) %&amp;gt;% 
  bind_cols(KB_totalUMI= Matrix::colSums(Sample1_kb)) %&amp;gt;% 
  ggplot(aes(x = KB_totalUMI, y = CR_totalUMI)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  coord_equal() + 
  geom_abline(slope =1, intercept = 0, linetype=2, color = &amp;quot;red&amp;quot;) +
  ggtitle(&amp;quot;total UMI per cell\nkb-python vs cellranger&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kb-python always have more counts than cellranger for single-nuclei data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fig2C plots the correlation of counts from two pipelines for the same cell.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# install.packages(&amp;quot;ggpointdensity&amp;quot;)
library(ggpointdensity)
library(viridis)
df&amp;lt;- Matrix::colSums(Sample1_kb) %&amp;gt;%
  enframe(name = &amp;quot;cell&amp;quot;, value = &amp;quot;KB_totalUMI&amp;quot;) %&amp;gt;%
  bind_cols(cors = cors) 


ggplot(df, aes(x= KB_totalUMI, y = cors)) +
  geom_pointdensity(adjust = .2) +
  scale_x_log10() + 
  scale_color_viridis() +
  ggtitle(&amp;quot;pearson correlation per cell as a \nfunction of total UMI by kb-python&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;most of the correlations are higher than 0.8.&lt;/strong&gt;, but not as good as for the single-cell data showed in the biorxiv paper.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(df$cors &amp;lt; 0.8)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## FALSE  TRUE 
##  9016  1921&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition, too many zeros can inflate the correlation.
Let’s remove the genes if the counts from two pipelines are both 0s.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# mapply(cor, as.data.frame(x), as.data.frame(y))

# map2 takes columns of df1 and df2 as argument and apply cor function to each pair of columns
cors2&amp;lt;- map2_dbl( as.data.frame(Sample1_cr), as.data.frame(Sample1_kb), cor)
all.equal(cors, cors2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor_remove_zero&amp;lt;- function(x,y){
  indx&amp;lt;- (x==0 &amp;amp; y==0)
  return(cor(x[!indx],y[!indx]))
}

cors_remove_zeros&amp;lt;- map2_dbl( as.data.frame(Sample1_cr), as.data.frame(Sample1_kb), cor_remove_zero)

df2&amp;lt;- Matrix::colSums(Sample1_kb) %&amp;gt;%
  enframe(name = &amp;quot;cell&amp;quot;, value = &amp;quot;KB_totalUMI&amp;quot;) %&amp;gt;%
  bind_cols(cors_remove_zeros = cors_remove_zeros) 

# boxplot for correlations before and after removing 0s 
inner_join(df, df2) %&amp;gt;%
  gather(3:4, key = &amp;quot;group&amp;quot;, value = &amp;quot;correlation&amp;quot;) %&amp;gt;% 
  ggplot(aes(x=group, y = correlation)) +
  geom_boxplot() +
  xlab(&amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We see removing zeros decreases the correlation a bit.&lt;/p&gt;
&lt;p&gt;Let’s plot side by side.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1&amp;lt;- ggplot(df, aes(x= KB_totalUMI, y = cors)) +
  geom_pointdensity(adjust = .2) +
  scale_x_log10() + 
  scale_color_viridis() +
  ggtitle(&amp;quot;correlation&amp;quot;)


p2&amp;lt;- ggplot(df2, aes(x= KB_totalUMI, y = cors)) +
  geom_pointdensity(adjust = .2) +
  scale_x_log10() + 
  scale_color_viridis() +
  ggtitle(&amp;quot;correlation removing 0s&amp;quot;)

#install.packages(&amp;quot;patchwork&amp;quot;)
# use patchwork to combine the legends from multiple plots
library(patchwork)
p1 / p2 + plot_layout(guides = &amp;quot;collect&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-02-21-compare-kallisto-bustools-and-cellranger-for-single-nuclei-seqencing-data_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I have not seen many posts comparing cellranger with &lt;code&gt;kallisto + bustools&lt;/code&gt; for single nuclei data. I hope this post opens the discussion for the single-cell RNAseq community.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kallisto + bustools&lt;/code&gt; always gives more counts for single-nuclei data, why is that?&lt;/li&gt;
&lt;li&gt;Why the correlation between cellranger and &lt;code&gt;kallisto + bustools&lt;/code&gt; is not as good for single-nuclei data?&lt;/li&gt;
&lt;li&gt;For those cells with bad correlation, what’s going on?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Comment below!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>LATS kinase–mediated CTCF phosphorylation and selective loss of genomic binding</title>
      <link>/publication/2020-02-19-lats-ctcf/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 -0500</pubDate>
      
      <guid>/publication/2020-02-19-lats-ctcf/</guid>
      <description>&lt;p&gt;More detail can easily be written here using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
